
## CH 5. 책임 할당하기 

---
### 책임 주도 설계를 향해 

책임 중심의 설계로 전환하기 위해 다음 2 가지 원칙을 따라야 한다.

1. 데이터보다 행동을 먼저 결정해라! -> 이전 장에서 봤던 데이터 중심 설계 시 문제가 되기 때문이다.
2. 협력이라는 문맥 안에서 책임을 결정해라 -> 협력에서 정해져있지 않으면 올바른 객체를 설계하기가 힘들다.


### 데이터보다 행동을 먼저 결정

 데이터를 중심으로 하여 설계를 하다보니 행동에 따라 움직이는 느낌보다 상태에 따라서 움직여지는 경향이 많이 보였다.
그렇게 하면 당연히 응집도가 낮아지고 결합도가 높아지는 현상이 생겨날 수 밖에 없게 된다. 그러니 앞으로 설계를 할 때는 행동을 중심으로 설계를 하는 것이 좋다.

### 적절한 책임을 할당하는 방법

객체지향에서 가장 중요한 것은 **적절한 객체에게 적절한 책임을 할당하는 능력이다.** 이렇게 할당하기 위해서는 어떻게 해야 될까?

바로 협력에 적합한 책임을 결정해야 하는 것이다. 어떤 협력을 하는지를 알아야지 책임을 주고 적당한 메시지를 던져서 객체를 선택할거다. 그런데 그러한 과정을 고려하지 않는다면 
당연히 설계 중간에 꼬일수도 있고 의미없는 객체들이 생성될 가능성이 많다. 

설계가 이상하게 되는 경우가 다음과 같다. 
> Client -> Screening -> Movie 이렇게 화살표로 이어지는 사이에 아무런 관계의 이유가 없다면 다 의미없는 객체가 되는 것이다.

여기 화살표는 메시지의 역할을 하는 것과 같다. 그래서 우리는 항상 메시지를 통해 책임을 할당시켜 전달하는 과정이 먼저 되어야 자동적으로 캡슐화가 잘 되어질 수 있다는 점을 잘 기억하고 가야 한다.

**메시지를 결정하고 그 다음 객체를 만들면 캡슐화가 잘 되어질 수 있다.(협력이라는 문맥에서 책임을 결정시키자!)** 

### 책임 주도 설계

다음은 앞선 장에서 살펴본 설계의 흐름이다.

- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

이 뒤부턴 책에서 다음과 같은 방법을 통해서 만들게 된 흐름들을 하나하나씩 뜯어볼 거다.

---

### GRASP 패턴
>GRASP(General Responsibility Assignment Software Pattern) : 일반적인 책임 할당을 위한 소프트웨어 패턴의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원리들의 집합을 패턴 형식으로 정의한 것이다.

### 다시 처음부터 살펴보기
이제부터 다시 처음부터 도메인 설계부터 시작해서 코드를 어떤 식으로 설계를 해나가야 하는지에 대한 설명이 책에 함께 나와있으니 책을 보면서 같이 문서를 읽으면 좋을 거 같다.

### 도메인 개념에서부터 시작

우리가 예시로 설계하는 것은 영화의 예매의 과정이다. 책에서는 그림으로 그려져있지만 목차로 분류해보면 다음과 같다.

- 고객이 예매 
- 상영에 대한 정보 
- 영화에 대한 내용(금액에 대한 할인인지, 비율에 대한 할인인지) 
- 할인의 조건이 어떻게 되는지 (순번에 대한 조건이 있는지, 기간에 대한 조건이 있는지)

이런 순서대로 살펴보게 되는데 솔직히 말해서 이건 아직 정제되지 않은 느낌이다. 그치만 **처음에 완벽한 설계는 없는 것처럼 도메인 설계에 시간을 낭비하지 말고 빠르게 설계와 구현을 진행하라!** 라고 책에서는 언급한다. 


### 전문가에게 책임을 할당하자.

사실 객체를 설계할 때 협력이라는 것이 엄청 중요하다고 했는데 현실 세계에서도 어찌보면 사람이 각자 잘하는 분야가 있어서 나중에 협력하여서 제품들을 개발하듯이 객체끼리도 그렇게 진행해야
한다고 많이 느꼈다. 그래서 객체 하나가 일을 다 하는 것보다 내가 원하는 것에 대한 정보 전문가에게 도움을 구하는 형식으로 설계해나가는 방향이 책임을 잘 할당할 수 있었다.

예시로 보면 다음과 같다.

1. 영화를 예매하라! 라는 메시지를 보낼 필요가 있다.
2. 이 메시지를 수신할 적절한 객체가 누구일까?

아직 객체를 정하지 않았기에 이 메시지를 처리해야 한다. 2번의 질문에 답하기 위하여 객체가 상태와 행동을 통합한 캡슐화의 단위라는 사실에 집중을 해야 한다. 그리고 객체는 자신의 상태를 스스로 처리하는
자율적인 존재여야 한다. 그래서 **첫 번째 원칙으로서 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것 그것을 INFORMATION EXPERT(정보 전문가)** 패턴이라고 부른다. 

위 패턴에 따라가보면 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 **캡슐화를 유지할 수 있다.**

이 패턴의 이름처럼 정보 전문가패턴을 통하여서 관련된 작업을 수행한다고 것을 표현한 것이다. 그런데 중요한 것이 **정보 전문가라고 해서 정보를 처리하지 저장할 필요는 없다** 라는 사실을 잘 알고 가야한다.

### 예매하는 설계 중 적용되는 전문가 패턴

1. 예매하라 -> Screening
2. Screening -> 영화 가격을 계산하라
3. 가격을 계산하라 -> Movie
4. Movie -> 할인 여부를 판단하라 
5. 할인 여부를 판단하라 -> DiscountCondition

각각의 전문가에게 계속해서 먼저 메시지를 정한 후에 할당해준다는 것을 알 수 있다.

### 높은 응집도와 낮은 결합도
GRASP에서는 이를 `LOW COUPLING(낮은 결합도)`, `HIGH COHESION(높은 응집도)` 패턴이라고 부르기로 했다. 

상황을 하나 부여해 보자면 Movie에다가 DiscountCondition을 붙이는게 아닌 Screening에다가 붙이면?

금액을 계산하기로 한 곳에서 연결해서 하면 될 것을 굳이 Movie에서 Screening을 거쳐서 다시 DiscountCondition으로 가게 된다면?

너무 비효율적인 것처럼 보일 뿐더러 응집도가 낮아지고 Screening의 결합도가 되게 높아지게 된다. 그래서 우리는 항상 **높은 응집도, 낮은 결합도** 를 유지하기 위해서 매순간마다 생각하면서 설계를 하면 재사용 가능하고 유연한 설계를 얻게 될 것이다.

### 창조자에게 객체 생성 책임을 할당하자

GRASP에서는 `CREATER` 패턴이라는 것이 존재한다. 창조자 패턴이라는 말처럼 객체 생성의 책임을 할당하는 것이다. 

책의 그림에서는 `Screening`이 `Reservation`이라는 객체의 `CREATOR`가 된다. 왜냐하면 예매 정보를 생성하기 위한 정보들을 다 가지고 있기 때문이다. 

이런식으로 앞에 나오는대로 창조를 시키는 책임, 각자의 전문가에게 맡기는 책임을 토대로 설계를 해나가면 자동적으로 높은 응집도와 낮은 결합도가 형성이 된다.

---

### 문제가 되는 DiscountCondition

책에서 언급한대로 구현을 그대로 하면서 보게 될 경우 DiscountCondition에서 Period, Sequence에 따른 메서드가 존재한다.  p.150

그러면 문제점이 3가지가 있다.

- 새로운 할인 조건을 추가하게 되면? -> 새로운 할인 조건에서 새로운 데이터를 요구하면 속성을 추가해야 한다.
- 순번 조건을 판단하는 로직이 변경되면? -> 메서드 내부를 수정하게 될 경우 밖에 존재하는 DiscountCondition의 sequence를 수정해야 할 수 있다.
- 기간 조건을 판단하는 로직이 변경되면? -> 위와 마찬가지로 메서드 밖의 데이터들을 수정해야 한다.

DiscountCondition에서 하나 이상의 변경되는 이유를 가지기에 응집도가 낮다.

### 응집도가 낮다?
>응집도가 낮다는 것은 서로 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있는 것을 의미한다. 

이렇게 되니 클래스를 분리해야 한다!

### 코드를 통해 보는 클래스 분리를 해야하는 상황

1. 인스턴스 변수가 초기화 되는 시점을 본다.
2. 메서드들이 인스턴스 변수를 사용하는 방식을 본다.

1번의 경우 DiscountCondition에서는 순번 조건을 사용할 때 sequence를 초기화 하게 되고 나머지 날짜, 시간은 고려하지 않는다. 반대의 경우도 마찬가지이다.

2번의 경우에도 1번과 맥락은 비슷하다. 그래서 관련이 없는 상태들이 같은 클래스 안에 존재하는 것 자체가 응집도가 낮아진다는 것이다.

그래서 클래스의 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.

> 클래스 응집도 판단하기
> - 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라.
> - 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화되는 속성의 그룹을 기준으로 클래스를 분리하라.
> - 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라. 


그래서 정리하면 한 클래스를 분리하는 기준은 메서드에서 사용하는 속성들이 있는데 만약에 관련이 없는 속성들이 있다면 그때는 바로 분리해야한다! 응집도가 낮아지기 때문이다.


### DiscountCondition을 Sequence, Period Condition으로 나누자

이런 식으로 이제 클래스를 분리만 하면 괜찮아질 줄 알았는데 Movie에서 사용해야 할 클래스가 2개가 더 생겼다. 이러면 결합도가 높아진다. 

그런데 또 생각해볼 것이 뭐냐면 Movie의 입장에서는 그냥 할인 조건들일 뿐이다. 나누긴 했어도 **역할** 은 똑같다! 그래서 이제 다형성을 활용해 보는 것이다.

항상 헷갈리던게 있었는데 어떻게 해야지 추상 클래스? 아니면 인터페이스?를 사용해야 될까 고민했었다.
- 구현을 공유해야 하면 -> `추상 클래스`
- 구현을 공유할 필요가 없고 책임만 정의할거라면 -> `인터페이스`

이것을 잘 알아야 한다. 그래서 이번 DiscountCondition이라는 인터페이스를 만들면 된다. 구현이 공유될 필요가 아예 없었으니까! 그냥 isSatisfiedBy 메시지를 이해할 수 있다는 사실만 알고 있어도 충분하다.

### 다형성

> 다형성: 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로써 할당하라는 것

말이 되게 추상적인데 객체의 타입: DiscountCondition 변하는 행동 : Period, Sequence 이렇게 생각하고 보면 될 거 같다.

### 변경으로부터 보호하기

이제 이렇게 다형성을 활용하여서 Movie에서 할인 조건에 대한 조건이 추가가 되어도 Movie는 변경에 영향을 받지 않는다. 그냥 한 클래스를 확장시키기만 하면 된다.

이렇게 변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서 PROTECTED VARIATION(변경 보호)패턴이라고 한다.

이렇게 처리를 하게 되면 변경과 확장에 유연하게 대처할 수 있는 설계를 얻을 수 있다.


### 할인 정책도 Movie에서 빼내자.

이전의 할인 조건을 클래스 분리시키는 것과 거의 동일하지만 Movie에서는 할인 정책에 대한 구현을 공유할 필요가 있다. 그래서 추상 클래스로 공유하기로 했다. 그렇게 할인 정책을 3가지로 구분할 수 있다.

- AmountDiscountMovie
- PercentDiscountMovie
- NoneDiscountMovie

이렇게 분리를 시키면 마찬가지로 응집도가 높아지고 결합도는 낮아지게 된다! 결론은 책임을 중심으로 잘 나누고 설계하라는 것이다. 

---

### 도메인의 구조가 코드를 이끌어간다.

도메인의 구조를 보고 어떻게 보면 영화 예매에 관련한 것을 다 볼 수 있었고 알맞게 구조를 변경하면서 협력에 맞게 책임들을 할당하고 클래스를 분리시킬 수 있었다. **구현을 가이드할 수 있는 도메인 모델이 제일 좋다!**

### 상속으로 단점이 생길때 합성을 보자.(p.164)

이게 왜 단점이 생기냐면 실행 도중에 갑자기 할인 정책을 바꾸게 된다면? 요구사항이 추가된다면? 바꿀 수 있는 방법은 **인스턴스를 새로 생성해야된다.**

그러면 문제가 변경 전후의 인스턴스끼리 헷갈린다는 것이다. 그래서 그냥 이럴거면 새로운 DiscountPolicy라는 정책을 만들어서 이곳에 합성을 시킨 후 Movie랑 연결시키는 것이 훨씬 유연해진다. 

그래서 여기서 알 수 있는 사실은 의존성의 정도가 유연성의 정도를 결정하기 때문이다. 


### 그런데 책임 주도 설계를 계속 잘할 수 있나?

우리가 설계를 할 때 이렇게 책에 나온대로 바로 할 수 있으면 좋겠지만 그러기 위해선 너무나 시간이 많이 필요하다. 그리고 숙련된 설계자도 적절한 책임과 객체를 선택하는 것에 있어서 어려움을 겪는다고 한다.

결론부터 말하고 가면 일단 빠르게 만들고 그다음 리팩토링! 하는 방식이다.

>리팩토링 : 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것


### 메서드의 응집도를 낮추자(메서드 분리)
그래서 이 방법으로는 메서드의 응집도를 낮추고 필요한 클래스에 넣어주고 하는 방식이다.
항상 또 고민이 되는게 메서드를 작게 작게 분리를 해버리면? 너무 코드가 길어진다. 그에 대해선 이렇게 말한다.
> 코드가 길어지는 것 < 코드의 명확성

더 명확해지면 길어지는 건 상관이 별로 없다. 이런 맥락이었다. **명확성의 가치가 클래스의 길이보다 더 중요하다는 것이다.**
이렇게 하면 전체적인 흐름이 잘 보이고 명확해진다. 그게 중요한 것이다.

### 객체를 자율적으로 (p.172)

메서드를 어떤 클래스를 이동시켜야 하는지에 대한 판단은 어떻게 해야 될까? 
> 자신이 소유한 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체로 만드는 방법이기에 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시키면 된다.

그런데 그 데이터를 확인하는 방법은 메서드 안에서 어떤 클래스의 접근자 메서드를 사용하는지 파악하는 것이다.

이렇게 계속 리팩토링을 해가다보면 결국 처음 설계하고 싶었던 책임 주도 설계처럼 만들어진다는 것을 볼 수 있었다. 결론은 처음부터 완벽해지지 않을 수 있지만 작성한 후에 리팩토링을 통하여서 코드를 잘 보수하면 좋은 객체 지향 설계로 나아갈 수 있는 것이다.