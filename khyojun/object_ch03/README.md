
## CH 3. 역할,책임.협력

---

### 객체 지향에서 가장 중요하게 생각해야 되는 것
객체 지향에서 설계할 때 객체가 가장 핵심이 되어야 한다고 했는데 그것에 이어서 우리가 봐야할 핵심은 `역할`, `책임`, `협력`이다.

>객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다.

그러니 항상 구현하기 전 협력을 위해 어떤 역할과 책임이 필요한지 고민하고 설계해나가야지 **코드가 유연해지고 변경이 쉬워지는 코드가 만들어진다.**


### 협력

객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 **협력**이라고 한다.
그것에 이어서 협력에 참여하기 위해 수행하는 로직은 **책임**이라고 한다. 그리고 책임들이 모여 객체가 수행하는 **역할**이라고 한다.

그래서 넓게 보면 책임, 역할을 정하기 위해서는 협력이라는 것이 정의되어야 진행이 될 것 같다. 그래서 협력에 대해서 자세히 아아보자.


> `협력`이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다. 한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다. 즉, 두 객체가 
> 상호작용을 통해 더 큰 책임을 수행하는 것이다. 객체 사이의 협력을 설계할 때 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.


이전 시간에도 언급을 했지만 그러면 객체 간의 상호작용을 하기 위해서는 반드시 `메시지를 전송`하는 방법이 유일하다고 했다. 그러면 협력도 마찬가지이다. 

### 협력 할 때 주의 사항
협력할때 그러면 메시지를 전송해서 서로간 상호작용을 통해서 진행을 하게 될 것인데 이럴 때 중요한 것이 이전 시간에 언급하였던 `캡슐화`와 관련된 부분이다.

Screening에서 영화를 예매하기 위하여서 Movie라는 객체랑 협력을 하는데 그때 만약 캡슐화가 제대로 되지 않아서 내부 구현이 Screening에게 노출이 다 되버리면 Movie의 자율성이 침해된다. 
그래서 협력하는 관계 속에서는 적절한 `캡슐화`를 통하여서 메시지를 전송, 응답을 통해서 애플리케이션을 구현할 수 있도록 해야 한다.

---

### 협력은 설계를 위한 문맥을 결정한다.

객체가 협력을 하게 되는 이유를 생각해보면 다른 객체에서 필요한 어떠한 행동을 하기 때문에 서로 협력하게 된다. 

그렇게 봤을 때 결국 행동을 결정하기 위해서는 어떤 협력에 참가하고 있는지 알아야 결정을 할 수가 있다.

코드의 입장에서 봤을 때 Screening과 Movie가 협력하게 되는 이유는 **영화를 예매해라!** 라는 목적을 가지고 협력하는 거다. 만약 이런 목적이 없으면 Movie는 아무 의미가 없어진다. 그러니까 협력이 있기 때문에 객체가 존재한다는 것이 방금 예시와 같은 의미이다.

그러면 더 이어가서 볼 때 상태를 설계할 때는 행동에 어떤 것이 필요한지 알고 설계를 하게 된다. 그러면 이런 관계가 전체적으로 만들어질 거다.

협력 -> 행동 -> 상태 : 협력의 목적을 알아야 행동을 설계하고 그 행동을 알아야 어떤 상태가 필요한 지 설계가 된다.

그래서 협력이 객체를 설계하는 데 필요한 일종의 **문맥(context)**를 제공한다고도 한다.

---

### 책임이란 무엇인가?

>협력에 참여하기 위해 객체가 수행하는 행동을 `책임`이라고 한다.

책임을 이렇게만 보면 너무 추상적이다.

두 가지로 분류해보면 하는 것, 아는 것 이렇게 2가지로 분류할 수 있다.

그걸 쉽게 말하자면 
- 아는 것 : 그 객체에 해당하는 상태 필드
- 하는 것 : 그 객체에서 행동하는 메서드

라고 이해하면 금방 이해가 될 거 같다. 하기 위해서 알아야 하는 것이 있으니 두 가지가 연결되어서 아까 말한 협력의 목적을 알아야 객체를 설계하기 위한 문맥을 알 수 있으니 그에 대한 책임을 주겠다는 말이다.


그래서 결국 객체 지향 설계에서 가장 중요한 것이 **책임**이 되는 것이다.

### 잠깐 지금까지의 흐름을 보자.

객체간의 상호작용을 협력이라고 했는데 결론은 협력이라는 목적이 있어 객체를 형성하게 되면 그 협력하는 것에 맞는 상태와 행동을 정의해야하는데 그것은 그 객체가 아는 것, 하는 것으로 나뉘어지며 그것 자체가 그 객체의 책임이라고 볼 수 있다.


이 말까지만 들으면 결국 책임은 객체를 형성하는데 있어서 아주 중요한 요소이다!

### 책임을 할당하자.

자율적인 객체를 만들기 위한 방법으로는 어떻게 보면 그 객체가 잘할 수 없는 것은 그 정보를 잘 알고 있는 전문가에게 맡기면 마음이 편하다.

이 말은 즉, 친구 중 해당 분야에 대한 덕후가 있다면 그 친구랑 협력해서 일을 처리하는게 내가 조금은 자유로워질 수 있다.

객체들끼리 협력을 하는데 필요한 지식과 방법을 가장 잘 알고 있는 객체에게 도움을 요청할 것이다. 

그때 요청에 응답하기 위해 필요한 이 행동이 객체가 수행할 책임으로 이어지는 것이다.

### 책임이 할당되는 과정

그래서 간단하게 요약하면 이런 과정이다. 하나의 큰 책임을 가지고 설계를 하다가 이제 이 책임을 처리할 게 너무 커서 작은 책임을 찾아서 다른 객체들에게 할당하는 반복적인 과정인 것이다.

> 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해서 이루어진다.

이런 방식으로 책임에 초점을 맞추면서 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 것이 **책임 주도 설계**라고 한다.(RDD)

목차로 정리하자면 이런 과정이지 않을까

- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 

그래서 책에서도 목차가 나눠지는데 이후에 **메시지가 객체를 결정**, **행동이 상태를 결정** 당연한 말이다. 협력부터 시작해서 계속 따라가다 보면 이렇게 설계가 이루어질 수 밖에 없다는 것을 알 수 있다.

### 메시지가 객체를 결정해야하는 이유

1. 객체가 최소한의 인터페이스를 가질 수 있다. (알맞은 크기의 퍼블릭 인터페이스를 가질 수 있다.)
2. 충분히 추상적인 인터페이스를 가질 수 있게 된다.

### 행동이 상태를 결정하는 것

초보자들이 많이 하는 실수가 객체에서 상태를 결정하고 그 다음 행동을 생각하는 거다. 그런데 이런 방식으로 설계하면 당연히 내부 구현이 퍼블릭 인터페이스에 노출되기가 쉬워진다. 내부 구현을 변경하려면 퍼블릭 인터페이스도 다 고쳐야 하기 때문이다. 

그래서 이렇게 되면 결국 **캡슐화**가 저해될 것이다.

그러면 우리는 객체의 내부 구현에 집중하여 설계하는 것이 좋다는 것을 알 수 있어야 하는데 이를 `데이터-주도-설계(DDD)`라고 부르기로 했다.

그래서 상태는 단지 행동을 위한 도구라고 생각하는게 좋다. 

`협력이 객체의 행동을 결정하고 행동이 상태를 결정한다. 이 행동이 바로 객체의 책임이 될 거다.`

---

### 역할

> 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 **역할**이라고 부른다.


역할에 대해서는 진짜 많은 말들이 나왔지만 결국에는 이 한 줄이 가장 이해가 잘 되었다.
> 역할은 다른 것으로 교체할 수 있는 책임의 집합이다. 

이 문구 뭔가 느낌이 다형성에 대해서 알아볼때 들었던 느낌과 다르지 않은거 같다.
책임이라는 것의 집합이라는 것은 결국 공통점이 있다는 것인데 이것은 즉 상속할 때의 부모 클래스와 같은 입장이었다는 것을 알 수 있었다.
그러면 끝났다. 역할을 사용하면 좋다는 장점들은 `추상화`의 장점과 같다. 
- 유연해진다.
- 재사용이 가능하다.
- 불필요한 중복 코드를 제거할 수 있다.

등등이 있을 거다. 


### 객체 VS 역할

이 개념도 잘 설명한 문장이 있었는데 
> **협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할**이 되지만 **단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 그 후보는 객체가 된다**.

이 말이 무엇일까? 즉, 추상화 하지 않고 책임을 수행할 대상이 한 종류밖에 되지 않는다면 **객체** 아니면 **역할** 이라는 것이다.

이렇게 되면 이전 장에서도 언급한 거 같은데 추상화된 개념을 사용하면 상위의 정책들에 대해서 더 명확하게 전달할 수 있고 협력이 유연해지고 재사용이 가능해진다는 측면이 있다.

---

### 배우와 배역의 입장에서 구분해보자.

역할, 책임에 관해서 가장 잘 설명하는 예시가 바로 연극을 하는 배우, 배역 예시이다.
- 배역은 연극 배우가 특정 연극에서 연기하는 역할이다.
- 배역은 연극이 상영되는 동안에만 존재하는 일시적인 개념이다.
- 연극이 끝나면 연극 배우는 배역이라는 역할을 벗어 버리고 원래의 연극 배우로 돌아오게 된다.
- 서로 다른 배우들이 동일한 배역을 연기할 수 있다.
- 하나의 배우가 다양한 연극 안에서 서로 다른 배역을 연기할 수 있다.

여기서 하나하나 우리의 객체지향 식대로 풀어보자.
- 배역 : `역할`
- 배우 : 배역을 연기할 `책임`이 있는 사람(객체).
- 배우들 끼리 하는 연극 : `협력`해야 하는 목적

**여기서 보면 배역을 다른 배우들도 맡을 수 있는 것, 배우가 책임지면서 연기해야 되는 것, 연극을 해야한다는 협력이 모이는 것처럼 우리의 코드를 설계를 할 때도 연극이 잘 되게 하는 것처럼 배우, 배역을 잘 지정해서 좋은 객체 지향 설계를 지향할 수 있어야 겠다.**
