# Appendix B. 타입 계층 구현
#### ✅ 기본 전제
- 리스코프 치환 원칙은 <u>구현 방법에 의해서 보장되는 것이 아니기</u> 때문에 <br/> " 클라이언트 관점에서 타입 계층에서의 **행동 호환성 보장** "은 개발자의 몫이다.
  - _올바른 타입 계층 : <u>서브 타입이 **슈퍼타입을 대체**</u>할 수 있도록 **리스코프 치환 원칙 준수** 필요_


- **"동일 메시지에 대한 행동 호환성"** 형성 목적
  - `타입 계층` 구현 방식  & `다형성`을 구현하는 방법
  - " _슈퍼타입에 대해 전송한 메시지를 <u>서브 타입별로 다르게 처리</u>할 수 있는 방법_ " 제공


<br/>

---
## 구현 방법
### 클래스
> `타입` → 객체의 "**퍼블릭 인터페이스**"<br/>
> `클래스` → 객체의 "<u>타입</u>(**퍼블릭 인터페이스**)" 및 "<u>**구현**</u>" 정의 매개체 → "**사용자 정의 타입** `User-Defined Data Type`"

클래스 내에선 <u>"**퍼블릭 메서드**"를 구현함으로서 퍼블릭 인터페이스를 구성</u>해 나가는데<br/>
**타입**은 즉 " 퍼블릭 인터페이스 "를 의미하기 때문에<br/>
정리하자면<br/>
**퍼블릭 메서드**로 "<u>메시지에 응답할 수 있는 `타입`을 선언</u>"하는 동시에 "<u>객체 `구현`</u>"을 하는 것과 동일하다.

단, " _특정 개념의 타입이 절대적으로 하나만 존재_ "한다면 `타입 == 클래스`에 그쳐도 무방하지만<br/>
만약 동일 퍼블릭 인터페이스를 기반으로 <u>서로 다른 내용 및 방식의 구현</u>이 필요할 경우, <br/>
해당 개념이 파괴된다.

<u>`퍼블릭 인터페이스`를 "**유지**" 하면서 서로 다른 `구현`을 "**추가**"</u>해야 할 땐,<br/>
" `추상 클래스` **상속** " & " `인터페이스` **구현** "를 사용하는 방식이 있다.

( _단순 **"구체 클래스 상속"** 은 강한 결합을 발생시키기 때문에 비권장한다._ )

<br/>

### 인터페이스
세상 모든 구현체들 중 어느 한 가지의 특성만 가진 경우는 찾기 힘들 것이다.<br/>
다양한 개념 및 범주들의 교집합으로서 특정 구현체가 생겨나는 것이 대부분인데

만약 이를 "클래스"와 "상속"을 통해서 객체를 구현하고자 한다면<br/>
"**단일 상속**" 정책에 의해 <u>교집합적인 개념들을 동시 구현</u>하기 **어려울 것**이다.

이럴 경우의 해결 방법이 바로 "**다중 구현**"이 가능한 "`인터페이스`"를 활용하는 것이다.

- 상속으로 인한 **강한 결합도** 문제 회피
- **단일 상속** 제약 회피

더 나아가 "<u>인터페이스 간 상속</u>" 을 통한 <br/>
더 많은 행동을 가진 다른 타입에 의해 "**확장**"까지 가능하다.<br/>
( _ex. `(interface) extends (interface)`_ )

이처럼 " _인터페이스가 다른 인터페이스를 확장하도록 설계_ "하면<br/>
<u>슈퍼 타입과 서브 타입 간의 **타입 계층**</u>을 구성할 수 있다.

<br/>

위 방법에 따라 타입 계층을 설계한 후,<br/>
다양한 타입들에 대해 "`클래스`"라는 수단을 통해<br/>
다양한 **타입(인터페이스)들을 구현**하면 된다.

> - **여러** 클래스 → <u>동일</u>한 타입 구현 : 여러 `서브 타입`
>   - **동일한 메시지에 응답**할 수 있는 <u>타입은 동일하지만 서로 다른 클래스</u>들
> 
> 
> - **단일** 클래스 → <u>여러</u> 타입 구현 : `다중 구현`

⁜ `인터페이스`를 이용해 "**타입**"을 정의하고, `클래스`를 이용해 객체를 "**구현**"하면 <br/>
<u>**상속을 사용하지 않고도** 타입 계층 구현</u>이 가능하다.

- `클래스(Class)` : 객체의 "**구현**" 정의 → 내부 상태 & 오퍼레이션 <br/>
  == " _타입 소속 객체 구현 매커니즘_ "


- `타입(Type)` : **Only** "**인터페이스**" 정의 → 반응할 수 있는 **오퍼레이션 집합**<br/>
  == " _동일한 퍼블릭 인터페이스를 가진 객체들의 범주_ "


- _객체 지향에서 가장 중요한 것이 "협력 안에서 객체가 제공하는 **행동**"인만큼 <br/>
  클래스 자체보단 <u>타입이 더 중요</u>하다._

<br/>

### 추상클래스
> "<u>**추상 클래스**를 상속</u>받는 **구체 클래스**" 추가 → 타입 계층 구현

#### 💡구체 클래스 상속 vs 추상 클래스 상속
1. 의존하는 대상의 **"추상화 정도"**
   - **구체 클래스 상속** → 내부 구현에 강한 결속
   - **추상 클래스 상속** → 추상 메서드에 시그니처에만 의존 (내부 구현 의존 ❌)
     - 오직 추상 메서드 `오버라이딩`에 의존 :: " `의존성 역전의 원칙` "<br/><br/>
   - 모든 자식 클래스들은 항상 추상 메서드의 시그니처 준수 
     - 유연 & 변화에 안정적인 설계
   - 추상화 ⬆ == 결합도 ⬇ == 변경에 의한 영향 ⬇ <br/><br/><br/>
2. 상속을 사용하는 "**의도**"
   - 구체 클래스 상속 → `코드 재사용`
     - _확장에 닫혀있음_
   - 추상 클래스 상속 → `상속`
     - 자기 자신의 **인스턴스 생성** 불가능
     - 오직 <u>**자식 클래스** 추가</u>를 위해 존재<br/><br/>
   - 상속 **계층 확장** 용이 & **결합도** 부작용 방지

<br/>

### 추상 클래스 + 인터페이스
> :: " `골격 구현 추상 클래스` ( _Skeletal Implementation Abstract Class_ ) "

- `인터페이스` → **"다중 상속"** 문제 해결
- `추상 클래스` → **"중복 코드"** 방지

```java
import domain.Money;
import domain.Screening;

public interface DiscountPolicy {
    Money calculateDiscountAmount(Screening screening);
}

/**
 * 골격 구현 추상 클래스 `DefaultDiscountPolicy`
 */
public abstract class DefaultDiscountPolicy implements DiscountPolicy {
    private List<DiscountPolicy> conditions = new ArrayList<>();

    public DefaultDiscountPolicy(DiscountPolicy... conditions) {
        this.conditions = Arrays.asList(conditions);
    }

    @Override
    public Money calculateDiscountAmount(Screening screening) {
        for (DiscountPolicy policy : conditions) {
            if(policy.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening) ;
            }
        }
        return screening.getMovieFee();
    }
    
    abstract protected Money getDiscountAmount(Screening screening);
}

/**
 * `calculateDiscountAmount`의 구현 상속 & 인스턴스 변수 상속
 * - 중복 코드 방지
 * - 하나의 상속 계층으로 묶을 수 있음
 * 
 * 각자 `getDiscountAmount` 에 대해 구현
 * - 시그니처 동일 :: 의존성 역전 원칙 적용 가능
 * - 행동 호환 가능 :: 타입 계층 구현
 */
public class AmountDiscountPolicy extends DefaultDiscountPolicy {
}
public class PercentDiscountPolicy extends DefaultDiscountPolicy {
}
```
<br/>

#### 💡골격 구현 추상 클래스 vs 추상 클래스 
- [장점] <u>**상속 계층**에 얽매이지 않는</u> 타입 계층 & 코드 <u>중복 제거</u>
  - 간단한 새로운 구현 방법 추가
    - 간단하게 새로운 **추상 클래스** 추가 
  - 손쉬운 인터페이스 추가/삭제
    - 기존 부모 클래스에서 **새로운 타입**으로 쉽게 **확장**


- [단점] **복잡도**가 올라감

<br/>

자칫 복잡도가 올라가 불필요하게 <u>이해용이성이 떨어질</u> 수 있기 때문에<br/>
**복잡성 절하**가 더 중요하다면<br/>
타입을 정의하기 위해 인터페이스 / 추상 클래스 **둘 중 하나만 사용**하는 것이 바람직하다.
- **단일** 상속 계층 **가능** : `클래스`/`추상 클래스`로 타입 정의
- **단일** 상속 계층 **불가능** : `인터페이스`로 타입 정의

<br/>
<br/>

---
### 덕 타이핑 - `동적 타입 언어`



<br/>
<br/>

---

---
### 믹스인 & 타입 계층