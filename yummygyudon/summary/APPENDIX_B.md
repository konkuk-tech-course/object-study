# Appendix B. 타입 계층 구현
#### ✅ 기본 전제
- 리스코프 치환 원칙은 <u>구현 방법에 의해서 보장되는 것이 아니기</u> 때문에 <br/> " 클라이언트 관점에서 타입 계층에서의 **행동 호환성 보장** "은 개발자의 몫이다.
  - _올바른 타입 계층 : <u>서브 타입이 **슈퍼타입을 대체**</u>할 수 있도록 **리스코프 치환 원칙 준수** 필요_


- **"동일 메시지에 대한 행동 호환성"** 형성 목적
  - `타입 계층` 구현 방식  & `다형성`을 구현하는 방법
  - " _슈퍼타입에 대해 전송한 메시지를 <u>서브 타입별로 다르게 처리</u>할 수 있는 방법_ " 제공


<br/>

---
## 구현 방법
### 클래스
> `타입` → 객체의 "**퍼블릭 인터페이스**"<br/>
> `클래스` → 객체의 "<u>타입</u>(**퍼블릭 인터페이스**)" 및 "<u>**구현**</u>" 정의 매개체 → "**사용자 정의 타입** `User-Defined Data Type`"

클래스 내에선 <u>"**퍼블릭 메서드**"를 구현함으로서 퍼블릭 인터페이스를 구성</u>해 나가는데<br/>
**타입**은 즉 " 퍼블릭 인터페이스 "를 의미하기 때문에<br/>
정리하자면<br/>
**퍼블릭 메서드**로 "<u>메시지에 응답할 수 있는 `타입`을 선언</u>"하는 동시에 "<u>객체 `구현`</u>"을 하는 것과 동일하다.

단, " _특정 개념의 타입이 절대적으로 하나만 존재_ "한다면 `타입 == 클래스`에 그쳐도 무방하지만<br/>
만약 동일 퍼블릭 인터페이스를 기반으로 <u>서로 다른 내용 및 방식의 구현</u>이 필요할 경우, <br/>
해당 개념이 파괴된다.

<u>`퍼블릭 인터페이스`를 "**유지**" 하면서 서로 다른 `구현`을 "**추가**"</u>해야 할 땐,<br/>
" `추상 클래스` **상속** " & " `인터페이스` **구현** "를 사용하는 방식이 있다.

### 인터페이스

### 추상클래스

### 추상 클래스 + 인터페이스

---
### 덕 타이핑 - `동적 타입 언어`



<br/>
<br/>

---

---
### 믹스인 & 타입 계층