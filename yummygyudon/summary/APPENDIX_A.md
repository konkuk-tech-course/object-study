# Appendix A. 계약에 의한 설계
명령으로 인해 발생하는 부수효과를 명확하게 표현하는데 한계가 존재
- "의도를 들어내도록" 인터페이스를 **설계**
- **명령**과 **쿼리**를 "분리"

위 2가지를 행하더라도 표현에는 한계가 있고<br/>
주석으로 서술하더라도 시간이 흐를 수록 정확히 반영하기 어려워지는 것이 사실

→ **명령의 부수효과**를 쉽고 명확하게 **표현**할 수 있는 **커뮤니케이션 수단** :: `계약에 의한 설계 (Design By Contract)`

- 협력에 필요한 다양한 제약 및 부수효과 문서화 가능 ➡ `명시적 문서화` & `명확한 커뮤니케이션` & `실행 가능 검증 도구`
  - 클라이언트 개발자 : <u>오퍼레이션 구현 내용을 모르더라도</u> 객체 **사용법 이해 용이**
  - 계약 : **실행 가능** → " _**구현**이 **동기화** 되어있는지 여부_ "를 "**런타임**"에 검증 가능
  - (_주석과 다르게_ ) <u>시간의 흐름</u>에 따라 **반영**
<br/>

---
## "협력" & "계약"
### 부수효과 명시화
⭐️ 객체지향 핵심 : " **협력** 안에서 <u>객체들이 수행하는 **행동**</u> " ⭐️

- **인터페이스**
  - ⭕️ : 객체가 수실할 수 있는 **메시지** 정의 
    - ＜ **메시지 이름** & **파라미터** ＞ 는 "**시그니처**"를 통해 전달 가능
  - ❌ : 객체 사이의 **의사소통 방식** 정의
    - 협력을 위해 필요한 <u>약속 및 제약 전달 불가능</u>

"인터페이스로 전달하지 못해" **협력**에 대해 상당히 <u>불확실</u>하고 <u>암시적</u>인 상태로 남게된다.<br/>
이에 대해 "**계약에 의한 설계 방식**"을 사용하면 개선할 수 있다.

<br/>

### `계약에 의한 설계` 라이브러리 검증 
〚`If` 조건문 검증〛이라는 방식도 있지만 `계약에 의한 설계` 라이브러리 검증 방식을 활용하는 것이 효율적이다.
- **문서화**
- <u>**계약 조건** 명시적 표현</u> 가능 → 일반 로직 구분 가능
- **실행 가능** → <u>실행 중</u> **"제약 조건 만족"** 여부 확인 가능
  - 코드로부터 해당 조건들 "**_추출 및 문서 자동화 도구_** " 제공

<br/>

### 계약
> ⁜ 적절한 **전문가**에게 **작업**을 **위탁**하고 **계약**하는 방식

- 각 계약 당사자 : **요구**되는 "`이익(Benefit)`" ⇋ **이행**해야 하는 "`의무(Obligation)`"
  - 한 쪽의 "**의무**" == 반대쪽의 "**권리**" 


- 이익과 의무에 대한 "**내용 문서화**"

실생활에서의 계약과 유사한 형태의 관계를 가지는 설계라고 생각하면 편하다.

마찬가지로<br/>
"**전문가**가 계약에 대해 이행하는 <u>구체적인 방식에 대해 간섭하지 않아야 한다</u>"는 개념도 유사하다.

이처럼 `계약`은 " **협력**을 **명확**하게 **정의**하고 **커뮤니케이션** 할 수 있는 범용적인 아이디어 "로서 사용될 수 있다.


<br/>
<br/>

---
## 계약에 의한 설계
> " _**인터페이스**에 대해 프로그래밍 하라._ " 라는 원칙의 확장 개념 

앞서 [계약](#계약)에서 다뤘던 실생활에서의 형식을 대입해보면
- 〚 **협력**에 참여하는 **각 객체** 〛는 계약으로부터 <u>**이익**을 기대</u>하고 이익을 얻기 위해 <u>**의무**를 이행</u>
  - 오퍼레이션 시그니처 → 협력에 참여하는 객체들이 지켜야 하는 **"제약 조건 명시"**


- 〚 **협력**에 참여하는 **각 객체** 〛의 이익과 의무는 <u>객체의 **인터페이스** 상에 **문서화**</u>
  - 명시된 제약 조건을 **인터페이스의 일부**로 만듦 → 코드 분석 없이 사용법 파악 가능

위와 같이 정리할 수 있다.

<br/>

> ⭐️ ⌜ **의도를 드러내는 인터페이스** ⌟ + ⌜ **사전조건** / **사후조건** / **불변식** ⌟  ⭐️

1. **의도를 드러내는 인터페이스**
   - "**오퍼레이션 시그니처**" → "**제약조건**" 명시
   ```java
    /**
     * 아래와 같은 구조로 클라이언트에게 어느 정도까지는 수행해야하는 제약조건을 "명시"할 수 있다.
     * [가시성 : 접근제어자] [반환 타입] [메서드명] ( *[파라미터 : 타입 & 이름] );
     */
    public Reservation reserve(Customer customer, int audienceCount) ;
   ```
   <br/>
2. **사전조건** / **사후조건** / **불변식**
   - 3가지의 **"기대/조건"** 에 대한 명시
     - `사전 조건` ⇤ `서버` : " _자신이 <u>처리할 수 있는 범위의 값</u>들을 **클라이언트가 전달할 것**_ " **기대** → `클라이언트`의 의무<br/><br/>
     - `사후 조건` ⇤ `클라이언트` : " _자신이 <u>원하는 값</u>을 **서버가 반환할 것**_ " **예상**  → `서버`의 의무<br/><br/>
     - `불변식` ⇤ `클라이언트` : " _<u>메시지 전송 전 & 후</u>에 **서버의 상태가 정상일 것**_ " **기대** → `서버`의 조건

사전조건/사후조건/불변식을 기술할 때는<br/>
<u>**절차 기술** 없이</u> "**상태 변경**"만을 명시하면 된다.<br/>
(코드 이해 및 분석 용이)

<br/>

### ⁜ 사전 조건 (Precondition)
> 메서드가 <u>호출되기 위해</u> 만족돼야 하는 조건
> - 메서드 **"요구사항"** 명시
> - 어긋날 경우, "**예외 발생** ⭕️ ➡ **실행** ❌"
> - `클라이언트` 의무

<br/>

보통 메서드에 <u>"**전달된 인자**"의 정합성 체크</u>를 위해 사용

```java
public Reservation Reserve(Customer customer, int audienceCount) {
    /**
     * 1. 계약만을 위해 준비된 전용 표기법 사용 → 명확한 계약 표현
     * 2. 일반 로직과 분리하기 용이
     * 3. 메서드의 일부 → 계약 강제 가능
     */
    Contract.Requires(customer != null) ; // 사전조건 False(조건 미충족) 시, 예외 발생 → 메서드 실행 거절
    Contract.Requires(audienceCount >= 1) ;
    
    return new Reservation(customer, this, calculateFee(audienceCount), audienceCount) ;
}
```

<br/>

### ⁜ 사후 조건 (Postcondition)
> 메서드가 <u>실행된 후</u>에 <u>**클라이언트**에게</u> **보장**돼야 하는 조건
> - 어긋날 경우, "클라이언트 **예외 발생** ⭕️"
> - `서버` 의무

<br/>

메서드의 <u>실행 **결과**가 올바른지</u> 검사 &<br/>
<u>**실행 후**에 객체가 **유효한 상태**</u>로 남아 있는지 검증

- "<u>인스턴스 변수</u> **상태 적절성**" 서술


- 메서드 "전달 **파라미터** 정상적 **활용 및 변경 여부**" 서술


- "**반환값 적절성**" 서술

사전조건보다 <u>사후조건을 정의하는 것이 조금 더 까다로운데</u>
아래 **2가지 상황**이 그 이유다.<br/>
(_다행히 아래 두 상황에 대해 **대부분의 라이브러리는 개선방안을 제공**해준다._)

1. `한 메서드 안에 여러번의 reutrn문이 나올 경우`
   - **모든 return 문마다** 결과값이 올바른지 **검증하는 코드 필요**
   - _계약에 의한 설계를 지원하는 대부분의 라이브러리_ → 결과값에 대한 **사후조건을 한번만 기술할 수 있게** 해줌.<br/><br/>
2. `실행 전 & 실행 후의 값을 비교해야하는 경우`
   - 두 값이 메서드 실행으로 인해 **다른 값으로 변경됐을 가능성이 높아 비교하기 쉽지 않음**.
   - _계약에 의한 설계를 지원하는 대부분의 라이브러리_ → "<u>실행 전 값</u>"에 접근할 수 있는 방법 제공


<br/>

### ⁜ 불변식 (Invariant)
> <u>항상 **참(True)**</u>라고 **보장**되어야 하는 조건
> - 메서드 **"실행 전" & "실행 후"** 항상 "**참(True)**" 보장
>   - 실행 도중에는 불변식 만족시킬 의무 없음
> - `서버` **조건**

(_사전조건/사후조건 : 각 메서드마다 상이_)<br/>
" **인스턴스 생명주기 전반** "에 걸쳐 지켜져야 하는 규칙 명세

- <u>클래스</u>의 " **모든 인스턴스**가 생성된 **후** "에 **만족**돼야 함.
  - "**생성자 실행 후**" 모두 호출됨.


- <u>클라이언트</u>에 의해 " **호출 가능**한 **모든 메서드**에 의해" **준수**돼야 함
  - 메서드 "**실행 전**" & "**실행 후**" 모두 호출됨.

즉, 클래스의 모든 메서드의 사전조건과 사후조건에 추가되는 "<u>**공통 조건**</u>"이라 볼 수 있다.



<br/>
<br/>

---
## "계약에 의한 설계" & "서브타이핑"

