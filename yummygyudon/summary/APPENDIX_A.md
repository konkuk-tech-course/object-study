# Appendix A. 계약에 의한 설계
명령으로 인해 발생하는 부수효과를 명확하게 표현하는데 한계가 존재
- "의도를 들어내도록" 인터페이스를 **설계**
- **명령**과 **쿼리**를 "분리"

위 2가지를 행하더라도 표현에는 한계가 있고<br/>
주석으로 서술하더라도 시간이 흐를 수록 정확히 반영하기 어려워지는 것이 사실

→ **명령의 부수효과**를 쉽고 명확하게 **표현**할 수 있는 **커뮤니케이션 수단** :: `계약에 의한 설계 (Design By Contract)`

- 협력에 필요한 다양한 제약 및 부수효과 문서화 가능 ➡ `명시적 문서화` & `명확한 커뮤니케이션` & `실행 가능 검증 도구`
  - 클라이언트 개발자 : <u>오퍼레이션 구현 내용을 모르더라도</u> 객체 **사용법 이해 용이**
  - 계약 : **실행 가능** → " _**구현**이 **동기화** 되어있는지 여부_ "를 "**런타임**"에 검증 가능
  - (_주석과 다르게_ ) <u>시간의 흐름</u>에 따라 **반영**
<br/>

---
## "협력" & "계약"
### 부수효과 명시화
⭐️ 객체지향 핵심 : " **협력** 안에서 <u>객체들이 수행하는 **행동**</u> " ⭐️

- **인터페이스**
  - ⭕️ : 객체가 수실할 수 있는 **메시지** 정의 
    - ＜ **메시지 이름** & **파라미터** ＞ 는 "**시그니처**"를 통해 전달 가능
  - ❌ : 객체 사이의 **의사소통 방식** 정의
    - 협력을 위해 필요한 <u>약속 및 제약 전달 불가능</u>

"인터페이스로 전달하지 못해" **협력**에 대해 상당히 <u>불확실</u>하고 <u>암시적</u>인 상태로 남게된다.<br/>
이에 대해 "**계약에 의한 설계 방식**"을 사용하면 개선할 수 있다.

<br/>

### `계약에 의한 설계` 라이브러리 검증 
〚`If` 조건문 검증〛이라는 방식도 있지만 `계약에 의한 설계` 라이브러리 검증 방식을 활용하는 것이 효율적이다.
- **문서화**
- <u>**계약 조건** 명시적 표현</u> 가능 → 일반 로직 구분 가능
- **실행 가능** → <u>실행 중</u> **"제약 조건 만족"** 여부 확인 가능
  - 코드로부터 해당 조건들 "**_추출 및 문서 자동화 도구_** " 제공

<br/>

### 계약
> ⁜ 적절한 **전문가**에게 **작업**을 **위탁**하고 **계약**하는 방식

- 각 계약 당사자 : **요구**되는 "`이익(Benefit)`" ⇋ **이행**해야 하는 "`의무(Obligation)`"
  - 한 쪽의 "**의무**" == 반대쪽의 "**권리**" 


- 이익과 의무에 대한 "**내용 문서화**"

실생활에서의 계약과 유사한 형태의 관계를 가지는 설계라고 생각하면 편하다.

마찬가지로<br/>
"**전문가**가 계약에 대해 이행하는 <u>구체적인 방식에 대해 간섭하지 않아야 한다</u>"는 개념도 유사하다.

이처럼 `계약`은 " **협력**을 **명확**하게 **정의**하고 **커뮤니케이션** 할 수 있는 범용적인 아이디어 "로서 사용될 수 있다.


<br/>
<br/>

---
## 계약에 의한 설계


<br/>
<br/>

---
## "계약에 의한 설계" & "서브타이핑"

