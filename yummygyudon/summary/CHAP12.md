# Chapter 12. 다형성
> ⁜ **다형성**(**Polymorphism**) : <u>**런타임**</u>에 메세지를 처리하기에 적합한 메서드를 "**동적**으로 탐색"하는 과정을 통해 구현됨.
> <br/><br/>
> ⁜ **상속** : <u>**클래스 계층**</u>의 형태의 "적합한 메세지 처리 메서드를 찾기 위한 일종의 탐색 경로"를 구현하기 위한 방법

- "**상속**" 목적 : <u>**타입 계층**</u> 구조화
  - **클라이언트 관점**에서 <u>인스턴스들을 **동일하게 행동하는 그룹**으로 묶어</u> 사용 및 관리 가능
  - _단순 코드 재사용을 위해 사용하기엔 부적절_<br/>(<span style="color:grey">과거 가장 일반적인 다형성 구현 방법이었지만 최근엔 다양한 방법이 등장</span>)

## 다형성
> 하나의 **추상 인터페이스**에 대해 코드를 작성 <br/>→ 추상 인터페이스에 대해 <u>서로 다른 구현을 **연결**</u>할 수 있는 능력
><br/><br/>
> : 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법

### 1️⃣ 유니버설 다형성 ( _Universal Polymorphism_ )
#### ⁜ " _매개변수_ ( _Parametric_ ) " 다형성
- <u>클래스의 **인스턴스 변수**</u> / <u>메서드의 **매개변수**</u> 타입을 **임의의 타입**으로 선언 & **사용 시점**에 <u>구체 타입 지정</u>하는 방식
  - _ex. `List<T>`_
  - "**제네릭 프로그래밍**"과 연관 있음.
  - 해당 인터페이스는 <u>다양한 타입의 요소</u>를 다루기 위해 **동일한 오퍼레이션** 사용 가능<br/><br/>

<br/>

#### ⁜ " _포함_ ( _Inclusion_ ) " 다형성
- `서브타입(Subtype)`다형성 이라 불리기도 함
- 가장 일반적으로 널리 알려진 다형성
- <u>메시지가 동일하더라도</u> "**수신한 객체 타입**"에 따라 <u>실제 수행되는 행동이 달라지는</u> 방식
  - 가장 일반적인 구현 방법 : **상속**
  - 부모 클래스의 메서드 **오버라이딩** → 클라이언트는 **부모 클래스만** 참조
- **전제 조건** : 자식 클래스가 <u>부모 클래스의 서브 타입</u>
  - (_코드 재사용이 아닌_) 다형성을 위한 **<u>서브타입 계층</u>** 구축
  - 파이프 라인 구조처럼 <u>상속 계층 내</u>에서 **메시지 처리에 적절한 메서드를 탐색**

<br/>

### 2️⃣ 애드 혹 다형성 ( _Ad Hoc Polymorphism_ )

#### ⁜ " _오버로딩_ ( _Overloading_ ) " 다형성
- 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
  - 유사 작업 수행에 대해 메서드의 이름이 통일되어있기 때문에, 기억/인지해야할 이름의 수가 줄어드는 효용

<br/>


#### ⁜ " _강제_ ( _Coercion_ ) " 다형성
- 언어가 지원하는 자동 타입 변환 / 사용자 구현 타입 변환 등을 통해 동일한 연산자를 다양한 타입에 범용적으로 사용하는 방식
  - _ex. Java : 정수 + 정수 → 정수의 합 / 정수 + 문자열 → 문자열로 자동 강제 형변환 및 연결_
  - 위 예처럼 사용은 가능하지만 [오버로딩 다형성](#--오버로딩--overloading---다형성)과 함께 사용하면 실제 연산 시, 어떤 메서드가 호출될지 모호하기 때문에 위험하다. 


<br/>
<br/>

---

## "상속"의 양면성

### ✵ 데이터 관점

### ✵ 행동 관점


<br/>
<br/>

---
## 업캐스팅 & 동적 바인딩 ( _Up-Casting & Dynamic Binding_ )


<br/>
<br/>

---
## 동적 메서드 탐색 & 다형성


<br/>
<br/>

---
## 상속 vs 위임


<br/>
<br/>

---