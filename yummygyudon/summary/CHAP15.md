# Chapter 15. 디자인 패턴과 프레임워크

- 〚 `디자인 패턴` 〛<br/> :: 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결방법
  - (목적) `설계 재사용`
    - 특정한 변경을 일관성 있게 다룰 수 있는 **협력 템플릿** 제공
    - " <u>**재사용**할 수 있는 **설계의 묶음**</u> "


- 〚 `프레임 워크` 〛<br/> :: 설계와 코드를 함께 재사용하기 위한 것
  - (목적) `설계 및 코드 재사용`
    - <u>애플리케이션의 아키텍쳐</u>를 "**구현 코드**"의 형태로 제공
    - 특정한 변경을 일관성 있게 다룰 수 있는 **확장 가능한 코드 템플릿** 제공
    - " <u>일관성 있는 협력을 제공하는 **확장 가능한 코드**</u> "

## `디자인 패턴` - "설계" 재사용

### ✅ 소프트웨어 패턴
> ⁜ `패턴` : _하나의 실무 컨텍스트(Practical Context)에서 **유용하게 사용해 왔고** <u>**다른 실무 컨텍스트에서도** 유용할 것이라고 예상되는 아이디어</u>_
> - **반복**적으로 발생하는 `{문제 : 해법}`의 쌍으로 정의
> - 이미 알려진 문제 & 해법에 대한 내용 **문서화 가능**
> - 해당 지식을 다른 사람과 **의사소통 가능**
> - ⭐️ "**실무**"에서 탄생
> 
> ( _패턴은 소프트웨어 개발과 직접적인 연광성을 가진 영역만으로 한정된 것이 아님 : ex. 조직 구성 방법/일정 추정 방법 등 등_ )

<br/>

- 경험을 통해 축적된 실무 지식을 효과적이고 요약적으로 전달 가능
  - 지식 전달 & 커뮤니케이션 수단
- 가장 중요한 것 : 패턴의 "**이름**"
  - 간략하게 **패턴의 효과 및 특징**을 축약하는 이름 
  - _ex. "<u>인터페이스를 하나 추가</u>하고 해당 인터페이스 <u>구현 클래스를 만든 후</u>, <u>객체 생성자/`setter`에 할당</u>하여 <u>런타임 시에 알고리즘을 바꿀 수 있도록</u> 설계"_ <br/>→ "`STARTEGY` 패턴"
- 특정 패턴 내 포함된 〚 컴포넌트 - 컴포넌트 〛간 관계 <br/>→ "<u>더 **작은** 패턴</u>에 의해 **서술**" / "<u>더 **큰** 패턴</u>에 **포함**" 가능
  - " **연관된 패턴들의 집합** " :: `패턴 언어(Pattern Language)`  / `패턴 시스템(Pattern System)`

<br/>

### 패턴 종류
> 디자인 패턴 **상위** : `아키텍처 패턴`<br/>
> 디자인 패턴 **하위** : `이디엄`
- **아키텍처** 패턴 (Architecture Pattern) : 소프트웨어 <u>**전체적인 구조 결정**</u>
  - **미리 정의**된 **서브 시스템** 제공
  - 각 서브 시스템 **책임** 정의
  - 〚서브 시스템〛관계 **조직화 규칙 및 가이드라인** 포함
  - 구체적인 소프트웨어 아키텍처를 위한 템플릿 제공
  - 프로그래밍 언어/프로그래밍 패러다임 `독립적`

<br/>

- **분석** 패턴 (Analysis Pattern) : "업무 모델링 시", <u>발견되는 공통적인 구조를 표현하는 개념들의 집합</u>
  - "**도메인 내 개념적 문제**" 해결 목적
  - <u>단일 도메인에만</u> 적절할 수 도 있고 <u>다중 도메인</u>에서 적절할 수 있다.

<br/>

- **디자인** 패턴 (Design Pattern) : <u>특정 정황 내에서 일반적인 **설계 문제 해결**</u>
  - 〚협력 컴포넌트〛들 사이에서 **반복적으로 발생하는 구조** 서술
  - 특정 설계 문제 해결
  - 프로그래밍 언어/프로그래밍 패러다임 `독립적`

<br/>

- **이디엄** (Idiom) : 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴
  - 〚컴포넌트〛/ 〚컴포넌트 간〛**특정 측명 구현 방법** 서술
  - 프로그래밍 언어 `종속적`
    - _특정 언어의 이디엄이 다른 언어에서는 소용 없을 수도 있음_

<br/>

⁜ < **아키텍처 / 다지아니 / 이디엄** > : **기술적** 문제 해결<br/>
⁜ < **분석** > : **개념적** 문제 해결

<br/>

### 패턴 & `책임 - 주도 설계`
⭐️ `객체지향 설계` : "**올바른 책임**"을 "**올바른 객체**에게 할당"하고 "객체 간의 **유연한 협력 관계**"를 구축하는 것

- `책임/협력` : 다양한 요소들의 "**트레이드 오프(Trade-Off)**"에 의해 결정
  - _캡슐화 / 크기 / 의존성 / 성능 / 확장 가능성 / 유연성 / 재사용성 등_


- **패턴** : " <u>공통적으로 사용할 수 있는</u> `역할`, `책임`, `협력`의 **템플릿** "
  - `STARTEGY` 패턴<br/> : 다양한 알고리즘을 **동적으로 교체**할 수 있는 역할과 책임의 집합 제공<br/><br/> 
  - `BRIDGE` 패턴<br/> : (추상화의 조합으로 인한 클래스의 폭발적인 증가 문제 해결)<br/>
  역할과 책임을 `추상화` & `구현` 두 개의 커다란 집합으로 **분해**
    - 확장 가능한 설계 제공<br/><br/>
  - `OBSERVER` 패턴<br/> : (유연한 통지 매커니즘 구축)<br/>
  **객체간의 결합도를 낮출 수 있는** 역할과 책임의 집합 제공


패턴을 따르게 되면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다.

또한 패턴의 구성 요소는 `역할`( _클래스 X_ )<br/>
→ _ex. `COMPOSITE` 패턴 : **클라이언트**가 "**개별 객체**와 **복합 객체**를 동일하게 취급"_
- 클래스가 아닌 <u>**협력에 참여**하는 객체들의 **역할**</u>들로 구성
  - `역할` → **동일한 오퍼레이션에 대해 응답**할 수 있는 "**책임의 집합**" 암시 <br/><br/>
  - <u>해당 역할이 제공하는 **오퍼레이션을 구현**하는 어떤 객체</u>라도 "**본 역할 대체 가능**"
    - _반대로 "**다수의 클래스**가 **동일한 역할** 수행"이 가능하도록 구현하는 것도 가능_ 

<br/>

### `캡슐화` & 디자인 패턴
> _대부분의 디자인 패턴 : **유연 & 일관성 있는 협력**을 만드는 목정_
> 
> → "**특정한 <u>변경</u>**"을 **캡슐화**하기 위한 방법 정의 (**유연 & 일관성 있는 협력**)

- `STRATEGY` 패턴
  - <u>알고리즘 변경</u>을 **캡슐화**
  - 객체의 "`합성`" 활용<br/></br>
  - " **런타임** "에 알고리즘 **변경 가능**

<br/>

- `TEMPLATE METHOD` 패턴
  - <u>알고리즘 변경</u>을 **캡슐화** → "**추상 메서드**"
  - 객체의 "`상속`" 활용
    - 변경하지 않은 부분 = 부모 클래스
    - 변경하는 부분 = 자식 클래스<br/><br/>
    - **부모 클래스**의 <u>추상 메서드</u> 호출 / 적합한 **자식 클래스**의 <u>오버라이딩 된 메서드</u> **실행**
    - "결합도"는 높지만 "**복잡도**"는 상대적으로 **낮아짐**.

<br/>

- `DECORATOR` 패턴
  - <u>**선택적인 행동의 개수와 순서**</u>에 대한 변경 캡슐화  
  - <u>객체의 **행동**</u>을 **동적**으로 추가 → 객체의 "<u>**행동 결합**</u>"
  - 객체의 "`합성`" 활용

<br/>

- `COMPOSITE` 패턴
  - <u>객체의 **수**</u>와 관련된 변경을 **캡슐화**
    - "**개별** 객체" / "**복합** 객체"

<br/>

### 패턴은 단지 나침반
- **널리 요구**되는 <u>유연성</u>이나 <br/>**공통적으로 발견**되는 <u>특정 설계 이슈</u>를 해결하기 위해 <br/>"디자인 패턴"을 이용해 설계
  - **범용적**이고 **통상적**이기 때문에 <br/>그대로 끼워 맞추는 것이 아닌<br/>
  현재의 요구사항 / 적용 기술 / 프레임워크에 <u>적합하지 않다면</u> <br/>⭐️ **목적**에 맞게 **패턴 수정** ⭐️ 필요

**맹목적**인 패턴 적용 및 **구조 끼워맞추기** → <u>컨텍스트 **적절성**</u> 무시 → 문제 발생<br/>
(불필요한 복잡도 + 난해 + 유지보수성 저하)

<br/>

- 다양한 **트레이드 오프**(Trade-Off) 관계 속에서 패턴 적용 및 사용 필요
  - " _패턴의 **복잡함**이 <u>**단순화**보다 나을 경우</u>_ "에만 정당화
  - 설계 **단순성 & 명확성**에 대한 **고민**
  - 코드를 공유하는 사람들은 "**모든 패턴에 대해 인지 및 이해**"해야 함.

즉, 패턴에 끼워맞추는 것이 아닌 <br/>
패턴을 "**지향**"하거나 <u>단순히 패턴을 목표로 두고</u> "**리팩토링**"하는 것이<br/>
패턴을 가장 효과적으로 적용하는 방법이다.

> 범용적일 수 있는 패턴이 공통적인 문제 해결에는 도움이 될 수 있지만<br/>
> <u>해결이 필요한 **구체적인 문제들**</u>에는 "적합하지 않을 수 있다"는 것을 명심해야 한다.
> 
> ⭐️ 문제 **분석** & 창의력 발휘 → <u>직면한 구체적 문제에 적합하도록</u> 적절한 **"수정"**

<br/>
<br/>

---
