# Chapter 15. 디자인 패턴과 프레임워크

- 〚 `디자인 패턴` 〛<br/> :: 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결방법
  - (목적) `설계 재사용`
    - 특정한 변경을 일관성 있게 다룰 수 있는 **협력 템플릿** 제공
    - " <u>**재사용**할 수 있는 **설계의 묶음**</u> "


- 〚 `프레임 워크` 〛<br/> :: 설계와 코드를 함께 재사용하기 위한 것
  - (목적) `설계 및 코드 재사용`
    - <u>애플리케이션의 아키텍쳐</u>를 "**구현 코드**"의 형태로 제공
    - 특정한 변경을 일관성 있게 다룰 수 있는 **확장 가능한 코드 템플릿** 제공
    - " <u>일관성 있는 협력을 제공하는 **확장 가능한 코드**</u> "

## `디자인 패턴` - "설계" 재사용

### ✅ 소프트웨어 패턴
> ⁜ `패턴` : _하나의 실무 컨텍스트(Practical Context)에서 **유용하게 사용해 왔고** <u>**다른 실무 컨텍스트에서도** 유용할 것이라고 예상되는 아이디어</u>_
> - **반복**적으로 발생하는 `{문제 : 해법}`의 쌍으로 정의
> - 이미 알려진 문제 & 해법에 대한 내용 **문서화 가능**
> - 해당 지식을 다른 사람과 **의사소통 가능**
> - ⭐️ "**실무**"에서 탄생
> 
> ( _패턴은 소프트웨어 개발과 직접적인 연광성을 가진 영역만으로 한정된 것이 아님 : ex. 조직 구성 방법/일정 추정 방법 등 등_ )

<br/>

- 경험을 통해 축적된 실무 지식을 효과적이고 요약적으로 전달 가능
  - 지식 전달 & 커뮤니케이션 수단
- 가장 중요한 것 : 패턴의 "**이름**"
  - 간략하게 **패턴의 효과 및 특징**을 축약하는 이름 
  - _ex. "<u>인터페이스를 하나 추가</u>하고 해당 인터페이스 <u>구현 클래스를 만든 후</u>, <u>객체 생성자/`setter`에 할당</u>하여 <u>런타임 시에 알고리즘을 바꿀 수 있도록</u> 설계"_ <br/>→ "`STARTEGY` 패턴"
- 특정 패턴 내 포함된 〚 컴포넌트 - 컴포넌트 〛간 관계 <br/>→ "<u>더 **작은** 패턴</u>에 의해 **서술**" / "<u>더 **큰** 패턴</u>에 **포함**" 가능
  - " **연관된 패턴들의 집합** " :: `패턴 언어(Pattern Language)`  / `패턴 시스템(Pattern System)`

<br/>

### 패턴 종류
> 디자인 패턴 **상위** : `아키텍처 패턴`<br/>
> 디자인 패턴 **하위** : `이디엄`
- **아키텍처** 패턴 (Architecture Pattern) : 소프트웨어 <u>**전체적인 구조 결정**</u>
  - **미리 정의**된 **서브 시스템** 제공
  - 각 서브 시스템 **책임** 정의
  - 〚서브 시스템〛관계 **조직화 규칙 및 가이드라인** 포함
  - 구체적인 소프트웨어 아키텍처를 위한 템플릿 제공
  - 프로그래밍 언어/프로그래밍 패러다임 `독립적`

<br/>

- **분석** 패턴 (Analysis Pattern) : "업무 모델링 시", <u>발견되는 공통적인 구조를 표현하는 개념들의 집합</u>
  - "**도메인 내 개념적 문제**" 해결 목적
  - <u>단일 도메인에만</u> 적절할 수 도 있고 <u>다중 도메인</u>에서 적절할 수 있다.

<br/>

- **디자인** 패턴 (Design Pattern) : <u>특정 정황 내에서 일반적인 **설계 문제 해결**</u>
  - 〚협력 컴포넌트〛들 사이에서 **반복적으로 발생하는 구조** 서술
  - 특정 설계 문제 해결
  - 프로그래밍 언어/프로그래밍 패러다임 `독립적`

<br/>

- **이디엄** (Idiom) : 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴
  - 〚컴포넌트〛/ 〚컴포넌트 간〛**특정 측명 구현 방법** 서술
  - 프로그래밍 언어 `종속적`
    - _특정 언어의 이디엄이 다른 언어에서는 소용 없을 수도 있음_

<br/>

⁜ < **아키텍처 / 다지아니 / 이디엄** > : **기술적** 문제 해결<br/>
⁜ < **분석** > : **개념적** 문제 해결

<br/>

### 패턴 & `책임 - 주도 설계`
⭐️ `객체지향 설계` : "**올바른 책임**"을 "**올바른 객체**에게 할당"하고 "객체 간의 **유연한 협력 관계**"를 구축하는 것

- `책임/협력` : 다양한 요소들의 "**트레이드 오프(Trade-Off)**"에 의해 결정
  - _캡슐화 / 크기 / 의존성 / 성능 / 확장 가능성 / 유연성 / 재사용성 등_


- **패턴** : " <u>공통적으로 사용할 수 있는</u> `역할`, `책임`, `협력`의 **템플릿** "
  - `STARTEGY` 패턴<br/> : 다양한 알고리즘을 **동적으로 교체**할 수 있는 역할과 책임의 집합 제공<br/><br/> 
  - `BRIDGE` 패턴<br/> : (추상화의 조합으로 인한 클래스의 폭발적인 증가 문제 해결)<br/>
  역할과 책임을 `추상화` & `구현` 두 개의 커다란 집합으로 **분해**
    - 확장 가능한 설계 제공<br/><br/>
  - `OBSERVER` 패턴<br/> : (유연한 통지 매커니즘 구축)<br/>
  **객체간의 결합도를 낮출 수 있는** 역할과 책임의 집합 제공


패턴을 따르게 되면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다.

또한 패턴의 구성 요소는 `역할`( _클래스 X_ )<br/>
→ _ex. `COMPOSITE` 패턴 : **클라이언트**가 "**개별 객체**와 **복합 객체**를 동일하게 취급"_
- 클래스가 아닌 <u>**협력에 참여**하는 객체들의 **역할**</u>들로 구성
  - `역할` → **동일한 오퍼레이션에 대해 응답**할 수 있는 "**책임의 집합**" 암시 <br/><br/>
  - <u>해당 역할이 제공하는 **오퍼레이션을 구현**하는 어떤 객체</u>라도 "**본 역할 대체 가능**"
    - _반대로 "**다수의 클래스**가 **동일한 역할** 수행"이 가능하도록 구현하는 것도 가능_ 

<br/>

### `캡슐화` & 디자인 패턴
> _대부분의 디자인 패턴 : **유연 & 일관성 있는 협력**을 만드는 목정_
> 
> → "**특정한 <u>변경</u>**"을 **캡슐화**하기 위한 방법 정의 (**유연 & 일관성 있는 협력**)

- `STRATEGY` 패턴
  - <u>알고리즘 변경</u>을 **캡슐화**
  - 객체의 "`합성`" 활용<br/></br>
  - " **런타임** "에 알고리즘 **변경 가능**

<br/>

- `TEMPLATE METHOD` 패턴
  - <u>알고리즘 변경</u>을 **캡슐화** → "**추상 메서드**"
  - 객체의 "`상속`" 활용
    - 변경하지 않은 부분 = 부모 클래스
    - 변경하는 부분 = 자식 클래스<br/><br/>
    - **부모 클래스**의 <u>추상 메서드</u> 호출 / 적합한 **자식 클래스**의 <u>오버라이딩 된 메서드</u> **실행**
    - "결합도"는 높지만 "**복잡도**"는 상대적으로 **낮아짐**.

<br/>

- `DECORATOR` 패턴
  - <u>**선택적인 행동의 개수와 순서**</u>에 대한 변경 캡슐화  
  - <u>객체의 **행동**</u>을 **동적**으로 추가 → 객체의 "<u>**행동 결합**</u>"
  - 객체의 "`합성`" 활용

<br/>

- `COMPOSITE` 패턴
  - <u>객체의 **수**</u>와 관련된 변경을 **캡슐화**
    - "**개별** 객체" / "**복합** 객체"

<br/>

### 패턴은 단지 나침반
- **널리 요구**되는 <u>유연성</u>이나 <br/>**공통적으로 발견**되는 <u>특정 설계 이슈</u>를 해결하기 위해 <br/>"디자인 패턴"을 이용해 설계
  - **범용적**이고 **통상적**이기 때문에 <br/>그대로 끼워 맞추는 것이 아닌<br/>
  현재의 요구사항 / 적용 기술 / 프레임워크에 <u>적합하지 않다면</u> <br/>⭐️ **목적**에 맞게 **패턴 수정** ⭐️ 필요

**맹목적**인 패턴 적용 및 **구조 끼워맞추기** → <u>컨텍스트 **적절성**</u> 무시 → 문제 발생<br/>
(불필요한 복잡도 + 난해 + 유지보수성 저하)

<br/>

- 다양한 **트레이드 오프**(Trade-Off) 관계 속에서 패턴 적용 및 사용 필요
  - " _패턴의 **복잡함**이 <u>**단순화**보다 나을 경우</u>_ "에만 정당화
  - 설계 **단순성 & 명확성**에 대한 **고민**
  - 코드를 공유하는 사람들은 "**모든 패턴에 대해 인지 및 이해**"해야 함.

즉, 패턴에 끼워맞추는 것이 아닌 <br/>
패턴을 "**지향**"하거나 <u>단순히 패턴을 목표로 두고</u> "**리팩토링**"하는 것이<br/>
패턴을 가장 효과적으로 적용하는 방법이다.

> 범용적일 수 있는 패턴이 공통적인 문제 해결에는 도움이 될 수 있지만<br/>
> <u>해결이 필요한 **구체적인 문제들**</u>에는 "적합하지 않을 수 있다"는 것을 명심해야 한다.
> 
> ⭐️ 문제 **분석** & 창의력 발휘 → <u>직면한 구체적 문제에 적합하도록</u> 적절한 **"수정"**

<br/>
<br/>

---
## `프레임워크` - "코드" 재사용

### "코드" 재사용 vs "설계" 재사용
- 디자인 패턴 : 프로그래밍 "**독립적**" & "<u>재사용 가능한</u> 설계 아이디어" 제공
  - 프로그래밍 언어적 특성에 대한 맞춤형 가공 필요 → 매번 구현 코드 작성 요구

<br/>

- 〚 **코드** 재사용 〛 강조
  - `컴포넌트` 기반 재사용 : 별도 프로그래밍 없이 **기존 컴포넌트 조립**
    - 애플리케이션과 도메인의 **"다양성"** → 비현실적인 방법
- 〚 **설계** 재사용 〛 강조
  - `디자인 패턴` : 추상적인 수준의 설계 재사용
  - **"매번 유사한 코드"** 작성 요구

<br/>

### 이상적인 재사용, `프레임 워크`
> ⭐️ 적절한 `설계 재사용` & `코드 재사용` 조합 (_가장 이상적인 재사용_)

- **구조적** 측면
  - `추상 클래스` / `인터페이스` 정의
  - <u>인스턴스 사이의 상호작용</u>을 통해 시스템 **전체/일부를 구현**해 놓은 **재사용 가능한 설계** 
- **재사용** 측면
  - 직면한 요구사항에 맞게 "**커스터마이징**"할 수 있도록 애플리케이션의 **기본 골조**


- 애플리케이션의 `아키텍처` 제공
- 문제 해결에 필요한 `설계 결정` & `기반 코드` 제공
- "**확장**"을 위한 부분적 구현 `추상 클래스` / `인터페이스` 제공
- <u>추가 작업 없이</u> 재사용 가능한 `컴포넌트` 제공

<br/>

### 패키지 분리 : `상위` 정책 - `하위` 정책
> ⁜ 프레임 워크 핵심 : `추상화` (추상 클래스 & 인터페이스)

`추상화`를 통한 " <u>**변경**의 캡슐화</u> " → **일관성 있는 협력**<br/>
협력 구현 코드의 **의존성**은 가급적 **추상 클래스 / 인터페이스** 사용<br/>
(_추상 클래스 & 인터페이스 → **프레임워크**의 **재사용성 향상**_)<br/>
(_**프레임워크** → **일관성 있는 협력**_)

- 전통적인 개발 방법론
  - 상위 레벨 모듈 → **하위** 레벨 **모듈** 의존
  - 상위 정책 → **구체적 세부 사항** 의존 
    - _변경에 대한 파급 효과 → **불안정**_

<br/>

**상위** 정책 : 상대적으로 **안정적**인 변경 ==  "높은 재사용 가능성"<br/> 
**하위** 정책(세부 사항) : **빈번**한 변경<Br/>
→ " _상위 정책이 하위 정책보다 **더 다양한 상황에서 재사용** 될 수 있어야 한다._ "

> " `상위 정책`을 재사용 한다. " == " 도메인에 존재하는 `핵심 개념들 사이의 협력 관계`를 재사용 한다. "

<br/>

> #### ⭐️ **〚`의존성 역전(D.I)`의 원칙〛**<br/>
>    → <u>상위 정책 & 하위 정책</u> 모두 `추상화` **의존** <br/>
>    → 〚 "**변하는 것**"(`구체적 세부 사항`) / "**변하지 않는 것**"(`상위 정책 협력` 구조) 〛 분리
>   - 다양한 애플리케이션 안에서 "<u>**동일 역할** 수행 객체들 간의 **협력** 구조</u>" 자체를 재사용
>   - **세부 사항 구현 패키지** : "**항상**" <u>상위 정책 구현 패키지</u> 의존
>      - **상위 정책 구현 패키지** : 항상 <u>세부 사항 구현 패키지</u> 의존 ❌
>        - 외부 애플리케이션은 <u>**세부사항** 구현 클래스 패키지</u>에 대해 아는 정보가 없음
>      - **별도 분리 관리** 가능
>        - <u>서로 다른 주기</u>에 **배포** 가능 ("`배포 단위`" 분리)
  
<br/>

**＜ 동일한 프레임워크를 사용하는 여러 애플리케이션 ＞** <br/>
- " **일관성 있는 코드 설계 및 구현** " 가능<br/>
- 일관성있는 구현 : " **이해 용이** "<br/>
- " <u>설계 및 코드</u> **재사용** " 가능


<br/>

### `제어 역전 (IoC : Inversion of Control)`의 원리
> `제어 역전 (IoC : Inversion of Control) 원리` :: `할리우드(Hollywood` <br/>
> ✵ _프레임 워크의 가장 기본적인 설계 매커니즘_

의존성을 역전시킨 객체지향 구조에서는
반대로 프레임워크가 애플리케이션에 속하는 서브 클래스의 메서드를 호출하는

"**전체적인 협력 흐름**"은 프레임워크에 정의되어 있기 때문에<br/>
개발자는 애플리케이션에 <u>필요한 서브 타입들만 개발</u>하기만 하면<br/>
<u>정의되어 있던 플로우</u>에 따라 <br/>
프레임워크가 "**협력**에 따른 **처리 제어**"를 대신한다.

(즉, 우리는 의존성 역전 원칙에 따라 <u>추상화와 구체 클래스를 분리</u>해서 의존성 역전된 **협력 관계**를 **정의만** 해주고<br/>
**서브 타입**들에 대해서만 **개발**하면 <br/><u>**전체적인 플로우 제어**는 프레임워크가 담당</u>하는 것이다.)

<br/>

- `프레임워크` : 일반적인 해결책만 제공  
  - <u>애플리케이션에 따라 **달라질 수 있는** "**특정한 동작**"</u>은 비워둔다. → "**훅(Hook)**"
    - `훅(Hook)` : _완성되지 않은 채로 남겨진 동작 / 프레임워크 코드에서 호출하는 프레임워크의 특정 부분_ <br/><br/>
    - "**애플리케이션의 컨텍스트**"에 따라 <u>훅(Hook)의 구현은 달라질 수 있다</u>
      - <u>재정의된 훅</u>은 제어 역전 원리에 따라 <u>프레임워크가 "**원하는 시점**"에 호출된다.</u><br/><br/>
    - 우리가 직접 명시하지 않아도 때에 따라 **적합한 제어를 프레임워크가 수행**

<br/>

즉, "`관리하는 애플리케이션마다 서로 다른 훅을 프레임워크가 원하는 시점에 호출`"의 모습이다.<br/><br/>
이처럼 " 직접 <u>라이브러리 코드</u>를 가져와 <u>**직접적인 명시를 통한 제어**를 하는 방식</u> "이 아닌<br/>
" 개발자는 <u>프레임워크를 호출하는 코드만 작성</u>하고 <u>**프레임워크에 의해** 제어되게끔 하는 것</u> "을 <br/><br/>
" `제어 역전(IoC)` "라 한다.
