# Chapter 4. 설계 품질과 트레이드 오프

앞서 배웠던 내용에 대해서 다시 짚어보자면
<u>객체지향 설계의 핵심은 **역할, 책임, 협력**이라는 것</u>과

**협력**(**Collaboration**)은 " <u>애플리케이션의 기능 구현을 위해 **메시지**를 주고받는 **객체간의 상호작용**</u> "이고<br/>
**책임**(**Responsibility**)은 " <u>객체가 다른 객체와 **협력하기 위해 수행**하는 **행동**</u> "이며<br/>
**역할**(**Role**)은 " <u>대체 가능한 **책임의 집합**</u> "이라는 것이다.

> ### 객체 지향 설계
> : 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동
> 
> - 객체지향 설계의 핵심은 "책임"이다.
> - 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관되어 있다.
 
설계라는 것 자체가 **변경**을 위해 존재하고<br/>
변경은 <u>어떤 식으로든 **비용**이 발생</u>한다.

이는 변하지 않는 사실이기 때문에<br/>
훌륭한 설계라 함은 이 **비용이 합리적**이며 **변경을 수용하기 용이**한 구조를 만드는 것이고<br/>
그러기 위해서는 <u>**응집도**가 높고 **서로 느슨**하게 결합된 구조</u>를 형성하는 것이다.

결합도와 응집도를 합리적인 수준으로 유지하기 위한 원칙이 있다.<br/>
바로 " <u>_객체의 상태가 아닌 **객체의 행동에 초점**을 맞추는 것_</u> ".

객체를 단순 데이터 집합으로만 바라본다면<br/>
**객체 내부 구현**을 <u>퍼블릭 인터페이스에 노출시키게 되는 참사</u>가 일어날 가능성이 높기 때문에<br/>
결과적으로 **변경에 취약한 실패한 설계**가 될 것이다.

그렇기 때문에 **객체의 행동**. 즉, **객체의 책임**에 초점을 맞춰<br/>
"**객체와 객체 사이의 상호작용**"으로 <u>설계 중심을 이동</u> 시키고,<br/>
결합도가 낮고 응집도가 높으며 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 있는 기반을 제공한다.

<br/>

---
### 데이터 중심으로 설계한다면 어떻게 될까?
데이터 중심 설계라 함은 <br/>
말 그대로 객체의 데이터를 중심으로 설계되는 것을 뜻하는데

여기서 이 데이터는 이전 단원에서 다뤘던 객체의 "**상태**"로 생각하면 된다.

즉, 데이터 중심의 관점은 <u>객체의 상태에 초점</u>을 맞추는 방식이다.<br/>
하지만 객체의 **상태**는 <u>**구현**</u>에 속하며<br/>
<u>구현은 불안정</u>하기 때문에 **변하기 쉬워서**

객체분할의 기준으로 삼게 되면<br/> 
<u>구현에 관한 세부 사항</u>이 객체의 **퍼블릭 인터페이스**에 자연스럽게 **스며들어**<br/>
상태가 변경된다면 인터페이스까지 변경되어야 하고<br/>
그에 따라 <u>인터페이스에 의존하는 **모든 객체</u>에서 수정**이 이루어진다.

그렇다면 당연하게도 올바른 캡슐화는 물론이고 변경에 취약한 설계가 될 수 밖에 없다.

> 객체의 **책임**은 **인터페이스**에 속하기 때문에<br/>
> 객체는 **책임을 드러내는 안정적인 인터페이스** 뒤로 <u>책임을 수행하는 데 필요한 상태를 **캡슐화**함</u>으로써<br/>
> 구현 변경에 대한 파장이 외부까지 영향이 가지 않도록 할 수 있다.
> 
> 따라서 **책임 중심 설계**. 즉, **RDD**는 상대적으로 <u>변경에 안정적인 설계</u>를 얻을 수 있는 것이다.
 
<br/>

## "데이터" 중심 설계 vs "책임" 중심 설계

물론 데이터 중심 설계가 단점만 존재하는 설계 방법론은 아니다.<br/>
객체 지향 설계 패러다임에서의 데이터 중심 설계가 상대적으로 효율적이지 않다는 것이다.

상대적으로 효율적인 책임 중심 설계와의 차이점은 세 가지 품질 척도에서 발생한다.<br/>
바로 "**캡슐화**", "**응집도**", "**결합도**" 이다.

### 캡슐화
우선 객체의 상태와 행동을 모으는 이유는<br/>
<u>추후 변경될 가능성이 높은 **내부 구현**</u>을 **외부로부터 감추기 위해**서이다.

이 캡슐화가 <u>한 곳에서 일어난 변경</u>이 **전체 시스템에 영향을 끼치지 않도록** <u>파급효과를 조절</u>할 수 있는 장치로서 작용하는 것이<br/>
객체 지향이 강력한 이유 중 하나이다.<br/>
( _변경 가능성이 높은 구현은 내부에 숨기고 외부에는 상대적으로 안정적인 인터페이스만 공개 → **변경 여파 통제**_ )

그렇기 때문에 객체를 설계할 땐 가장 기본적으로 <u>변경의 정도를 따져</u> **구현과 인터페이스를 분리**하고 <br/>
**외부에서는 인터페이스에만 의존하도록** 관계를 조절하는 것이 중요하다.

사실 사용자 요구사항이 변경되지 않는다면 이렇게까지 설계에 신경쓸 필요가 없겠지만<br/>
요구사항은 어떠한 이유에서라도 변경될 가능성이 다분하기 때문에<br/>
이로 인해 발생하는 변경의 영향을 통제하기 위해 캡슐화를 기준으로 설계의 품질을 높이는 것이 중요한 것이다.

정리하자면 캡슐화는 변경 가능성이 높은 부분을 객체 내부를 숨기는 추상화 기법 중 하나이며<br/>
<u>변경될 가능성이 있다면</u> **어떤 것이라도 캡슐화**하여 객체 지향 프로그램을 구현하는 것이 핵심이다.<br/>

<br/>

> 복잡성을 다루기 위한 가장 효과적인 도구는 "**추상화**"다.<br/>
> 다양한 추상화 유형이 있지만<br/>
> <u>객체지향 프로그래밍에서 복잡성을 취급하는 주요 추상화 기법</u>은 **캡슐화**이다.
> 
> 하지만 객체지향 언어를 사용한다는 것만으로 애플리케이션의 복잡성이 잘 캡슐화된다는 보장이 없다.<br/>
> **언어**는 캡슐화를 향상시킬 수 있는 **수단**일 뿐이고<br/>
> 객체지향 프로그래밍을 통해 전반적으로 얻을 수 있는 장점은<br/>
> <u>오직 **설계 과정** 동안 **캡슐화를 목표로 인식할 때만** 달성</u>될 수 있다.<br/>
> 
> ᠆ _Wirfs-Brock89_ ᠆

> **유지보수성**이 목표다.
> 
> 유지보수성이란 <u>두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있는 능력</u>을 말하며<br/>
> 가장 중요한 동료로 캡슐화를 뽑을 수 있다.
> 
> 캡슐화는 어떤 것을 숨긴다는 것을 의미하는데<br/>
> 이를 통해 시스템의 한 부분을 **다른 부분으로부터 감춤**으로서<br/>
> <u>뜻밖의 피해가 확산될 가능성</u>을 **사전에 방지**할 수 있다.<br/>
> 
> 만약 시스템의 캡슐화가 크게 부족하다면<br/>
> <u>변경으로부터 자유로울 수 없고</u><br/>
> 결과적으로 시스템은 <u>진화할 수 없게 될 것</u>이다.
> 
> 물론 응집도, 결합도, 중복 역시 훌륭한 코드를 규정하는데 핵심적인 품질 지표이지만<br/>
> 가장 중요한 제 1원리는 **캡슐화**이다.
>
> ᠆ _Bain08_ ᠆

<br/>

### 응집도 & 결합도

- **응집도** : 모듈에 포함된 **내부 요소들이 연관돼 있는 정도**
  - 모듈 내 요소들이 하나의 목적을 위해 긴밀하게 협력 ➡ "높은 응집도"
  - 객체 또는 클래스에 <u>얼마나 관련 높은 책임들을 할당했는지</u> 나타내는 지표


- **결합도** : **의존성의 정도**
  - 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지
  - 다른 모듈에 대해 너무 자세한 부분까지 알고 있다 ➡ 두 모듈 모두 "높은 결합도"
  - 다른 모듈에 대해 꼭 필요한 지식만 알고 있다 ➡ 두 모듈 모두 "낮은 결합도"
  - 객체 또는 클래스가 <u>협력에 필요한 적절한 수준의 관계만을 유지하고 있는지</u> 나타내는 지표

일반적으로 좋은 설계라 함은 <br/>
흔히 알고있다시피 **각 요소의 응집도**는 <u>높으면서</u><br/>
**서로 느슨하게 결합**되어 <u>낮은 결합도</u>를 가진 설계라고 할 수 있다.

이와 같은 설계를 추구해야 하는 이유는 단 한가지 "<u>**설계를 변경하기 쉽게 만들어준다**.</u>"이다. 

[ **변경의 관점** ]에서 살펴보면<br/>
**응집도**는 <u>변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도</u>로 측정할 수 있는데

" 응집도가 높은수록 " _**변경의 대상과 범위가 명확**해지기 때문에 코드를 변경하기 쉬워지고<br/>
수정되는 부분을 파악하기 위해 다른 코드를 해매거나 여러 모듈을 동시에 수정할 필요도 없어<br/>
변경을 반영하기 위해 직접적으로 관련된 적은 수의 모듈들만 수정하면 된다._

<br/>

**결합도**는 <u>하나의 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도</u>로 측정할 수 있는데<br/>

" 결합도가 낮을수록 " _특정 모듈을 변경했을 때, 적은 수의 다른 모듈들만 영향을 받게된다._

<br/>

영향 범위 내의 모듈 수 외에도<br/>
" 내부 구현을 변경했을 뿐인데 " 다른 모듈에 영향을 미친다면 _두 모듈 사이의 결합도가 높다고_ 표현하고<br/>
" 인터페이스를 수정했을 때만 " 다른 모듈에 영향을 미친다면 _두 모듈 사이의 결합도가 낮다고_ 표현한다.

물론 <u>표준 라이브러리의 모듈이나 안정화된 프레임워크에 의존하는 경우</u>에는<br/>
결합도가 높아도 상관없지만<br/>
**우리가 새롭게 작성하는 코드들은 다르다.**<br/>
직접 작성한 코드는 <u>요구사항의 변경이나 버그 등</u>으로 인해<br/>
항상 불안정하고 언제라도 변경될 수 있기 때문에<br/>
이를 대처하기 위한 대비책으로 응집도와 결합도를 신경써야한다.

<br/>

---
### 데이터 중심 설계의 문제점

1. **본질적으로 너무 이른 시기에 데이터에 대하여 결정하도록 강요한다.**
2. **협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.**

<br/>

#### ⁜ 객체의 행동 << 상태
데이터는 구현의 일부이며<br/>
앞서 말했다시피 너무 이른 시기에 데이터에 대해 결정하도록 강요하기 때문에<br/>
<u>너무 이른 시기에 **내부 구현**에 초점</u>을 맞추게 하는 것이 문제점인 것이다.

<span style="color:grey">_실제 데이터 중심 설계 방식에 익숙해지면 <u>일반적으로 데이터와 기능을 분리하는 절차적 프로그래밍 방식을 따르게 되고</u><br/>
이로 인해 상태와 행동을 하나의 단위로 캡슐화하는 원칙을 위반하게 된다._</span>

데이터 중심의 관점에서 객체는 **그저 단순 데이터 집합체**이기 때문에<br/>
<u>접근자와 수정자를 남발</u>하게 되어 **구현을 그대로 노출** 시키게되니 캡슐화가 완전히 무너지게 되는 것이다.

즉, 데이터를 먼저 결정하고 데이터를 처리하는데 필요한 오퍼레이션을 나중에 결정하게 됨으로서<br/>
**데이터에 관한 정보**가 객체의 <u>인터페이스에 고스란히 드러나</u><br/>
결과적으로는 " 구현을 캡슐화하는데 실패한 것과 더불어 변경에 취약한 코드가 작성된다. "

<br/>

#### ⁜ 객체 고립 + 오퍼레이션 정의
객체지향 애플리케이션에서 가장 중요한 것은 **협력하는 객체들의 공동체를 구축하는 것**이기 때문에<br/>
<u>협력이라는 문맥 안에서 필요한 책임을 결정하고 이를 수행할 적절한 객체를 결정하는 것</u>이 가장 중요하다.

그렇기 때문에 올바른 **설계의 중심**은 <u>항상 상태와 내부가 아닌 **외부에** 맞춰져 있게끔</u> 하고<br/>
내부에 어떤 상태를 가지고 어떻게 관리하는가보다 <br/>
<u>**외부에서 다른 객체와 협력하는 방법**에 집중하는 것</u>이 중요하다.

하지만 " 데이터 중심 설계 "는 내부에 초점이 맞춰져 있기 때문에<br/>
실행 문맥에 대해 별 고민 없이 객체가 관리할 **데이터의 세부 정보를 먼저 결정**한다.<br/>
당연히 세부 정보를 먼저 결정하고 협력 방법을 고민하기 때문에 <br/>
<u>이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수 밖에 없는 것이다.</u>

그에 따라 **협력**이 **구현 세부 사항에 종속**되어<br/>
<u>객체 내부 구현의 변경에 따라 **모든 협력 객체에 영향**을 끼치는 것</u>이 불가피해지기 때문에<br/>
유연하지 못한 설계가 되어버린다.

<br/>


<!--
### 코드로 알아보기

```java
/**
 * 사전 데이터
 */
public class Movie {
  private String title;
  private Duration runningTime;
  private Money fee;
  private List<DiscountCondition> discountConditions;
  
  // 데이터 중심 시스템 설계 
  // 미리 세부 정보를 정해놓음
  private MovieType movieType;
  private Money discountAmount;
  private double discountPercent;
}
```
미리 정해 놓은 세부 정보들이 있기 때문에<br/>
그에 따라 필요한 값들도 준비해주어야 한다.

```java
public enum MovieType {
    AMOUNT_DISCOUNT, // 금액 할인 정책 
    PERCENT_DISCOUNT, // 비율 할인 정책
    NONE_DISCOUNT // 미적용
}
```
```java
public enum DicountConditionType {
    SEQUENCE, // 순번 조건 
    PERIOD // 기간 조건
}
```

물론 캡슐화 원칙에 따라 내부 속성들을 직접 사용하지 못하도록<br/>
접근자와 수정자가 추가 될 것이다.

```java
public class Movie {
  private String title;
  private Duration runningTime;
  private Money fee;
  private List<DiscountCondition> discountConditions;

  private MovieType movieType;
  private Money discountAmount;
  private double discountPercent;

  public MovieType getMovieType() {
    return movieType;
  }
  public void setMovieType(MovieType movieType) {
    this.movieType = movieType;
  }

  public Money getFee() {
    return fee;
  }
  public void setFee(Money fee){
      this.fee = fee;
  }

  public List<DiscountCondition> getDiscountConditions() {
    return Collections.unmodifiableList(discountConditions);
  }
  public void setDiscountConditions(List<DiscountCondition> discountConditions){
      this.discountConditions = discountConditions;
  }

  public Money getDiscountAmount() {
    return discountAmount;
  }
  public void setDiscountAmount(Money discountAmount){
      this.discountAmount = discountAmount;
  }

  public double getDiscountPercent() {
    return discountPercent;
  }
  public void setDiscountPercent(double discountPercent){
      this.discountPercent = discountPercent;
  }
}
```
-->