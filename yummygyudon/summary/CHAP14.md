# Chapter 14. 일관성 있는 협력

- 객체 : 협력을 위해 존재 - **협력의 주체**
  - 협력 : 문맥 제공
- 좋은 설계의 애플리케이션 : **이해** 용이 & **수정** 용이 & **재사용** 용이
  - 올바른 객체 지향 설계 → 좋은 설계
  - <u>"적절한 **책임**을 수행하는 객체"들의 "**협력**"</u>을 기반으로 "**재사용 가능**"한 "**낮은 결합도**"의 코드


- 객체 지향 패러다임
  - 설계 재사용
    - "**일관**된" 객체 간 **협력 방식**
    - ⭐️ <u>유사한 기능을 구현</u>하기 위해 가능한 "**유사한 협력 패턴**"을 사용해야 한다.
  - 비용 감소

<br/>

---
## 비일관성의 문제점

- **기능 구현** : 각자의 책임을 가지는 객체들 간의 **협력** 관계 구축
- `책임 할당 원칙` : 책임을 수행하는데 "**필요한 정보를 가장 잘 알고 있는** <u>정보 전문가</u>"에게 할당

여기서 모든 기능들을 구현 때,<br/>
확장을 위해 클래스를 추가하면서 위 규칙이 준수하며 구현했고 최종적으로도 동작에 성공했더라도<br/>
결국 유사 기능 그룹 내 클래스들의 설계가 서로 다르다면 문제가 발생한다.
- "**새로운 구현을 추가**"해야 하는 상황<br/> : **새로운 유사 기능 구현을 추가할 때** 필요한 규칙들을 모두 각자 생성 및 관리하면서 <u>매번 새로운 구현 방식이 생겨나는 것</u>이다.


- "**기존의 구현을 이해**"해야 하는 상황<br/> : 위 상황에 발생하는 문제들로 인해 자연스레 "**유사 기능**이더라도 <u>서로 다른 규칙과 구현</u>"을 갖고 있기 때문에<br/>모든 기능 구현체 하나하나를 파보면서 <u>각자의 설계를 이해</u>해야 한다.

즉, "기존 설계의 **비일관성**"으로 인해<br/>
<u>기존의 설계가 어떠한 가이드를 제공하지 않기</u> 때문에<br/>
새로운 구현체를 만들어야 할 때, 또 다른 개발자는 **또 다른 방식으로 구현할 가능성**이 높아지는 치명적 단점이 있는 것이다.

<br/>
<br/>

---
## 일관성 부여기
> ⭐️ " _**다양한 설계 경험을 익혀라.**_ "<br/>
> ⭐️ " _널리 알려진 **디자인 패턴을 학습**하고 `변경`이라는 **문맥 안**에서 패턴을 **적용해보라.**_ "

#### ♨️ 일관된 협력 관계 구축 원칙 ♨️
- `변하는 개념` :  <u>변하지 않는 개념으로부터 **분리**</u>
- `변하는 개념` :  <u>"**캡슐화**"</u>
  - 추후에 바뀌지 않는 부분에는 **수정으로 인한 영향을 미치지 않은 채**로 확장 가능

<br/>

### 조건 로직 vs 객체 탐색
- `절차적`인 조건 검증 방식 → 새로운 조건을 추가하기 위해선 "**기존 내부 코드 수정** 필요" & "한 클래스 안에 **서로 다른 검증 코드 밀집**"


- `객체 지향적` 조건 검증 방식 → 조건 로직을 "<u>**객체 사이**의 **이동**</u>"으로 대체
  - 대체가 가능하게 만들어준 설계 기법 : `다형성` 
  - "수신하는 객체 타입"과 "해당 타입을 믿고 메시지를 보내주는 클라이언트" 간의 **협력 관계** 활용
    - 처리에 대한 **구체적 메서드**를 결정하는 것 : **수신 객체** <br/>(클라이언트는 전달해주는 메시지의 구체적인 내용을 모르고 참조를 통해 메시지를 전달할 뿐)

<br/>

`객체 지향적` 조건 검증 방식처럼
<u>**유사한 행동**을 수행하는 작은 **구체화** 클래스들</u>이 <br/>
"**역할**"이라는 **추상화**로 묶이게 되고<br/>
`클라이언트 - 역할` 사이의 **협력** 방식을 통해 전체 설계의 **일관성을 유지**<br/>
(_각각의 <u>작은 클래스들에 변경이 발생하더라도</u> "**단일 책임 원칙**"이 따르도록 분리되어 있기 때문에 타 클래스에 영향을 끼치지 않는다._)

- 클라이언트 → `역할`(`추상화`) 의존 → 메시지 **수신자 타입**의 완벽한`캡슐화`
  - 결합도 감소
  - **대체 가능**한 역할로 구성된 **협력 관계** 구축 가능
- `역할`을 구성하는 작은 클래스들 → `캡슐화`

_**상속**, **합성** 모든 방식으로 타입을 캡슐화할 수 있기에_<br/>
가장 중요한 것은<br/>
<u>"**변경**"에 초점을 맞추고 캡슐화의 관점에서 설계</u>해서 "**일관성 있는 협력 패턴**"을 구성하는 것이다.

> 📍 **객체지향의 핵심 개념**
> 
> - `구성 요소 캡슐화`
>   - 시스템 → "**책임**"을 `캡슐화`하여 `분리` → **결합도 제한**
>   - <u>"`엔티티` 사이의 관계"</u>가 **추상적인 수준**에서 정의 :: " <span style="color:grey">_인터페이스에 대해 설계해야 한다_</span> " <span style="color:grey">_-GoF-_</span>
>   - 다양한 패턴들이 빈번하게<br/>
>   "요소들이 <u>관계를 맺을 수 있는 대상</u>을 **추상적인** `기반 타입(슈퍼타입/인터페이스)`으로 **제한**"한다.

<br/>

### 캡슐화 
⁜ **캡슐화** : "**데이터 은닉**(Data Hiding)"을 넘어 "<u>**변하는 어떤 것이든**</u>" 외부로부터 숨기는 것
- `퍼블릭 인터페이스` - `구현` 분리
  - **클라이언트** -(`퍼블릭 인터페이스`)→ **서버** → 적절한 `구현`이 처리
  - _클라이언트에게 정확한 구현에 대해 숨기는 형식_


- 코드 수정으로 인한 파급 효과 제어 가능
- `데이터` 캡슐화  & `메서드` 캡슐화 : <u>**개별** 객체</u>에 대한 **변경 관리**
- `객체` 캡슐화 & `서브타입` 캡슐화 : <u>**협력 관계**의 객체들 관계</u>에 대한 **변경 관리**

<br/>

> 💊 **캡슐화** 💊
> - "**데이터**" 캡슐화 : 클래스 <U>**내부에서 관리하는 데이터**</U> 캡슐화
> 
> 
> - "**메서드**" 캡슐화 : 클래스 <u>**내부의 행동**</u> 캡슐화
> 
> 
> - "**객체**" 캡슐화 : <u>**객체와 객체 사이의 관계**</u> 캡슐화 :: `합성`
> 
> 
> - "**서브타입**" 캡슐화 : <u>**기반 타입**를 통한 서브타입</u> 캡슐화 :: 다형성의 기반

<br/>
<br/>

---
## 일관성 있는 설계 구현
### 1. 변경 분리
> <u>요구 사항 분석</u> → "**변하는**" 개념 & "**변하지 않는**" 개념 **분리**

- <u>**유사** 기능 수행 타입들</u> 간의 "`공통점`"(**변하지 않는** 개념) & "`차이점`"(**변하는** 개념) 분리

<br/>

### 2. 변경 캡슐화
- `변하지 않는 부분` → 오직 <u>"`변하는 부분`의 **공통점**"에 대한 추상화</u>에만 **의존**
  - 해당 관계로 제한하면 <U>`변경`을 캡슐화</U>하는 것이 가능해진다.

_ex._
- 변하지 않는 것 : 규칙
- 변하는 것 : 적용조건
  - "적응조건"라는 개념 자체 : `추상화`
  - "자세한 조건 기준 및 연산 방식" : `서브타입`


- _"규칙"을 "적용조건"이라는 추상화에만 의존하도록 관계 제한_ (**<u>합성</u> 관계** 연결) 

<br/>

### 3. 협력 패턴 설계
> 적절한 분리와 추상화가 이루어졌다는 전제 조건
> 
> ⁜ " _**유사한 기능**에 대해 **유사한 협력 패턴**을 적용하는 것_ " :: `개념적 무결성(Conceptual Integrity)`
 
- "추상화"만으로 구성한 협력 → " **재사용 가능한 협력 패턴** "
  - <u>`추상화`</u> → <u>변동적인 상황마다 적절한 **구체적 사례**</u> 대체 
    - <u>추상화의 `서브 타입`</u> 추가 → **구체적인 협력** 구현
  - "협력에 참여한 추상화" 에 **<u>책임</u> 할당**
    - 다양한 상황에 대한 **대응 및 확장**


- 변하지 않는 부분 분리 → 공통의 변하지 않는 부분 "재사용 가능"

<br/>

### 4. 협력 패턴 통일화

만약 " _기존의 협력 방식에서 벗어날 수밖에 없는 경우_ "


또 다른 협력 패턴을 적용하는 것보다는
<u>설계를 약간 비틀어 약간의 부조화가 발생하더라도</u><br/>
가급적 **기존 협력 패턴**에 맞추어 <u>**전체적인 일관성**을 유지하고 **개념적 무결성**을 보장</u>하는 설계를 선택하는 것이 현명하다.

> ⭐️ **지속적인 리팩토링 및 개선** ⭐️
> 
> 협력은 **절대적으로 고정되는 것이 아니기** 때문에<br/>
> _만약 계속적인 부조화가 발생하고 설계의 일관성이 어긋하게 된다면_<br/>
> <u>변경을 수용할 수 있는 **새로운 협력 패턴**을 채택</u>하는 것이 옳다.
> 
> 즉 현재 설계에 맹목적인 일관성을 좇기보단 "**변경의 방향**에 맞춰 **지속적인 개선**"에 신경써야 한다.


<br/>

> #### ※ 패턴 탐색 ※
> 
> - 유사한 기능에 대한 변경의 지속적 발생 <br/>→ `변경 캡슐화`가 가능한 **추상화** 탐색 & 변하지 않는 **공통적 책임 할당**
>   - 현재 구조가 적합하지 않다면 <br/>
>   <u>코드 수정 없이 원하는 변경을 수용</u>할 수 있도록 **협력 & 코드 리팩토링**<br/><br/>
>   - 한 번의 탐색으로 끝나는 것이 아닌 <u>반복적인 협력의 구조를 탐색하며 꾸준히 **개선 및 수정**</u>하여 **진화**
