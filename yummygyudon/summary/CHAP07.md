# Chapter 7. 객체 분해
> - **인지 부조화**(**Cognitive Overload**)
>   - 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 <br/>
>   문제 해결 능력이 급격히 떨어지는 현상 
> - **추상화**(**Abstract**)
>   - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
> - **분해**(**Decomposition**)
>   - 큰 문제를 해결 가능한 작은 문제로 나누는 작업

한 번에 단기 기억에 담을 수 있는 추상화의 수에는 한계가 있지만<br/>
추상화를 더 큰 규모의 추상화로 압축시킴으로써 단기 기억의 한계를 초월할 수있다.<br/>
그에 따라 추상화와 분해는 <br/>
인간이 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구인 셈이다.

복잡성이 존재하는 곳에 추상화와 분해 역시 함께 존재하며<br/>
어쩌면 가장 복잡한 분야라고 할 수 있는 소프트웨어 개발 영역의 문제를 해결하기 위해 사용해왔다.

---
## "프로시저" 추상화 && "데이터" 추상화

현대적인 프로그래밍 언어를 특정 짓는 중요한 두 가지 추상화 매커니즘은<br/>
"**프로시저 추상화**"와 "**데이터 추상화**"이다.

- **프로시저 추상화**(**Procedure** Abstraction) : 소프트웨어가 무엇을 <u>해야하는지</u> 추상화
- **데이터 추상화**(**Data** Abstraction) : 소프트웨어가 무엇을 <u>알아야 하는지</u> 추상화

시스템을 분해하는 방법을 결정하기 위해서는<br/>
선행적으로 앞서 언급한 추상화 방향을 결정해야 한다.
- <u>**프로시저 추상화**</u> <br/>→ **기능 분해**(`Functional Decomposition`) == **알고리즘 분해**(`Algorithm Decomposition`)<br/>


- <u>**데이터 추상화**</u> <br/>→ **타입 추상화**(`Type Abstraction`) : **추상 데이터 타입**`Abstract Data Type` 
<br/>→ **데이터 중심** 프로시저 추상화 : **객체지향**(`Object-Oriented`)

지금까지의 **객체지향 패러다임**은 " <u>역할과 책임을 수행하는 자율적인 객체들의 협력 공동체를 구축하는 것</u> "으로 설명되었다.<br/>
여기에서 `역할과 책임을 수행하는 객체`라는 존재가 바로 객체 지향 패러다임의 <u>추상화</u>이며<br/>
`기능을 협력하는 공동체로 구성`하기 위해 객체들로 나누는 과정이 객체 지향 패러다임의 <u>분해</u>인 것이다.

<br/>

## "프로시저" 추상황 && "기능" 분해

우선 전통적인 분해 방법은 바로 **기능 분해** 방식이다.<br/>
기능 분해의 관점에서 <u>추상화의 단위</u>는 **프로시저**로<br/>
시스템은 프로시저 단위로 분해된다.

더불어 <u>**하향식 접근법**</u>(**Top-Down Approach**)으로 분해 작업이 수행되는데<br/>
시스템을 구성하는 **가장 최상위 기능**을 정의한 후에<br/>
이 최상위 기능을 <u>좀 더 작은 단계의 하위 기능으로 분해해 나가는</u> 방법이다.

분해는 <u>세분화된 마지막 하위 기능</u>이 **프로그래밍 언어로 구현 가능한 수준이 될 때까지** 반복된다.<br/>
( _각 세분화 단계는 바로 위 단계보다 더 구체적이어야 함_ )

<br/>

앞서 설명했듯이<br/>
최상위의 추상적인 함수 정의에서부터 출발한다.<br/>
이는 시스템의 기능을 표현하는 **하나의 문장으로** 나타내는 것이다.

이후, 단계적인 정제 절차를 따라 시스템을 구축하는데<br/>
세부적인 단계의 문장으로 분해해나간다.

즉, <u>하나의 문장으로 표현된 기능을 여러 개의 더 작은 기능으로 분해</u>하는 작업이다.

기능 분해 방법에서는
<u>**기능을 중심**으로 필요한 데이터를 결정</u>한다.<br/>
기능 분해를 위한 하향식 접근법은 **우선적으로** <u>필요한 기능에 대해 생각</u>하고<br/>
이 기능을 <u>분해하고 정제하는 과정</u>에서 **필요한 데이터의 종류와 저장 방식**을 **식별**한다.

> #### ⁜ 하향식 기능 분해 문제점
> 최상위의 가장 추상적인 메인 함수 정의를 시작으로 <br/>
> 구현 가능한 수준의 세부적인 단계까지 분해해나가는 구조는 "트리구조"이다.
> 
> 메인 함수는 이 기능 분해 트리의 루트(root)이며<br/>
> 분해되는 단계에 따라 분리된 하나의 프로시저는 노드(node)인 것이다.
> 
> 분명 구조적이고 체계적인 방법이지만<br/>
> 불규칙하고 불완전한 어쩌면 가장 복잡한 분야라고 할 수 있는 소프트웨어 개발에서는<br/>
> 되려 혼란과 동요를 발생시키는 것이다.
> > - <u>하나</u>의 메인 함수로 **정의 및 구성 불가**
> > - **빈번한 수정 및 재설계** 발생
> > - <u>비즈니스 로직</u>과 <u>사용자 인터페이스</u>의 **강한 결합**
> > - <u>너무 이른 시기</u>에 결정된 **실행 순서 고정**
> >   - 변경에 취약
> >   - 유연성과 재사용성 저하
> > - <u>데이터 형식 변경</u>에 대한 **파급효과 예측 불가능**

<br/>

하향식 분해가 유용한 경우는<br/>
<u>**작은 프로그램**과 **개별 알고리즘**을 취급</u>하는 경우다.<br/>
특히 <u>**이미** 해결된 알고리즘을 정리하고 서술</u>하는 데에 훌륭한 기법이다.

다시 말해, <u>새로운 것을 개발하고, 설계하고, 발격하는 데 적합한 기법이 아닌</u><br/>
**이미 해결되었고 증명된 것**에 대하여 **서술할 때** 적합한 기법이다. 
입
하지만 <u>하나의 함수에 제어가 집중</u>되어 있기에<br/>
데이터에 대한 **영향도를 파악하기도 어렵고** **재사용하기 어렵다**는 단점과 더불어<br/>
동작하는 커다란 소프트웨어 설계에는 적절치 않은 기법인 것이다.

<br/>
<br/>

---
## 모듈
시스템의 변경을 관리하는 기본적인 전략은<br/>
**함께 변경되는 부분**을 <u>하나의 구현 단위로 묶고</u> <u>**퍼블릭 인터페이스**를 통해서만 접근</u>하도록 만드는 것이다.<br/>
즉, 기능을 기반으로 시스템을 분해하는 것이 아니라 <u>**변경의 방향**에 맞춰 분해</u>하는 것이다.

해당 전략의 핵심이 바로 "**정보 은닉**(**Information Hiding**)"이다.<br/>
정보 은닉은 <u>시스템을 모듈 단위로 분해하기 위한 기본 원리</u>로<br/>
시스템에서 **자주 변경되는 부분**을 상대적으로 <u>덜 변경되는 안정적인 인터페이스 **뒤**</u>로 **감춰야 한다**는 것에 초점이 맞춰져 있다.

그에 따라
시스템을 모듈로 분해한 후에는
각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.

**기능 분해**가 하나의 기능을 구현하기 위해 <u>필요한 기능들을 순차적으로 찾아가는</u> "**탐색**"의 과정이라면<br/>
**모듈 분해**는 감춰야 할 비밀을 선택하고 <u>비밀 주변에 보호막을 설치하는</u> "**보존**"의 과정이라고 볼 수 있다.<br/>
( `비밀 결정` → `모듈 분해` → `기능 분해` → `퍼블릭 인터페이스 구현`)

<br/>

> #### ⁜ 모듈이 숨길 비밀
>
> 1. **복잡성**<br/>
>    : 너무 복잡할 경우 이해하고 사용하기 어려우므로<br/>외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 통해 복잡도를 낮춘다.
>
> 
> 2. **변경 가능성**<br/>
>    : 변경 가능한 설계 결정이 노출될 경우, 변경 발생 시의 파급효과가 커진다.<br/>외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.
> 
> _* **데이터 캡슐화**(**Data Encapsulation**)와 **정보 은닉**은 엄연히 다르다.<br/>
> 정보 은닉에서는 지켜져야할 비밀이 **반드시 데이터일 필요는 없으며** <u>로직이나 자료 구조</u>일 수 있다.<br/>
> 일반적으로 시스템의 비밀은 데이터이다 보니 해당 관점에서 혼동이 되기 쉽다._

<br/>

### 장점과 한계

#### ⁜ 장점
1. 모듈 <u>내부 변수가 변경되더라도</u> **모듈 내부에만** 영향 <br/>
    - 모듈 내부 정의 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한 가능
    - 데이터 변경에 대해 영향을 받는 함수는 해당 데이터를 정의한 모듈만 검색하면 된다.
    - 데이터 변경으로 인한 파급효과 제어 가능 → 코드 수정 및 디버깅 용이<br/><br/>
2. 비즈니스 로직과 사용자 인터페이스에 대한 <u>**관심사 분리**</u>
    - 사용자 입력과 화면 출력 같은 사용자 인터페이스를 담당하는 모듈과 비즈니스 로직을 담당하는 모듈을 분리함으로서<br/>**각자의 관심사에 대해서만 담당**하도록 설계할 수 있고<br/>그에 따라 <u>사용자 인터페이스의 변경이 잦더라도</u> **비즈니스 로직은 변경할 필요가 없게** 된다.<br/><br/>
3. <u>**전역 변수**와 **전역 함수**를 제거함</u>으로써 "**네임 스페이스 오염**(**namespace pollution**)" 방지
    - <u>변수와 함수를 모듈 내부</u>에 포함 → 타 모듈에서도 **동일한 이름 사용 가능**
    - 네임스페이스 오염을 방지하는 동시에 **이름 충돌**(**Name Collision**)의 위험을 **완화**한다.<br/><br/>

모듈은 기능이 아닌 **변경에 정도**에 따라 시스템을 분해하게 하고<br/>
각 모듈은 <u>외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합</u>이기 때문에<br/>
모듈 내부는 **높은 응집도**를 유지하고<br/>
모듈과 모듈 사이에는 <u>퍼블릭 인터페이스를 통해서만 통신함</u>으로서 **낮은 결합도**를 유지한다.

하향식 기능 분해와는 달리<br/>
모듈은 감춰야 할 데이터를 결정하고 이 데이터를 조작하는데 필요한 함수를 결정한다.

즉, 기능이 아닌 데이터를 중심으로 시스템을 분해하였기에<br/>
모듈을 "<u>데이터와 함수가 통합된</u> 한 차원 높은 **추상화 설계**"의 한 단위로서 활용할 수 있다.

<br/>

#### ⁜ 한계
비록 모듈이 프로시저 추상화보다는 높은 추상화 개념을 제공하지만<br/>
애초에 **변경을 관리하기 위한 구현 기법**으로서 만들어진 기법이기 때문에 <u>추상화 관점에서의 한계점</u>이 명확하다.

- " _**인스턴스의 개념을 제공하지 않는다**._ "

만약 **좀 더 높은 수준의 추상화**를 실현하기 위해선 <u>개별 인스턴스를 독립적으로 다룰 수 있어야</u> 한다.<br/>
이 때 필요한 개념이 바로 **추상 데이터 타입(Abstract Data Type)** 이다.

<br/>

## 데이터 추상화 && 추상 데이터 타입