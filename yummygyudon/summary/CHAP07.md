# Chapter 7. 객체 분해
> - **인지 부조화**(**Cognitive Overload**)
>   - 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 <br/>
>   문제 해결 능력이 급격히 떨어지는 현상 
> - **추상화**(**Abstract**)
>   - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
> - **분해**(**Decomposition**)
>   - 큰 문제를 해결 가능한 작은 문제로 나누는 작업

한 번에 단기 기억에 담을 수 있는 추상화의 수에는 한계가 있지만<br/>
추상화를 더 큰 규모의 추상화로 압축시킴으로써 단기 기억의 한계를 초월할 수있다.<br/>
그에 따라 추상화와 분해는 <br/>
인간이 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구인 셈이다.

복잡성이 존재하는 곳에 추상화와 분해 역시 함께 존재하며<br/>
어쩌면 가장 복잡한 분야라고 할 수 있는 소프트웨어 개발 영역의 문제를 해결하기 위해 사용해왔다.

---
## "프로시저" 추상화 && "데이터" 추상화

현대적인 프로그래밍 언어를 특정 짓는 중요한 두 가지 추상화 매커니즘은<br/>
"**프로시저 추상화**"와 "**데이터 추상화**"이다.

- **프로시저 추상화**(**Procedure** Abstraction) : 소프트웨어가 무엇을 <u>해야하는지</u> 추상화
- **데이터 추상화**(**Data** Abstraction) : 소프트웨어가 무엇을 <u>알아야 하는지</u> 추상화

시스템을 분해하는 방법을 결정하기 위해서는<br/>
선행적으로 앞서 언급한 추상화 방향을 결정해야 한다.
- <u>**프로시저 추상화**</u> <br/>→ **기능 분해**(`Functional Decomposition`) == **알고리즘 분해**(`Algorithm Decomposition`)<br/>


- <u>**데이터 추상화**</u> <br/>→ **타입 추상화**(`Type Abstraction`) : **추상 데이터 타입**`Abstract Data Type` 
<br/>→ **데이터 중심** 프로시저 추상화 : **객체지향**(`Object-Oriented`)

지금까지의 **객체지향 패러다임**은 " <u>역할과 책임을 수행하는 자율적인 객체들의 협력 공동체를 구축하는 것</u> "으로 설명되었다.<br/>
여기에서 `역할과 책임을 수행하는 객체`라는 존재가 바로 객체 지향 패러다임의 <u>추상화</u>이며<br/>
`기능을 협력하는 공동체로 구성`하기 위해 객체들로 나누는 과정이 객체 지향 패러다임의 <u>분해</u>인 것이다.

<br/>

## "프로시저" 추상황 && "기능" 분해

우선 전통적인 분해 방법은 바로 **기능 분해** 방식이다.<br/>
기능 분해의 관점에서 <u>추상화의 단위</u>는 **프로시저**로<br/>
시스템은 프로시저 단위로 분해된다.

더불어 <u>**하향식 접근법**</u>(**Top-Down Approach**)으로 분해 작업이 수행되는데<br/>
시스템을 구성하는 **가장 최상위 기능**을 정의한 후에<br/>
이 최상위 기능을 <u>좀 더 작은 단계의 하위 기능으로 분해해 나가는</u> 방법이다.

분해는 <u>세분화된 마지막 하위 기능</u>이 **프로그래밍 언어로 구현 가능한 수준이 될 때까지** 반복된다.<br/>
( _각 세분화 단계는 바로 위 단계보다 더 구체적이어야 함_ )

<br/>

앞서 설명했듯이<br/>
최상위의 추상적인 함수 정의에서부터 출발한다.<br/>
이는 시스템의 기능을 표현하는 **하나의 문장으로** 나타내는 것이다.

이후, 단계적인 정제 절차를 따라 시스템을 구축하는데<br/>
세부적인 단계의 문장으로 분해해나간다.

즉, <u>하나의 문장으로 표현된 기능을 여러 개의 더 작은 기능으로 분해</u>하는 작업이다.

기능 분해 방법에서는
<u>**기능을 중심**으로 필요한 데이터를 결정</u>한다.<br/>
기능 분해를 위한 하향식 접근법은 **우선적으로** <u>필요한 기능에 대해 생각</u>하고<br/>
이 기능을 <u>분해하고 정제하는 과정</u>에서 **필요한 데이터의 종류와 저장 방식**을 **식별**한다.

> #### ⁜ 하향식 기능 분해 문제점
> 최상위의 가장 추상적인 메인 함수 정의를 시작으로 <br/>
> 구현 가능한 수준의 세부적인 단계까지 분해해나가는 구조는 "트리구조"이다.
> 
> 메인 함수는 이 기능 분해 트리의 루트(root)이며<br/>
> 분해되는 단계에 따라 분리된 하나의 프로시저는 노드(node)인 것이다.
> 
> 분명 구조적이고 체계적인 방법이지만<br/>
> 불규칙하고 불완전한 어쩌면 가장 복잡한 분야라고 할 수 있는 소프트웨어 개발에서는<br/>
> 되려 혼란과 동요를 발생시키는 것이다.
> > - <u>하나</u>의 메인 함수로 **정의 및 구성 불가**
> > - **빈번한 수정 및 재설계** 발생
> > - <u>비즈니스 로직</u>과 <u>사용자 인터페이스</u>의 **강한 결합**
> > - <u>너무 이른 시기</u>에 결정된 **실행 순서 고정**
> >   - 변경에 취약
> >   - 유연성과 재사용성 저하
> > - <u>데이터 형식 변경</u>에 대한 **파급효과 예측 불가능**

<br/>

하향식 분해가 유용한 경우는<br/>
<u>**작은 프로그램**과 **개별 알고리즘**을 취급</u>하는 경우다.<br/>
특히 <u>**이미** 해결된 알고리즘을 정리하고 서술</u>하는 데에 훌륭한 기법이다.

다시 말해, <u>새로운 것을 개발하고, 설계하고, 발격하는 데 적합한 기법이 아닌</u><br/>
**이미 해결되었고 증명된 것**에 대하여 **서술할 때** 적합한 기법이다. 

하지만 <u>하나의 함수에 제어가 집중</u>되어 있기에<br/>
데이터에 대한 **영향도를 파악하기도 어렵고** **재사용하기 어렵다**는 단점과 더불어<br/>
동작하는 커다란 소프트웨어 설계에는 적절치 않은 기법인 것이다.

<br/>
<br/>

