# Chapter 7. 객체 분해
> - **인지 부조화**(**Cognitive Overload**)
>   - 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 <br/>
>   문제 해결 능력이 급격히 떨어지는 현상 
> - **추상화**(**Abstract**)
>   - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
> - **분해**(**Decomposition**)
>   - 큰 문제를 해결 가능한 작은 문제로 나누는 작업

한 번에 단기 기억에 담을 수 있는 추상화의 수에는 한계가 있지만<br/>
추상화를 더 큰 규모의 추상화로 압축시킴으로써 단기 기억의 한계를 초월할 수있다.<br/>
그에 따라 추상화와 분해는 <br/>
인간이 인식하고 반응하기 위해 사용하는 가장 기본적인 사고 도구인 셈이다.

복잡성이 존재하는 곳에 추상화와 분해 역시 함께 존재하며<br/>
어쩌면 가장 복잡한 분야라고 할 수 있는 소프트웨어 개발 영역의 문제를 해결하기 위해 사용해왔다.

---
## "프로시저" 추상화 && "데이터" 추상화

현대적인 프로그래밍 언어를 특정 짓는 중요한 두 가지 추상화 매커니즘은<br/>
"**프로시저 추상화**"와 "**데이터 추상화**"이다.

- **프로시저 추상화**(**Procedure** Abstraction) : 소프트웨어가 무엇을 <u>해야하는지</u> 추상화
- **데이터 추상화**(**Data** Abstraction) : 소프트웨어가 무엇을 <u>알아야 하는지</u> 추상화

시스템을 분해하는 방법을 결정하기 위해서는<br/>
선행적으로 앞서 언급한 추상화 방향을 결정해야 한다.
- <u>**프로시저 추상화**</u> <br/>→ **기능 분해**(`Functional Decomposition`) == **알고리즘 분해**(`Algorithm Decomposition`)<br/>


- <u>**데이터 추상화**</u> <br/>→ **타입 추상화**(`Type Abstraction`) : **추상 데이터 타입**`Abstract Data Type` 
<br/>→ **데이터 중심** 프로시저 추상화 : **객체지향**(`Object-Oriented`)

지금까지의 **객체지향 패러다임**은 " <u>역할과 책임을 수행하는 자율적인 객체들의 협력 공동체를 구축하는 것</u> "으로 설명되었다.<br/>
여기에서 `역할과 책임을 수행하는 객체`라는 존재가 바로 객체 지향 패러다임의 <u>추상화</u>이며<br/>
`기능을 협력하는 공동체로 구성`하기 위해 객체들로 나누는 과정이 객체 지향 패러다임의 <u>분해</u>인 것이다.

<br/>

## "프로시저" 추상황 && "기능" 분해

우선 전통적인 분해 방법은 바로 **기능 분해** 방식이다.<br/>
기능 분해의 관점에서 <u>추상화의 단위</u>는 **프로시저**로<br/>
시스템은 프로시저 단위로 분해된다.

더불어 <u>**하향식 접근법**</u>(**Top-Down Approach**)으로 분해 작업이 수행되는데<br/>
시스템을 구성하는 **가장 최상위 기능**을 정의한 후에<br/>
이 최상위 기능을 <u>좀 더 작은 단계의 하위 기능으로 분해해 나가는</u> 방법이다.

분해는 <u>세분화된 마지막 하위 기능</u>이 **프로그래밍 언어로 구현 가능한 수준이 될 때까지** 반복된다.<br/>
( _각 세분화 단계는 바로 위 단계보다 더 구체적이어야 함_ )

<br/>

앞서 설명했듯이<br/>
최상위의 추상적인 함수 정의에서부터 출발한다.<br/>
이는 시스템의 기능을 표현하는 **하나의 문장으로** 나타내는 것이다.

이후, 단계적인 정제 절차를 따라 시스템을 구축하는데<br/>
세부적인 단계의 문장으로 분해해나간다.

즉, <u>하나의 문장으로 표현된 기능을 여러 개의 더 작은 기능으로 분해</u>하는 작업이다.

기능 분해 방법에서는
<u>**기능을 중심**으로 필요한 데이터를 결정</u>한다.<br/>
기능 분해를 위한 하향식 접근법은 **우선적으로** <u>필요한 기능에 대해 생각</u>하고<br/>
이 기능을 <u>분해하고 정제하는 과정</u>에서 **필요한 데이터의 종류와 저장 방식**을 **식별**한다.

> #### ⁜ 하향식 기능 분해 문제점
> 최상위의 가장 추상적인 메인 함수 정의를 시작으로 <br/>
> 구현 가능한 수준의 세부적인 단계까지 분해해나가는 구조는 "트리구조"이다.
> 
> 메인 함수는 이 기능 분해 트리의 루트(root)이며<br/>
> 분해되는 단계에 따라 분리된 하나의 프로시저는 노드(node)인 것이다.
> 
> 분명 구조적이고 체계적인 방법이지만<br/>
> 불규칙하고 불완전한 어쩌면 가장 복잡한 분야라고 할 수 있는 소프트웨어 개발에서는<br/>
> 되려 혼란과 동요를 발생시키는 것이다.
> > - <u>하나</u>의 메인 함수로 **정의 및 구성 불가**
> > - **빈번한 수정 및 재설계** 발생
> > - <u>비즈니스 로직</u>과 <u>사용자 인터페이스</u>의 **강한 결합**
> > - <u>너무 이른 시기</u>에 결정된 **실행 순서 고정**
> >   - 변경에 취약
> >   - 유연성과 재사용성 저하
> > - <u>데이터 형식 변경</u>에 대한 **파급효과 예측 불가능**

<br/>

하향식 분해가 유용한 경우는<br/>
<u>**작은 프로그램**과 **개별 알고리즘**을 취급</u>하는 경우다.<br/>
특히 <u>**이미** 해결된 알고리즘을 정리하고 서술</u>하는 데에 훌륭한 기법이다.

다시 말해, <u>새로운 것을 개발하고, 설계하고, 발격하는 데 적합한 기법이 아닌</u><br/>
**이미 해결되었고 증명된 것**에 대하여 **서술할 때** 적합한 기법이다. 
입
하지만 <u>하나의 함수에 제어가 집중</u>되어 있기에<br/>
데이터에 대한 **영향도를 파악하기도 어렵고** **재사용하기 어렵다**는 단점과 더불어<br/>
동작하는 커다란 소프트웨어 설계에는 적절치 않은 기법인 것이다.

<br/>
<br/>

---
## 모듈
시스템의 변경을 관리하는 기본적인 전략은<br/>
**함께 변경되는 부분**을 <u>하나의 구현 단위로 묶고</u> <u>**퍼블릭 인터페이스**를 통해서만 접근</u>하도록 만드는 것이다.<br/>
즉, 기능을 기반으로 시스템을 분해하는 것이 아니라 <u>**변경의 방향**에 맞춰 분해</u>하는 것이다.

해당 전략의 핵심이 바로 "**정보 은닉**(**Information Hiding**)"이다.<br/>
정보 은닉은 <u>시스템을 모듈 단위로 분해하기 위한 기본 원리</u>로<br/>
시스템에서 **자주 변경되는 부분**을 상대적으로 <u>덜 변경되는 안정적인 인터페이스 **뒤**</u>로 **감춰야 한다**는 것에 초점이 맞춰져 있다.

그에 따라
시스템을 모듈로 분해한 후에는
각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.

**기능 분해**가 하나의 기능을 구현하기 위해 <u>필요한 기능들을 순차적으로 찾아가는</u> "**탐색**"의 과정이라면<br/>
**모듈 분해**는 감춰야 할 비밀을 선택하고 <u>비밀 주변에 보호막을 설치하는</u> "**보존**"의 과정이라고 볼 수 있다.<br/>
( `비밀 결정` → `모듈 분해` → `기능 분해` → `퍼블릭 인터페이스 구현`)

<br/>

> #### ⁜ 모듈이 숨길 비밀
>
> 1. **복잡성**<br/>
>    : 너무 복잡할 경우 이해하고 사용하기 어려우므로<br/>외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 통해 복잡도를 낮춘다.
>
> 
> 2. **변경 가능성**<br/>
>    : 변경 가능한 설계 결정이 노출될 경우, 변경 발생 시의 파급효과가 커진다.<br/>외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.
> 
> _* **데이터 캡슐화**(**Data Encapsulation**)와 **정보 은닉**은 엄연히 다르다.<br/>
> 정보 은닉에서는 지켜져야할 비밀이 **반드시 데이터일 필요는 없으며** <u>로직이나 자료 구조</u>일 수 있다.<br/>
> 일반적으로 시스템의 비밀은 데이터이다 보니 해당 관점에서 혼동이 되기 쉽다._

<br/>

### 장점과 한계

#### ⁜ 장점
1. 모듈 <u>내부 변수가 변경되더라도</u> **모듈 내부에만** 영향 <br/>
    - 모듈 내부 정의 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한 가능
    - 데이터 변경에 대해 영향을 받는 함수는 해당 데이터를 정의한 모듈만 검색하면 된다.
    - 데이터 변경으로 인한 파급효과 제어 가능 → 코드 수정 및 디버깅 용이<br/><br/>
2. 비즈니스 로직과 사용자 인터페이스에 대한 <u>**관심사 분리**</u>
    - 사용자 입력과 화면 출력 같은 사용자 인터페이스를 담당하는 모듈과 비즈니스 로직을 담당하는 모듈을 분리함으로서<br/>**각자의 관심사에 대해서만 담당**하도록 설계할 수 있고<br/>그에 따라 <u>사용자 인터페이스의 변경이 잦더라도</u> **비즈니스 로직은 변경할 필요가 없게** 된다.<br/><br/>
3. <u>**전역 변수**와 **전역 함수**를 제거함</u>으로써 "**네임 스페이스 오염**(**namespace pollution**)" 방지
    - <u>변수와 함수를 모듈 내부</u>에 포함 → 타 모듈에서도 **동일한 이름 사용 가능**
    - 네임스페이스 오염을 방지하는 동시에 **이름 충돌**(**Name Collision**)의 위험을 **완화**한다.<br/><br/>

모듈은 기능이 아닌 **변경에 정도**에 따라 시스템을 분해하게 하고<br/>
각 모듈은 <u>외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합</u>이기 때문에<br/>
모듈 내부는 **높은 응집도**를 유지하고<br/>
모듈과 모듈 사이에는 <u>퍼블릭 인터페이스를 통해서만 통신함</u>으로서 **낮은 결합도**를 유지한다.

하향식 기능 분해와는 달리<br/>
모듈은 감춰야 할 데이터를 결정하고 이 데이터를 조작하는데 필요한 함수를 결정한다.

즉, 기능이 아닌 데이터를 중심으로 시스템을 분해하였기에<br/>
모듈을 "<u>데이터와 함수가 통합된</u> 한 차원 높은 **추상화 설계**"의 한 단위로서 활용할 수 있다.

<br/>

#### ⁜ 한계
비록 모듈이 프로시저 추상화보다는 높은 추상화 개념을 제공하지만<br/>
애초에 **변경을 관리하기 위한 구현 기법**으로서 만들어진 기법이기 때문에 <u>추상화 관점에서의 한계점</u>이 명확하다.

- " _**인스턴스의 개념을 제공하지 않는다**._ "

만약 **좀 더 높은 수준의 추상화**를 실현하기 위해선 <u>개별 인스턴스를 독립적으로 다룰 수 있어야</u> 한다.<br/>
이 때 필요한 개념이 바로 **추상 데이터 타입(Abstract Data Type)** 이다.

<br/>

## 데이터 추상화 && 추상 데이터 타입
프로그래밍 언어에서의 **타입(Type)** 이란<br/>
<u>변수에 저장할 수 있는 **내용물의 종류**와 변수에 적용될 수 있는 **연산의 가짓수**</u>를 의미한다.

예를 들어 변수명을 참조할 때, 해당 변수를 임의의 정숫값으로 간주하라고 지정하기 위해<br/>
정수 타입을 같이 선언하는 것처럼 말이다.

타입은 <u>저장된 값에 대해 **수행 가능한 연산의 집합**을 결정</u>하기 때문에<br/>
해당 변수의 **값이 어떻게 행동할 것인지 예측**할 수 있게 된다.

전통적인 방법인 기능 분해에서 사용되던 절차형 언어들은 적은 수의 내장 타입만이 제공되었기 때문에<br/>
새로운 타입을 추가하는 것이 불가능하거나 제한적이었고<br/>
프로그램에서 사용하는 주된 추상화는 **프로시저 추상화**였다.

프로시저 추상화로는 표현력을 향상시키는 데 한계가 있었고<br/>
그에 따라 **데이터 추상화(Data Abstraction)** 의 개념이 출현하게 된다.

>추상 데이터 타입은 **추상 객체의 클래스를 정의**한 것으로<br/>
>추상 객체에 **사용할 수 있는 오퍼레이션**을 이용해 규정되는 것이고<br/>
>바꿔 말하면 <u>오퍼레이션을 이용해 추상 데이터 타입을 정의</u>할 수 있음을 의미한다.
>
>또한 해당 추상 데이터 객체를 사용할 때,<br/>
>프로그래머는 **오직 외부에 제공하는 행위(퍼블릭 인터페이스)에만 관심** 가지며 <br/>
><u>구현되는 세부 사항에 대해서는 무시</u>한다.<br/>
>즉, 객체의 사용자는 정보를 알거나 제공받을 필요가 없이<br/>
>객체가 저장소 내에서 어떻게 표현되는지와 같은 **구현 정보**는 <u>오직 오퍼레이션을 어떻게 구현할 것인지에 집중할 때</u> 필요한 것이다.

위 개념을 통해<br/>
소프트웨어를 이용하여 표현할 수 있는 추상화의 수준을 한 단계 높일 수 있다.

추상 데이터 타입 구현을 위한 프로그래밍 언어의 전제 조건은 다음과 같다.
- <u>**타입 정의 선언**</u>이 가능하다.
- <u>타입의 인스턴스를 다루기 위해 사용할 수 있는 **오퍼레이션 집합의 선언**</u>이 가능하다.
- 제공된 오퍼레이션을 통해서만 조작할 수 있도록 <u>외부로부터의 **데이터 보호**</u>가 가능하다.
- <u>타입에 대한 **여러 개의 인스턴스** 생성</u>이 가능하다.

<br/>

추상 데이터 타입은 실제 세상을 바라보는 방식에 좀 더 근접해지도록 추상화 수준을 향상시키기에<br/>
<u>각 행위자에 대한 객체 인스턴스를 생성</u>하는 추상 데이터 타입은<br/>
전체에 대한 모듈보다는 좀 더 개념적으로 **인간의 사고방식과 유사하게 표현**할 수 있다.

단, 추상 데이터 타입 정의를 기반으로 객체를 생성하는 것은 가능하나<br/>
**데이터와 기능을 분리해서 바라본다는 점**에 주의해야 한다.<br/>

말 그대로 추상 데이터 타입은 " <u>시스템의 상태를 저장할 때 데이터를 표현하는 것</u> "이기 때문에<br/>
해당 **추상 데이터 타입으로 표현된 데이터**를 이용해서 <u>기능을 구현하는 핵심 로직</u>은<br/>
추상 데이터 타입 **외부**에 존재한다.


## 클래스
사실 앞서 살펴본 추상 데이터 타입과 클래스는<br/>
둘 다 데이터 추상화를 기반으로 시스템을 분해하기 때문에 "클래스는 추상 데이터 타입"이라는 말이 꼭 틀린 것만은 아니다.

하지만 명확하게 따져보자면 엄연히 다르다고 볼 수 있다.<br/>
가장 큰 핵심적인 차이는<br/>
클래스의 **상속**과 **다형성**이다.

이에 대해<br/>
<u>상속과 다형성을 지원</u>하는 "**객체지향 프로그래밍(Object-Oriented Programming)**"과<br/>
지원하지 않는 추상 데이터 타입 기반의 프로그래밍 패러다임인 "**객체기반 프로그래밍(Object-Based Programming)**"으로 구분하기도 한다.

또 다른 관점에서 차이를 구분하자면<br/>
**추상 데이터 타입**은 "<u>**타입**을 추상화</u>한 것"이고<br/>
**클래스**는 "<u>**절차**를 추상화</u>한 것"으로 구분할 수 있다.

> _예를 들어,<br/>
> <u>정규 직원</u>과 <u>비정규 직원</u>으로 두 개별적인 개념을 포괄하는 **직원**(`Employee`) 타입이 있고<br/>
> 해당 타입의 **퍼블릭 인터페이스**로서 <u>두 오퍼레이션 `calculatePay()`와 `monthlyBasePay()`</u>이 있다고 가정하자._
> 
> _이 때,
> `Employee` 는 하나의 타입처럼 보이지만 **정규 직원과 비정규 직원 두가지 타입이 공존**하는 것이고<br/>
> 오퍼레이션도 각 세부 타입에 따라 **세부 구현 로직은 달라지는데**<br/>
> 이를 캡슐화하여 <u>구체적인 직원 타입을 외부로부터 숨긴 것</u>이다._
> 
> _이처럼 <u>하나의 대표 타입이 **다수의 세부적 타입으로 감추는 것**</u>을 "**타입 추상화**"라 불렀고<br/>
> 이에 따라 개별 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄하도록 함으로써<br/>
> 하나의 통합 타입 안에 전체 타입을 감출 수 있게 된 것이다._
> 
> _위와 같이 <u>오퍼레이션을 기준으로 타입을 통합</u>하는 데이터 추상화 기법이 "**타입 추상화**"이며<br/>
> 타입 추상화를 기반으로 하는 대표적인 기법이 추상 데이터 타입인 것이다._

위 예시가 <u>**오퍼레이션**을 기준</u>으로 **타입을 묶는** 추상 데이터 타입이라면<br/>
객체지향은 <u>**타입**을 기준</u>으로 **오퍼레이션을 묶는다**.

동일한 예시로 다뤄보자면<br/>
정규 직원과 비정규 직원이라는 두 가지 클래스로 분리할 경우,<br/>
공통 로직을 어디에 둘 것인지가 관건일 것이다.

이 때, 가장 간단한 방법은<br/>
공통 로직을 포함할 **부모 클래스**를 정의하여<br/>
두 클래스 모두 부모 클래스를 상속받게 하여 구현하는 것이다.

더불어 "직원"이라는 대상에 대한 메시지가 전달되었을 때<br/>
부모 클래스의 참조자에 대해 메시지를 전송하면<br/>
**동일한 메시지이더라도** <u>실제 클래스가 무엇인지에 따라</u> 적절한 절차가 실행된다.

<u>**클라이언트 관점에선 두 클래스의 인스턴스를 통일하게 본다는 점**</u>이 핵심이다.<br/>
이처럼 <u>실제 내부에서 수행되는 절차는 다르더라도</u><br/>
다형성을 통해 **각 절차간의 차이를 숨길 수 있게 된다**.

이것이 **객체 지향**이며 "**절차 추상화**(**Procedural Abstraction**)"의 모습이다.

### 변경을 기준으로 선택하기
단순히 **클래스를 구현 단위로** 사용한다 해서 <u>객체 지향 프로그래밍을 한다는 의미가 아니다</u>.<br/>
**타입을 기준**으로 **절차를 추상화**하지 않았다면 객체 지향이 아닌 것이다.

클래스가 추상 데이터 타입의 개념을 따르는지 확인하는 가장 간단한 증거는<br/>
<u>클래스 내부 **인스턴스 타입을 표현하는 변수**의 존재 유무</u>이다.

객체 지향에서는 <u>타입 변수를 이용한 조건문</u>을 " **다형성** "으로 대체한다.<br/>
그에 따라 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라<br/>
" <u>**객체가** 메시지를 처리할 적절한 메서드를 선택하는 것</u> "이 객체 지향인 것이다.

얼핏보면 똑같은 말인듯하나 중요한 것은 <u>누가 메서드를 선택하느냐</u>이다.<br/>
다시 말해, <br/>
인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 <u>타입을 **명시적**으로 구분하는 방식</u>은 **객체 지향을 위반**하는 것이다.

<br/>

이렇게 명시적으로 타입을 구분해서 조건문을 사용하는 방식을 기피하는 이유는 "변경" 때문이다.<br/>
객체 지향을 기반으로 할 경우,<br/>
부모 클래스를 상속 받아 필요한 메서드를 오버라이딩하기만 하면<br/> 
새로운 로직 추가를 위한 클라이언트 코드 수정 없이도 새로운 타입을 구현하는 클래스를 추가할 수 있다.

이와 같이 <u>기존 코드에 아무런 영향도 미치지 않고 **새로운 객체 유형과 행위를 추가**할 수 있는 객체 지향의 특성</u>을<br/>
" **개방-폐쇄 원칙**(`Open-Closed Principle` : `OCP`) "이라고 한다.<br/>
해당 원칙 덕분에 객체 지향 설계가 전통적인 방식보다 **변경 및 확장이 쉬운 구조로 설계**할 수 있는 이유다.

<br/>

하지만 항상 절차를 추상화하는 객체 지향 설계 방식이 옳다는 것은 아니다.<br/>
" <u>설계에 요구되는 **변경의 압력**이 어떤 것이냐</u> "에 따라 달라진다.

"<u>**타입** 추가</u>"라는 변경의 압력이 더 클 경우,<br/>
<u>**객체 지향 설계**</u>가 유리하다.<br/>
추상 데이터 타입의 경우, 새로운 타입 추가를 위해선 타입을 체크하는 클라이언트 코드를 일일이 찾아 수정해야 하지만<br/>
**객체 지향**의 경우, <u>클라이언트 코드를 수정할 필요 없이</u> **새로운 클래스**를 **상속 계층에 추가**하기만 하면 된다.

반면, "<u>**오퍼레이션** 추가</u>"일 경우,<br/>
**추상 데이터 타입**. 즉, <u>**객체 기반 설계**</u>가 유리하다.<br/>
객체 지향의 경우, 새로운 오퍼레이션 추가를 위해선 상속 계층에 속하는 모든 클래스를 한 번에 수정해야 하지만<br/>
**추상 데이터 타입**의 경우, <u>전체 타입에 대한 구현 코드가 **하나의 구현체 내에 포함**</u>돼 있기 때문에 새로운 오퍼레이션 추가는 상대적으로 **간단**하다.

<br/>

> #### ⁜ 결국 "협력"이 중요한 것
> 객체 지향에서 중요한 것은 `역할`, `책임`, `협력` 이다.<br/>
> 그에 따라 객체 지향은 " <u>**기능을 수행하기 위해 객체들이 협력하는 방식에 집중하는 것**</u> "이다.
> 
> 협력이라는 문맥을 고려하지 않고 <u>객체를 **고립**시킨 채 오퍼레이션의 구현 방식을 **타입 별로 분배**하는 것이 아닌</u><br/>
> **책임 주도 설계**의 흐름을 따라 객체를 설계한다.
> 
> 다시 말해,
> >객체가 <u>참여할 **협력**을 **결정**</u>하고 협력에 필요한 <u>책임을 수행하기 위해 **어떤 객체가 필요**한지</u>에 관해 고민하고<br/>
> >그 <u>책임을 다양한 방식으로 수행해야 할 때만</u> **타입 계층 안에 각 절차를 추상화**해야 한다.
> >
> >그에 따라 [타입 계층]과 [다형성]은<br/>
> >협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며<br/>
> >이들 자체가 목적이 되어서는 안된다.
