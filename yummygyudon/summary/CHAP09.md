# Chapter 9. 유연한 설계

## 개방-폐쇄 원칙 ( `Open-Closed Principle : OCP` )
확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙으로<br/>
SOLID 원칙 중 하나이다.

> 소프트 웨어 개체( Class, Module, Method, ...)는 확장에 대해 열려 있어야 하고,<br/>
> 수정에 대해서는 닫혀있어야 한다.
 
- "**확장**"에 대해 열려 있다.
  - 애플리케이션 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 기능을 확장할 수 있다.
- "**수정**"에 대해 닫혀 있다.
  - 기존의 코드를 수정하지 않고도 동적을 추가하거나 변경할 수 있다.

### "컴파일 타임 의존성"을 고정시키자
사실 OCP는 런타임 의존성과 컴파일 타임 의존성에 관한 원칙이다.

앞 단원에서 살펴봤던 내용이지만<br/>
**런타임 의존성**은 <u>실행 시에 협력에 참여하는 객체들 사이의 관계</u>이고<br/>
**컴파일 타임 의존성**은 <u>코드에서 드러나는 클래스들 사이의 관계</u>이며<br/>
**유연하고 재사용 가능한 설계**는 <u>두 의존성은 서로 다른 구조</u>를 가져야 한다.

예시로 사용했던 할인 정책의 경우도<br/>
각 정책 클래스의 코드는 전혀 손대지 않고도 새로운 정책 클래스를 추가하여 동작을 확장할 수 있었다.

이러한 설계가 개방-폐쇄의 원칙을 적용한 설계라고 볼 수 있다.

즉, 개방-폐쇄의 원칙을 수용하는 코드는<br/>
**컴파일 타임 의존성**을 <u>수정하지 않고 유지</u>하면서<br/>
**런타임 의존성**을 <u>쉽게 변경하고 확장</u>할 수 있게된다.

### 역시 "추상화"가 핵심
OCP의 핵심은 "<u>**추상화**에 의존하는 것</u>"이다.

추상화는 **핵심 부분만 남기고** <u>불필요한 부분을 생략하여 복잡성을 극복</u>하는데<br/>
이에 따라 추상화 과정을 거치게 되면<br/>
**문맥이 바뀌더라도 변하지 않는 부분만** 남게 되고 <u>문맥에 따라 변하는 부분은 생략</u>된다.

즉, 추상화를 사용하면<br/>
생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써<br/>
**각 문맥에 적합하게 기능을 구체화하고 확장**할 수 있게되는 것이다.

개방-폐쇄 원칙의 관점에서<br/>
추상화 과정에서 보이는 생략되지 않고 남겨지는 핵심 부분은<br/>
다양한 상황에서의 공통점을 반영한 추상화의 결과물이라 볼 수 있다.

**공통적인 부분**은 <u>문맥이 바뀌더라도 **변하지 않아야** 하고</u><br/>
더불어 <u>**수정할 필요도 없어야**</u> 한다.

그에 따라 추상화 부분은 <u>수정에 대해 닫혀있고</u><br/>
<u>생략된 부분</u>은 **확장의 여지**로서 남겨놓는다.<br/>
해당 특징이 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유이다.

단, 추상화를 했다고 해서 <u>_모든 수정에 대한 설계가 폐쇄되는 것은 아니다_</u>.

변경에 의한 파급효과를 최대한 피하기 위해서는<br/>
<u>**변하는 것과 변하지 않는 것**이 무엇인지를 정확히 이해</u>하고<br/>
이를 **추상화의 목적**으로 삼아야 한다.