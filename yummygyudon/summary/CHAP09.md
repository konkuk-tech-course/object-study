# Chapter 9. 유연한 설계

## 개방-폐쇄 원칙 ( `Open-Closed Principle : OCP` )
확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙으로<br/>
SOLID 원칙 중 하나이다.

> 소프트 웨어 개체( Class, Module, Method, ...)는 확장에 대해 열려 있어야 하고,<br/>
> 수정에 대해서는 닫혀있어야 한다.
 
- "**확장**"에 대해 열려 있다.
  - 애플리케이션 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 기능을 확장할 수 있다.
- "**수정**"에 대해 닫혀 있다.
  - 기존의 코드를 수정하지 않고도 동적을 추가하거나 변경할 수 있다.

### "컴파일 타임 의존성"을 고정시키자
사실 OCP는 런타임 의존성과 컴파일 타임 의존성에 관한 원칙이다.

앞 단원에서 살펴봤던 내용이지만<br/>
**런타임 의존성**은 <u>실행 시에 협력에 참여하는 객체들 사이의 관계</u>이고<br/>
**컴파일 타임 의존성**은 <u>코드에서 드러나는 클래스들 사이의 관계</u>이며<br/>
**유연하고 재사용 가능한 설계**는 <u>두 의존성은 서로 다른 구조</u>를 가져야 한다.

예시로 사용했던 할인 정책의 경우도<br/>
각 정책 클래스의 코드는 전혀 손대지 않고도 새로운 정책 클래스를 추가하여 동작을 확장할 수 있었다.

이러한 설계가 개방-폐쇄의 원칙을 적용한 설계라고 볼 수 있다.

즉, 개방-폐쇄의 원칙을 수용하는 코드는<br/>
**컴파일 타임 의존성**을 <u>수정하지 않고 유지</u>하면서<br/>
**런타임 의존성**을 <u>쉽게 변경하고 확장</u>할 수 있게된다.

<br/>

### 역시 "추상화"가 핵심
OCP의 핵심은 "<u>**추상화**에 의존하는 것</u>"이다.

추상화는 **핵심 부분만 남기고** <u>불필요한 부분을 생략하여 복잡성을 극복</u>하는데<br/>
이에 따라 추상화 과정을 거치게 되면<br/>
**문맥이 바뀌더라도 변하지 않는 부분만** 남게 되고 <u>문맥에 따라 변하는 부분은 생략</u>된다.

즉, 추상화를 사용하면<br/>
생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써<br/>
**각 문맥에 적합하게 기능을 구체화하고 확장**할 수 있게되는 것이다.

개방-폐쇄 원칙의 관점에서<br/>
추상화 과정에서 보이는 생략되지 않고 남겨지는 핵심 부분은<br/>
다양한 상황에서의 공통점을 반영한 추상화의 결과물이라 볼 수 있다.

**공통적인 부분**은 <u>문맥이 바뀌더라도 **변하지 않아야** 하고</u><br/>
더불어 <u>**수정할 필요도 없어야**</u> 한다.

그에 따라 추상화 부분은 <u>수정에 대해 닫혀있고</u><br/>
<u>생략된 부분</u>은 **확장의 여지**로서 남겨놓는다.<br/>
해당 특징이 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유이다.

단, 추상화를 했다고 해서 <u>_모든 수정에 대한 설계가 폐쇄되는 것은 아니다_</u>.

변경에 의한 파급효과를 최대한 피하기 위해서는<br/>
<u>**변하는 것과 변하지 않는 것**이 무엇인지를 정확히 이해</u>하고<br/>
이를 **추상화의 목적**으로 삼아야 한다.

<br/>
<br/>

---

## 생성 사용 분리
클라이언트가 <u>알아야 하는 지식이 많을 수록</u> **결합도**가 높아지고<br/>
결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다.

<u>객체의 타입</u>과 <u>생성자에 전달해야 하는 인자</u>에 대한 **과도한 지식**은<br/>
<u>특정 컨텍스트에 **강한 결합**</u>을 야기하기 때문에<br/>
컨텍스트 교체를 위해서는 코드 안에 명시되어 있는 **컨텍스트를 직접 수정하는 방법뿐**이다.

그렇다고 객체 생성을 피할 수 있는 것은 아니다.<br/>
어디에선간 반드시 객체를 생성해야 한다.<br/>
즉, <u>**적절한 곳**에서 객체를 **생성**하는 것</u>이 가장 중요한 부분인 것이다.

물론 <u>메시지를 전송하지 않고</u> 객체 **생성만** 했거나<br/>
<u>객체를 생성하지 않고 **메시지만 전송**</u>했다면 아무런 문제가 발생하지 않을 것이다.<br/>
문제는 " <u>_**동일 클래스 내에서** 객체 생성과 사용이라는 두 이질적인 목적의 코드가 **공존**하는 것_</u> "이다.

유연하고 재사용 가능한 설계는<br/>
객체와 관련된 **두 가지 책임을 <u>서로 다른 객체로 분리</u>하여 독립적으로 사용**하는 것이고<br/>
이를 " **생성과 사용을 분리**(`Separating Use from Creation`) "한다고 한다.

<br/>

생성과 사용을 분리하는 데 사용되는 가장 보편적인 방법은<br/>
<u>객체 **생성**에 대한 책임</u>을 **클라이언트**로 옮기는 것이다.<br/>
즉, 클라이언트가 **적절한 인스턴스를 생성한 후**에 <u>해당 클래스와 협력하는 클래스에게 전달</u>하는 것이다.

이를 통해 현재의 **컨텍스트에 관한 결정권을 가지고 있는 클라이언트**로 컨텍스트에 대한 <u>지식을 옮김</u>으로써<br/>
특정한 클라이언트에 <u>결합되지 않고 **독립적**</u>일 수 있게 된다.

### FACTORY 추가
위에서 생성 책임을 클라이언트로 옮길 수 있었던 이유는 <br/>
클라이언트는 특정 컨텍스트에 묶이더라도 큰 상관이 없지만<br/>
다른 책임을 가진 클래스에서 특정 컨텍스트에 묶이면 안된다는 전제가 있기 때문이다.

만약 클라이언트 또한 공평하게 바라본다면<br/>
오히려 클라이언트에게 생성과 사용의 책임을 함께 지니게 된 것이다.<br/>
하지만 이 또한 동일한 방법으로 해결할 수 있다.

더 폭넓게 **클라이언트의 인스턴스**(이하 `Client`)**를 사용할 문맥을 결정**할 <br/>
<u>또 다른 클라이언트</u>로 **협력 객체 생성 책임**을 **옮기는 것**이다.<br/>
_단, **생성과 관련된 지식**은 <u>`Client`와 협력하는 클라이언트에게까지 노출되지 않도록</u> 하는 것을 조건으로 한다._

이를 위해 **객체 생성과 관련된 책임만 전담**하는 별도 객체를 추가해서<br/>
`Client`가 해당 객체를 사용하도록 할 수 있다.<br/>
(이처럼 <u>생성과 사용을 분리하기 위해 "**객체 생성**"에 특화된 객체</u>를 `FACTORY`라고 한다.)

```java
public class Factory {
    public Movie createMovie() {
        return new Movie("아바타",
                Duration.ofMinutes(120),
                Money.wons(10_000),
                new AmountDiscountPolicy());
    }
}

public class Client {
    private Factory factory;
    
    public Client(Factory factory){
        this.factory = factory;
    }
    public Money getAvatarFee(){
        Movie avatar = factory.createAvatarMovie();
        return avatar.getFee();
    }
}
```

### 순수 가공물에 책임 할당
책임 할당의 가장 기본이 되는 원칙은 
책임을 수행하는 데에 있어 필요한 정보를 가장 많이 알고 있는 정보 전문가(`INFORMATION EXPERT`)에게 책임을 할당하는 것이다.

그에 따라 우선적으로 도메인 모델 안의 개념 중에서 적절한 후보가 존재하는지 찾아봐야한다.
하지만 만약 도메인 모델 중에서 마땅한 후보가 없다면 꽤나 난감해진다.

이 때, 직전에 알아본 `FACTORY`와 같이
전체적인 결합도를 낮추고 재사용성을 높이기 위해
도메인 개념과는 아무 상관 없는 
설계자의 편의를 위해 임의로 만들어낸 순수 가공을 위한 객체를 사용하는 방법이 있다.
( 이러한 책임 할당을 위해 창조되는 도메인과 무관한 인공적인 객체를 `PURE FABRICATION : 순수한 가공물`이라 칭한다.)

> #### 표현적 분해 ( Representational Decomposition )
>  : 도메인 안에 존재하는 사물 또는 개념을 표현하는 객체들을 이용하여 시스템을 분해하는 것
> - 객체 지향 설계를 위한 가장 기본적인 접근법
> - 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 목적
> 
> #### 행위적 분해 ( Behavioral Decomposition )
>  : 도메인 개념 중심이 특정한 책임에 대한 행동을 기준으로 시스템을 분해하는 것
> - 모든 책임을 도메인 객체에게 할당할 경우에 <br/>낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제점이 발생하게 될 때<br/> 책임을 분산시키기 위해 주로 사용되는 방법
> 
> _- 크레이그 라만 -_

즉, <u>어떤 행동을 추가</u>하려고 하는데<br/>
**이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면** `PURE FABRICATION`을 추가하여<br/>
`PURE FABRICATION`에 책임을 할당한다.

설계를 시작할 때
처음부터 `PURE FABRICATION`을 고려하지 말고
도메인의 본질적 개념을 표현하는 추상화를 이용해 구축하다가
충분치 않을 경우에 창조한다.

> #### ⁜ `PURE FABRICATION` 패턴 
> 도메인 객체에 책임 할당 작업을 수행할 때,<br/>
> 객체 지향 설계의 목적 [`HIGH COHESION`/`LOW COUPLING`/`REUSABILITY`] 을 **위반**하게 될 경우<br/>
> <u>문제 도메인 개념을 표현하지 않는</u> **인위적/편의상 만든 클래스**에 <u>매우 응집된 책임을 **할당**</u>하는 패턴이다.
> 
> `INFORMATION EXPERT` 패턴에 따라 <u>책임을 할당한 결과가 바람직하지 않을 경우</u> 대안으로 사용되는 패턴이다.

<br/>
<br/>

---
## 의존성 주입 ( `Dependency Injection` )

> 사용하는 객체가 아닌 <u>외부의 독립적인 객체가 인스턴스를 생성한 후</u> <br/>이를 **전달**해서 의존성을 해결하는 방법

의존성 주입은 근복적으로 의존성 해결 방법과 관련이 깊다.<br/>
즉, "**의존성 해결**"은 다양한 매커니즘을 통해 컴파일 타임 의존성과 런타임 의존성의 차이점을 해소하는 것을 가르킨다면<br/>
"**의존성 주입**"은 의존성을 <u>객체의 퍼블릭 인터페이스에 명시적</u>으로 드러내<br/>
**외부에서** <u>필요한 런타임 의존성을 전달할 수 있도록</u> 만드는 의존성 해결 방법을 포괄하는 명칭이다.

그에 따라 의존성 주입에서는 의손성 해결 방법 3가지에 대해 가르키는 별도의 용어를 정의한다.
- `생성자` 주입(`Constructor Injection`) : 객체를 **생성하는 시점**에 <u>생성자</u>를 통해 해결
  - 컴파일 타임 의존성을 런타임 의존성으로 대체


- `setter` 주입(`Setter Injection`) : 객체 **생성 후**, <u>setter 메서드</u>를 통해 해결
  - **장점**
    - 의존성의 대상을 런타임에 변경 가능
    - 언제라도 읜존 대상 교체 가능
  - **단점**
    - 올바른 객체 생성을 위해 필수적인 의존성을 명시적으로 표현 불가
    - setter 메서드 누락 시, 비정상적 상태의 객체 생성


- `메서드 호출` 주입(`Method Call Injection`) : **메서드 실행 시** <u>인자</u>를 통해 해결
  - 메서드가 유일하게 의존성을 필요로 할 경우 사용
  - **장점**
    - 객체가 올바른 상태로 생성되는데 필요한 의존성을 명확히 표현
  - **단점**
    - 주입된 의존성이 단순 한 두개의 메서드에서만 사용하게 되면 비효율적<br/>
      ( _각 메서드의 인자로 전달하는 것이 더 나은 방법일 수 있음._ )


### 의존성을 숨기지 마라.
물론 의존성 주입 외에도 의존성을 해결할 수 있는 다양한 방법이 존재한다.

> #### ⁜ `SERVICE LOCATOR` 패턴
> 의존성 주입 외로 의존성 해결의 방법 중 하나
> 
> <u>의존성을 해결할 객체들</u>을 **보관**하는 일종의 저장소 `SERVICE LOCATOR`를 두어<br/>
> **의존성이 필요한 객체**가 <u>직접 `SERVICE LOCATOR`에게 의존성 해결을 요청</u>하는 방식이다.
> 
> 서비스를 이용하는 코드로부터 **서비스가 누구인지**( _"서비스 구현 구체 클래스의 타입이 무엇인지"_ ),<br/> **어디에 있을지**( _"클래스 인스턴스를 어떻게 얻을지"_ ) <u>몰라도 되게 해준다</u>.

위  `SERVICE LOCATOR` 패턴은 얼핏보면<br/>
의존성 해결에 있어 가장 쉽고 간단한 도구로 보여지지만<br/>
가장 큰 단점으로 **의존성을 감춘다**는 특징이 존재한다.

그 이유는
의존성이 필요한 객체의 **생성자 내부**에서 `ServiceLocator.~~`와 같안 할당 방식으로 <u>**의존성을 숨긴채로** 생성하는 구조</u>인데<br/>
만약 필요한 인스턴스가 <u>예상한 클래스가 아닌 **다른 클래스의 인스턴스**</u>일 경우,<br/>
객체가 성공적으로 만들어진 것처럼 보이겠지만<br/>
의존성 필요 객체 내부의 **해당 의존 인스턴스**는 `null` 값이 돨 것이다.<br/>
당연히 그에 따라 `NullPointerException`이 던져지고 말이다.

즉, 의존성이 숨겨져있던 탓에 <u>컴파일 타임이 아닌 **런타임에 가서야**</u> null값인 것을 눈치채게 된다.<br/>

숨겨진 의존성이 이해하기 어렵고 디버깅도 어려운 이유가<br/>
이와 같이 **문제점을 발견할 수 있는 시점**을 <u>코드 작성 시점(컴파일 타임)이 아닌 **실행시점(런타임)으로 미루는 것**</u>이다.

이해와 디버깅뿐만 아니라<br/>
**단위 테스트**를 진행할 때에도<br/>
`SERVICE LOCATOR`에는 <u>**내부적**으로 **정적 변수**를 통해 객체들을 관리</u>하기 때문에<br/>
<u>모든 단위 테스트 케이스에 공통적으로 **상태**를 **공유**</u>하게 된다.<br/>
이것은 " _서로 고립돼야 한다._ "라는 단위 테스트 기본 원칙을 어기게 된 것이다.

물론 `@BeforeAll`이나 `@AfterAll`로 매 시작마다 추가하고 매 종료마다 삭제하는 작업을 통해<br/>
단위 테스트가 가능하긴 하나<br/>
바꿔말하면 <u>적절한 테스트 프레임워크가 없다면</u> 단위 테스트가 **비효율적**이게 된다는 것이다.

<br/>

그에 반해 의존성 주입은 이런 문제들을 깔끔히 해결한다.<br/>
필요한 의존성은 <u>클래스 퍼블릭 인터페이스에 명시적으로</u> 드러나서<br/>
의존성 이해를 위해 코드 **내부까지 읽을 필요가 없기** 때문에 객체의 캡슐화는 단단해질 것이다.<br/>
또한 만약 <u>문제가 발생하더라도</u><br/>
**최대한 컴파일 타임에** 잡을 수 있고<br/>
더 나아가 단위 테스트 시에도 `SERVICE LOCATOR`를 시작과 끝마다 추가/제거 작업을 수행할 필요가 없어진다.

결론은 **명시적인 의존성**이 <u>숨겨진 의존성보다 좋다</u>는 것이고<br/>
최대한 의존성을 객체의 퍼블릭 인터페이스에 노출시켜야 한다는 것이다.

그러니 최대한 아래 두 상황에서만 `SERVICE LOCATOR` 패턴을 고려해본다.
- <u>의존성 주입을 지원하는 프레임워크</u>를 **사용하지 못하는** 경우
- <u>깊은 호출 계층에 걸쳐</u> **동일한 객체**를 비효율적으로 **계속 전달**하게 되는 경우