# Chapter 3. 역할, 책임, 협력


앞서 살펴본 “클래스”, “상속”, “지연 바인딩” 등의 개념도 중요하긴 하나<br/>
코드 구현의 측면에서 중요한 개념이라 볼 수 있고

<u>객체지향 패러다임</u>에서의 **핵심**은 이들이 아닌<br/>
“**역할**(**Role**)”, “**책임(Responsibility)**”, “**협력(Collaboration)**” 이다.

정리하자면<br/>
클래스/상속은 객체들의 책임과 협력 구조가 어느 정도 잡혀있는 상태에서 사용할 수 있는 <u>구현 매커니즘</u>일 뿐이고

객체지향의 본질은 “**협력하는 객체들의 공동체를 창조하는 것**” 이며
객체지향 설계의 핵심은 “협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정”에서 드러난다.

> - 애플리케이션의 기능 구현을 위한 객체 간 상호작용 = **협력**
> - 협력에 참여하기 위해 수행하는 로직 = **책임**
> - 객체들의 협력 안에서 각 객체가 담당하여 수행하는 책임들의 집합 = **역할**

<br/>

---
## 협력(Collaboration)
일반적으로 객체 지향 원칙을 따르는 애플리케이션의 제어 흐름은<br/>
어떤 하나의 객체에 통제되지 않고 다양한 객체들 사이에 균형있게 분배되는 것이다.

그렇기 때문에 객체는 고립된 존재가 아닌 <br/>
<u>각자에게 분배된 책임을 수행</u>하며 **다른 객체와의 협력**을 통해서 시스템의 기능 수행하는 존재이다.

<br/>

협력은<br/>
하나의 객체가 다른 객체에게 도움을 요청할 때 시작되는데

이 도움 요청은 <u>메시지를 전송(message sending)</u>하는 것이며<br/>
이 행위가 객체 사이의 협력을 위해 사용할 수 있는 유일한 상호작용 수단이다.<br/>
( _다른 객체의 내부 구현에 직접 접근할 수 없기 때문에 **메시지 전송을 통해서만 요청을 전달**할 수 있음._ )

메시지를 수신하는 객체는 <br/>
**메서드**를 실행하여 **요청에 대한 응답**을 할텐데<br/>
여기서 중요한 점은 <u>메시지 처리 방법</u>에 대해<br/>
<u>외부에서 전달한 객체가 정해주는 것이 아닌</u> **해당 객체가 스스로 선택**한다는 점이다.<br/>
( _외부의 객체 : 오직 메시지 전달 / 어떻게 처리할지 결정 → 수신한 객체가 직접_ )

자신이 **알고 있는 정보**를 이용하여 **할 수 있는 일**을 하고<br/>
<u>**자신이 하지 못하는 일**이나 **알지 못하는 일**에 대한 처리</u>를 다른 객체에 **위임**하여 협력하는 것이<br/>
협력에 참여하는 객체들의 <u>전체적인 자율성을 향상</u>시킬 수 있다.

즉, "객체가 자율성을 갖는 것"이 중요하다는 의미이며<br/>
이 자율성을 가지게끔 만드는 가장 기본적인 방법이 **내부 구현 캡슐화**인 것이다.

이렇게 자율성을 가지게 된다면<br/>
” *메시지를 수신한 객체의 행동을 결정하는 것은 해당 객체가 참여하고 있는 협력이다.* ” 라는<br/>
결론을 도출할 수 있다.

> #### "위임할 책임조차 없는 독립적 객체는 사용할 수 있나?"
> 애플리케이션 안에 어떤 객체가 존재한다면
> 그 이유는 단 한 가지이다.
> 
> 그 객체가 **어떤 협력에 참여**하고 있고 <br/>
> 어떤 객체는 분명히 그 객체가 가진 책임을 지는 역할을 **필요로 하기 때문**이다.
> 
> 또한 해당 객체가 협력에 참여할 수 있는 이유도<br/>
> <u>협력에 필요한 **적절한 행동**을 **보유**</u>하고 있기 때문이다.
> 
> *즉, 어떠한 책임도 가지지 않은 객체는 애플리케이션에서의 존재 이유가 없는 것과 다름 없는 것이다.*

<br/>

따라서 <u>협력이 바뀌면</u> **객체**가 제공하는 **행동**까지 바뀌어야 하므로<br/>
**협력**은 **객체가 <u>필요한 이유**</u>와 객체가 수행하는 <u>**행동의 동기**</u>를 제공한다고 볼 수 있다.

바꿔말하면
객체의 <u>**행동**을 결정하는 것</u>이 **협력**이라면 <br/>
객체의 <u>**상태**를 결정하는 것</u>은 **행동**이라는 뜻이다.

그 객체가 행동을 수행하는데 필요한 정보가 무엇인지에 따라 <br/>
객체의 상태가 결정될 것이고<br/>

이 자율적인 존재의 객체는 <br/>
자신의 <u>상태를 **스스로 결정**</u>하고 <u>수행하는 행동에 **필요한 상태까지 모두 가지고** 있어야</u> 한다.

```java
/**
 * Movie - DiscountPolicy  협력관계
 */
public class Movie {
    private Money fee;
    // 상태
    private DiscountPolicy discountPolicy;
    
    // 행동(책임) : 요금 계산
    // 이 행동을 위해선 discountPolicy라는 상태가 필요함.
    // 단, 어떤 조건인지, 어떤 유형의 할인인지 까지의 상세 내용이 필요한 것이 아니기 때문에
    // 추상적인 DiscountPolicy로 상태를 가진다.
    public Money calculateMovieFee(Screening screening){
        return fee.minus( discountPolicy.calculateDiscountAmount(screening) );
    }
}
```

이렇게 상태는 "**행동하는데 필용한 정보**"에 의해 결정되고<br/>
협력은 객체가 처리할 "**메시지**"로 결정된다.

즉, 객체가 참여하는 **협력**이 객체를 구성하는 <u>행동과 상태 모두를 결정</u>하며<br/>
그에 따라 **협력**은 **객체 설계의 <u>문맥**(**Context**)</u>을 제공한다고 정리할 수 있다.

<br/>

---
## 책임(Responsibility)
객체 설계의 문맥인 협력이 잘 갖춰졌다면<br/>
그 다음은 협력에 <u>필요한 행동을 수행할 수 있는</u> 적절한 객체를 찾는 것이다.

여기서 협력에 참여하기 위해 객체가 **수행하는 행동**을 "**책임**"이라고 한다.

즉, 객체에 의해 정의되는 **응집도 있는 행위의 집합**으로<br/>
객체가 <u>유지해야하는 정보</u>와 <u>수행할 수 있는 행동</u>에 대해 개략적으로 서술한 문장이다.<br/>
( “**무엇을 할 수 있는가** : **doing**” / “**무엇을 알고 있는가** : **knowing**” )

- **하는 것** (**Doing**)
    - 객체를 <u>생성하거나 계산</u>을 수행하는 등의 **스스로 하는 것**
    - <u>다른 객체의 행동을 시작시키는</u> 것 == **메세지 전달**
    - <u>다른 객체의 활동을 제어하고 조절</u>하는 것
- **아는 것** (**Knowing**)
    - **사적인 정보**에 관해 아는 것
    - **관련 객체**에 관해 아는 것
    - 자신이 **유도하거나 계산할 수 있는 것**에 관해 아는 것

<br/>

**책임**(**Responsibility**)은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에<br/>
메시지보다 추상적이고 개념적으로도 더 크다.

단순한 책임을 넘어 <u>여러 개의 메시지로 분할</u>되기도 하고<br/>
하나의 객체가 수행할 수 있다고 생각했던 책임이<br/>
<u>여러 객체들이 협력해야만 하는 **큰 책임으로 확대**</u>되는 것이 일반적이다.

객체는 자신이 맡은 책임을 수행하는데 필요한 정보를 알 책임이 있고
또한 자신이 할수 없는 작업을 도와줄 협력할 객체를 알고 있을 책임도 있다.

이에 따라 **적절한 협력**이 <u>**적절한 책임**을 제공</u>하고,<br/>
**적절한 책임**을 <u>**적절한 객체에게 할당**해야만</u><br/>
단순하고 유연한 설계를 창조할 수 있는 것이다.

<br/>

### 책임 할당

자율적인 객체로 향하는 첫 단추는 바로<br/>
"**책임을 수행하는 데 필요한 정보**"를 <u>**가장 잘 알고 있는 전문가**에게 그 책임을 할당하는 것</u>이며<br/>
이를 책임 할당을 위한 <u>“***INFORMATION EXPERT(정보 전문가)***”</u>라 칭한다.

말 그대로<br/>
<u>협력에 필요한 지식과 방법</u>을 **가장 잘 알고 있는 객체에게** 도움을 요청하는 것이고<br/>
<u>요청에 응답하기 위해 **필요한 행동**</u>이 바로 그 <u>객체가 수행할 **책임**으로 이어지는 것</u>이다.

책임 할당을 위해서는 우선적으로 <u>**협력**이라는 문맥이 정의되야 한다.</u><br/>
이를 위해서는 시스템에서 "**사용자에게 재공하는 기능**"을 <br/>
시스템이 담당할 <u>하나의 **책임**으로 취급</u>하는 것이다.

이렇게 더 작은 책임을 찾아내고 객체들에게 할당하는 작업을 반복하며 <br/>
프로그램의 모양을 갖춰나가는 것이다.

<br/>

이처럼 객체지향 설계는<br/>
협력 속에서 프로세스에 <u>**필요한 메시지**를 찾고</u><br/>
메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 시스템이 이뤄진다.<br/>
여기서의 메시지가 해당 메시지를 <u>**수신할 객체**의 **책임**을 결정</u>한다.

물론 모든 책임 할당 과정 중<br/>
어떤 경우에는 꼭 정보 전문가에게 할당하기보단<br/>
<u>*다른 객체에게 책임을 할당하는 것이 적절한 경우도 있다.*</u><br/>

하지만 정보 전문가에게 할당하는 것만으로도 <br/>
<u>상태와 행동을 가진 자율적인 객체를 만들 가능성이 높기</u> 때문에<br/>
기본적인 전략은 **책임을 수행할 정보 전문가를 찾는 것**으로 설정하는 것이 바람직하다.

<br/>

### 책임 주도 설계

> #### < 책임 주도 설계 : Responsibility-Driven Design_RDD >
> **책임**을 찾고 책임을 수행할 **적절한 객체**를 찾아 <br/>
> <u>책임을 할당하는 방식</u>으로 **협력**을 **설계**하는 방식
> 
> **구현이 아닌 **책임에 집중할 수 있도록** 유도 → 유연하고 견고한 객체지향 시스템 설계* 

<br/>

#### 📌 책임 주도 설계(RDD)의 과정
1. 시스템이 사용자에게 제공해야 하는 기능인 **시스템 책임을 파악**
2. 시스템 **책임 세분화**
3. 분할된 책임을 수행할 **적절한 객체/역할 탐색 및 할당**<br/>
   - *객체의 책임 수행 도중 다른 객체의 도움이 필요한 경우에도 책임질 적절한 객체/역할 탐색 및 할당*
4. 책임 할당한 두 객체 **협력 설정**

<br/>

책임 할당 시 고려해야 할 요소들은 다음과 같다.

### 1.  메시지 → 객체 결정
> 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택하는 구조를 아는 것이 중요하다.

**< 메시지가 결정해야하는 이유 >**

- **최소한의 인터페이스** (**minimal interface**)를 가질 수 있게 된다.
  - 필요한 **메시지 식별될 때까지**<br/>
    객체의 <u>퍼블릭 인터페이스에 어떤 것도 추가되지 않음.</u><br/>
    *→ 어플리케이션 ⇒ "꼭 필요한 크기의 퍼블릭 인터페이스"를 가질 수 있음*


- **추상적인 인터페이스** (**abstract interface**)를 가질 수 있게 된다.
  - 객체의 인터페이스는 어떻게(how) 수행하는지에 대해선 노출해서는 안되는데<br/>
    **메시지**는 <u>외부의 객체가 요청하는 무언가(what)을 의미</u>하기 때문에<br/>
    메시지를 먼저 식별하면 <br/>
    어떻게(how)가 아닌 **무엇을(what) 수행할지**에 초점을 맞추는 인터페이스를 가질 수 있음

<br/>

###  2. 행동 → 상태 결정

객체가 존재하는 이유는 협력에 참여하기 위함이기 때문에<br/>
그에 따라 객체는 <u>**협력에 필요한 행동**을 제공</u>해야 한다.

객체의 행동은 협력에 참여할 수 있는 유일한 방법이기도 하니<br/>
객체가 협력에 "얼마나 적합한지" 결정하는 것은 <br/>
객체의 <u>상태가 아닌 **다른 객체에게 제공하는 행동**</u>이라고 볼 수 있다.

사실 객체지향 패러다임에서 흔히 나오는 실수가 바로<br/>
객체의 <u>행동이 아닌 상태에 초점을 맞추게 되는 것</u>이다.

"상태에 초점"을 맞추게 되면
객체의 **내부 구현**이 <u>객체의 **퍼블릭 인터페이스**에 **노출**되도록</u> 만들기 때문에<br/>
**캡슐화**를 **저해**하는 요인으로 작용한다.<br/>
( _객체의 내부 구현에 초점을 맞춘 설계 방법 = " **데이터 주도 설계 : Data-Driven Design** "_ )

<br/>

<u>캡슐화를 위반하지 않도록</u> **구현에 대한 결정**은 뒤로 미루면서<br/>
객체의 행위를 고려하기 위해서는<br/>
항상 "**협력**"이라는 **문맥 안에서 객체를 생각**하는 버릇을 가져야 한다.

또한<br/>
협력 관계 속에서 다른 객체에게 <u>무엇을 제공해야 하고 무엇을 얻어야하는지</u>를 고민해야만<br/>
**훌륭한 책임**을 수확할 수 있고

개별 객체의 상태와 행동이 아닌<br/>
<u>**시스템의 기능을 구현**하기 위한 협력</u>에 초점을 맞춰야만<br/>
"**<u>응집도가 높고 결합도가 낮은</u> 객체들**"을 **창조**할 수 있다.<br/>
( _**상태**는 단지 <u>행동을 수행하기 위한 재료</u>로 생각하는 것이 좋다._ )

<br/>

---
## 역할(Role)

> 객체는 협력이라는 문맥 안에서 <u>특정한 목적을 갖게 되고</u><br/>
> 그 목적은 협력 안에서 객체가 맡게 되는 **책임의 집합**으로 표시된다.
> 
> 이처럼 객체가 **어떤 특정한 협력** 안에서 수행하는 책임의 집합을 **역할**이라고 부른다.<br/>
> ( _실제로 협력에 대해 모델링 할 때, 특정 객체가 아닌 "역할"에 책임을 할당한다고 생각하면 편하다._ )

즉, 특정 객체를 먼저 배치시키면서 프로그램을 생각한다기 보다<br/>
역할을 먼저 생각하고 그 역할에 적절한 객체들을 만들어 나가는 것이 좋다. 

<br/>

### 유연하고 재사용 가능한 협력

예를 들어 “할인 적용” 라는 역할을 명시하지 않고

<u>“금액 할인 적용”이라는 협력</u>과 <u>“비율 할인 적용”이라는 협력</u> 두 가지를 <br/>
개별적으로 구현하게 되면<br/>
당연히 대부분의 코드가 중복될 것이다.

이 두 협력에서는
**할인**이라는 <u>**동일한 책임**</u>이지만<br/>
역할을 제외하고 생각하여 구현했기 때문에 불필요한 중복이 발생하게 된 것이다.

이처럼 고려하는 순서가 <u>객체에게 역할을 먼저 대입하고 구현한다면</u> 해당 **객체에 휘둘리는 코드**가 될 가능성이 높다.<br/>
따라서 이와 같은 문제를 해결하기 위해서는 <u>객체가 아닌 **책임**에 초점</u>을 맞춰야한다.

<br/>

즉, <u>다수의 협력이 **동일한 책임**</u>을 가진다면<br/>
해당 책임에 대한 응답을 할 수 있는 **대표자**인 역할을 정해 놓는다면<br/>
협력을 **하나로 통합**하고

이 대표자는 다수의 동일 책임 객체들을 교대로 사용할 수 있는 기준으로 활용될 수 있다.<br/>
( _대표자인 역할은 여러 동일 책임 객체들이 참여할 수 있는 일종의 **슬롯**이라고 보면 이해하기 쉽다._ )

> *" **역할은 다른 것으로 교체할 수 있는 책임의 집합이다.** " - Wirfs-Brock03 -*

<br/>

<u>두 종류 이상의 구체적인 객체를 포괄</u>하는 역할의 모양새는 분명 **추상화**의 모습이다.

이전 단원에서 코드로도 봤던<br/>
`AmountDiscountPolicy`와 `PercentDiscountPolicy`를 포괄하는<br/>
`DiscountPolicy` 인터페이스가 바로 역할이라고 할 수 있다.

요점은 이 추상화를 통해<br/>
<u>**동일한 책임을 수행하는 역할**을 기반</u>으로 두 가지의 협력을 하나로 **통합**한 덕분에<br/>
**불필요한 중복 코드를 제거**할 수 있고<br/>
**더욱 유연하게 협력을 관리**할 수 있게 되는 것이다.

> ### 역할(Role) 구현
> 추상화라는 말을 언급했듯이<br/>
> 역할을 구현하는 가장 일반적인 방법은 **추상 클래스**와 **인터페이스**를 활용하는 것이다.<br/>
> ( _구체 클래스들이 따라야 하는 책임의 집합을 서술해 놓은 것_ )
> 
> **역할**이 <u>다양한 종류의 객체를 수용할 수 있는</u> 일종의 **슬롯**이자<br/>
> <u>구체적인 객체들의 타입을 캡슐화</u>하는 추상화이다.<br/>
> 따라서 중요한 것은 **행동**이며, <br/>역할은 객체를 추상화해서 객체 자체가 아닌 **협력에 초점**을 맞출 수 있게 된다.

<br/>

---
### "역할" 과 "객체"

공통된 행동을 가진 다양한 객체들의 슬롯처럼 사용되는 개념이 역할이라고 했는데<br/>
만약 <u>오직 한 종류의 객체만 협력에 참여</u>하는 상황이라면<br/>
오히려 역할을 사용하는 것은 더 복잡하게 만들 것이다.

실제로 _'레베카 워프스브록'_ 의 말을 빌리자면<br/>
> **협력에 참여하는 후보**가 <u>여러 종류의 객체에 의해 수행될 필요</u>가 있다면 그 후보가 **역할**이 되겠지만<br/>
> <u>단 한 종류의 객체만이 협력에 참여</u>할 필요가 있다면 후보는 그저 **객체**가 된다.

즉,협력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주하고<br/>
여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 되는 것이다.

> #### ⁜ 협력/역할/객체/클래스 의 관계
> : **협력**(**Collaboration**) - ( _reference_ ) → **역할**(**Role**) <br/>- ( _select from_ ) → **객체**(**Object**) - ( _instance of_ ) → **클래스**(**Class**)

<br/>

하지만 대부분의 경우 <u>어떤 것이 역할이고 객체인지</u> **확연하게 구분되어 나타나지 않기 때문에**<br/>
설계 단계부터 명확한 기준을 세워서 역할로 시작할지, 객체로 시작할지 결정하기 상당히 어려운 부분이다.

이럴 경우,<br/>
초반 설계 단계에서는 **책임과 협력의 큰 그림**을 먼저 탐색하는 것을 목표로 하며<br/>
역할과 객체를 명확하게 구분하는 것은 후순위로 두는 것이 효율적일 것이다.

즉, 다양한 객체들이 협력에 참여한다는 것이 확실할 경우에 **역할**로 시작하고<br/>
만약 모든 것이 정확한 결정을 내리기 애매한 상황이라면 **구체적인 객체**로 시작하는 것이 바람직하다.

이를 시작으로<br/>
**다양한 <u>시나리오 탐색**</u>과 **유사한 협력들의 <u>단순화와 통합**</u>을 반복하다보면<br/>
자연스레 역할의 모습이 드러날 것이다.

<br/>

### 역할 - 추상화

협력을 구체적인 객체가 아닌
**추상적인 역할**의 관점에서 설계하면

협력이 유연하고 재사용이 가능해진다.

역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에
어찌보면 역할을 **객체의 추상화**로 볼 수 있다.

그렇기에 <u>추상화가 가지는 장점들</u> 또한
추상화가 핵심인 역할에게도 동일하게 적용된다.

<br/>

추상화를 통해 **<u>세부 사항에 억눌리지 않고도</u>**<br/>
상위 수준의 정책을 <u>**쉽고 간단하게 표현**</u>할 수 있기 때문에
**핵심적인 개념을 강조**할 수 있다.

그에 더해 <u>**설계**를 **유연**하게</u> 만들 수도 있는데<br/>
앞서 언급된 “ <u>_역할은 다양한 종류의 객체를 끼워 넣을 수 있는 일종의 슬롯_</u> ”이라는 것을 착안하면 이해된다.

즉, 협력 안에서 동일한 책임을 수행하는 객체들은 동일한 역할을 수행하기 때문에<br/>
서로 **대체 가능**하고<br/>
그에 따라 역할은 <u>다양한 환경에서 **다양한 객체들을 수용**</u>할 수 있게 해주므로<br/>
협력을 유연하게 만드는 것이다.