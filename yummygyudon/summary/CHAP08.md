# Chapter 8. 의존성 관리하기

잘 설계된 객체 지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다.<br/>
**작고 응집도 높은 객체**라 함은 <u>책임이 명확하고 **한 가지 일만** 잘하는 객체</u>를 의미한다.

단, 이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에<br/>
다른 객체와의 **협력 관계**가 **필수적**이다.

하지만 협력은 객체가 <u>다른 객체에 대해 알 것을 강요</u>하고<br/>
객체가 <u>수신할 수 있는 메시지에 대해서도 알고</u> 있어야 하기 때문에<br/>
필수적 존재이면서도 과도할 경우 설계는 곤경에 처한다.

그에 따라 협력에 있어 의존성이 필수적이지만<br/>
**과도한 의존성**은 애플리케이션을 **수정하기 어렵게** 만들기 때문에<br/>
협력을 위해 <u>필요한 의존성은 유지하되 변경을 방해하는 의존성은 제거하는 것</u>이 객체지향 설계의 핵심이다.

바꿔말하자면 **객체 지향 설계**란 <u>의존성을 관리하는 것</u>이고<br/>
**객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술**이라고 할 수 있다.

<br/>

## 의존성 이해
### 변경과 의존성
어떠한 두 객체간의 협력 관계에서는 의존성이 존재하게 되는데<br/>
이 의존성은 실행시점과 구현 시점에 서로 다른 의미를 가진다.
- **실행** 시점 : 실행 시에 <u>의존 대상 객체가 반드시 존재</u>해야 한다.
- **구현** 시점 : **의존 대상 객체가 변경**될 경우, <u>의존하는 객체도 함께 변경</u>된다.

어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우<br/>
두 객체 사이에 <u>**단방향**</u>의 의존성이 존재한다.

그에 따라<br/>
의존**되는** 요소가 **변경** 될 때,<br/>
<u>의존**하는** 요소도 함께 변경될 수 있다</u>는 것이다.<br/>
이는 의존성이 **<u>변경에 의한 영향 전파</u> 가능성**을 암시한다.

### 의존성 전이
의존성을 전이가 될 수 있는데
한 객체가 특정 객체에 의존할 경우, 특정 객체가 의존하는 대상에 대해서도 자동으로 의존하게 된다.

다시 말해,
의존성이 한 다리 건너까지 전이된 것이다.

의존성은 함께 변경될 수 있는 가능성을 의미하기에 꼭 모든 경우에 의존성이 전이되진 않으며
전이 여부는 변경의 방향과 캡슐화 정도에 따라 달라진다.
즉, 전이는 그저 변경에 의해 영향이 널리 전파될 수도 있다는 경고일 뿐이다.

이런 의존성의 전이 특성을 기준으로
의존성의 종류를 2가지로 나눌 수 있다.
1. **직접 의존성** (**Direct** Dependency)
   - 한 요소가 <u>다른 요소에 직접 의존</u>하는 경우
2. **간접 의존성** (**Indirect** Dependency)
    - <u>직접적인 관계는 존재하지 않지만</u> 의존성 전이에 의해 **영향이 전파**되는 경우
    - 코드 안에 **명시적으로 드러나지 않는다**.

<br/>

### `Run-time` 의존성 && `Compile-time` 의존성
**런타임**은 말 그대로 **애플리케이션이 실행되는 시점**을 가르키고<br/>
**컴파일 타임**은 물론 <u>컴파일하는 시점</u>으로 볼 수 있지만<br/>
사실 핵심은 시점이 아닌 우리가 작성한 **코드의 구조**에 있다.<br/>
( _해당 단어가 어떤 것을 가르키는 것인지 잘 파악하는 것이 중요하다._ )

객체지향 애플리케이션에서 <u>**런타임**의 주인공</u>은 **객체**다.<br/>
따라서 **런타임 의존성**이 다루는 주제는 <u>"**객체**"사이의 의존성</u>이고<br/>
코드 관점에서의 주인공은 클래스이기 때문에<br/>
**컴파일 타임 의존성**이 다루는 주제는 <u>"**클래스**"사이의 의존성</u>이다.

얼핏 보면 똑같아 보일 수 있지만<br/>
<u>런타임 의존성과 컴파일 타임 의존성이 다를 수 있다</u>는 사실을 간과해선 안된다.

사실 **유연하고 재사용성이 높은 코드**를 설계하기 위해서는 <u>두 종류의 의존성을 서로 다르게</u> 만들어야 한다.

해당 개념들을 이해하기 위해선 다시 한 번 추상화의 도움이 필요하다.
> - `Movie` 클래스 
> - `DiscountPolicy` 인터페이스
>   - `AmountDiscountPolicy` 클래스 / `PercentDiscountPolicy` 클래스
> 
> 
> - `Movie` 클래스와 `DiscountPolicy` 인터페이스 간의 의존성 :  **컴파일 타임 의존성**
> - 상황별로 다르게 협력 관계가 맺어지는 "`Movie` 클래스와 `AmountDiscountPolicy` 클래스" / "`Movie` 클래스와 `PercentDiscountPolicy` 클래스" 간의 의존성 : **런타임 의존성**
>
> <u>**코드를 작성하는 시점**</u>의 Movie 클래스는 `AmountDiscountPolicy` 클래스나 `PercentDiscountPolicy` 클래스의 <u>존재에 대해 전혀 알지 못하지만</u><br/>
> <u>**실행 시점**</u>의 Movie 인스턴스는 `AmountDiscountPolicy` 인스턴스, `PercentDiscountPolicy` 인스턴스와 협력할 수 있어야 한다.
> 
> 만약, Movie 클래스가 **둘 중 하나의 정책 클래스에 의존**하게 되면 <u>다른 정책 인스턴스와 협력하는 것이 불가능</u>할 것이다.<br/>
> 그렇다고 **둘 모두에 의존하게 하는 것**도 Movie 클래스의 <u>전체적인 결합도를 높이고 또 다른 정책 추가도 여전히 어렵기</u> 때문에 바람직하지 않다.
> 
> 그에 따라 함께 협력할 수 있게 만드는 더 나은 방법은 차라리 " <u>**어떤 것도 알지 못하게 만드는 것**</u> "이다.<br/>
> 대신 모두를 포괄하는 DiscountPolicy 라는 추상 클래스를 의존하도록 하여 정책 클래스 인스턴스들에 대한 런타임 의존성으로 대체해야 한다.

즉, 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는<br/>
**협력할 인스턴스의 구체적인 클래스를 알아서는 안된다**.

**실제로 협력할 객체**는 <u>런타임에 알 수 있어야</u> 하며<br/>
협력할 객체의 클래스를 <u>추상적으로 드러내</u> **유연하고 재사용 가능한 코드**를 작성해야 한다.

<br/>

### 컨텍스트 독립성
유연하고 확장 가능한 설계를 만들기 위해서는<br/> 
컴파일 타임 의존성과 런타임 의존성이 달라야 한다는 사실을 알 수 있었다.

다시 한 번 강조하자면<br/>
구체적인 **클래스를 알면 알수록** <u>그 클래스의 문맥에 귀속</u>되버리기 때문에<br/>
클래스는 <u>**자신과 협력할 객체의 구체적 클래스에 대해서는 알아선 안된다.**</u>

이처럼 클래스가 <u>특정 문맥에 **강하게 결합**될수록</u> **다른 문맥에서 사용하기 어려워**지는 반면<br/>
클래스가 사용될 <u>특정 문맥에 대해 **최소한의 가정**만으로 알고 있다면</u> **다른 문맥에서도 재사용하기 수월**해지는 특성을<br/>
" <u>_**컨텍스트 독립성**_</u> "이라고 한다.

> 시스템을 구성하는 객체가 컨텍스트 독립적이라면<br/>
> 시스템은 **변경하기 용이**하다.
> 
> 즉, **각 객체**가 <u>해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다</u>는 의미이기 때문에<br/>
> **행위의 단위(객체)를 가지고 새로운 상황에 적용**할 수 있다는 것이다.
> 
> 이에 따라 <u>다양한 컨텍스트에 적용할 수 있는</u> **응집력 있는 객체**를 만들 수 있고<br/>
> <u>객체 구성 방법을 재설정</u>해서 **변경 가능한 시스템**으로 나아갈 수 있다.

<br/>

> #### ⁜ 의존성 해결
> <u>**컴파일 타임 의존성**을 실행 컨텍스트에 맞는 적절한 **런타임 의존성**으로 교체하는 것</u>을<br/> 
> " <u>**의존성 해결**</u> "이라고 한다.
> - <u>객체 **생성 시점**</u>에 "**생성자**"를 통해 의존성 해결
> - <u>객체 **생성 후**</u> "**setter 메서드**"를 통해 의존성 해결
> - <u>**메서드 실행**</u> 시 "**인자**"를 이용해 의존성 해결
> 
> <u>`setter 메서드`를 이용하는 방법</u>은 <br/>
> **실행 시점**에 <u>의존 대상을 변경</u>할 수 있기 때문에
> 설계를 좀 더 **유연**하게 만들 수 있다.
> 
> 하지만 객체 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에<br/>
> <u>객체를 생성하고 의존 대상을 설정하기 전까지는</u> **객체의 상태가 불완전**할 수 있다는 단점이 있다.
> 
> <br/>
> 
> 그에 따라 더 개선된 방법은<br/>
> <u>`생성자 방식`과 `setter 방식`</u>을 **혼합**하는 것이다.<br/>
> **완전한 상태의 객체를 생성한 후**, <u>필요에 따라 setter 메서드</u>를 이용해 **의존 대상을 변경**할 수 있게 할 수 있다.
> 
> 이를 통해 시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬 수 있기 때문에 의존성 해결을 위해 가장 선호된다.
> 
> <br/>
>
> <u>`메서드 인자`를 사용하는 방식</u>은 <br/>
> 협력 대상에 대해 **지속적인 의존 관계를 맺을 필요 없이**<br/>
> <u>메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방</u>하거나,<br/>
> 메서드가 <u>실행될 때마다 의존 대상이 매번 달라져야 할 때</u> **유용**하다.
