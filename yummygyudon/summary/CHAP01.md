# Chapter 1. 객체, 설계
<br/>

> 〈 **소프트웨어 모듈의 3가지 목적** 〉
>1. 실행 중에 **제대로 동작**하는 것
> 2. **변경을 위해 존재**하는 것
>   - 대부분의 모듈은 생명 주기동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 함
> 3. 코드를 **읽는 사람과 의사소통**하는 것

<br/>

### 예상 가능한 코드

<p>
모든 프로그램을 설계할 때,<br/>
그저 결과론적으로 작동이 된다는 것에 의의를 두는 것이 아닌<br/>
실제로 해당 코드대로 현실세계에서 작동한다는 가정하에<br/>
모든 프로세스가 **실제 서비스와 같은** 프로세스로 작동하는 것이 좋다.

또한 코드, 즉 <u>변수 명이나 메서드 명</u> 또한 살펴보았을 때,<br/>
**어떤 행동/작업인지 바로 이해가 가능하며 납득이 가게끔** 설계하는 것이 바람직하다.

<br/>

### 변경 가능한 코드
객체 사이의 **의존성**(**Dependency**)와 관련된 문제로<br/>
객체 지향 설계는 “**서로 의존하면서 협력하는 객체들의 공동체**를 구축하는 것”이기는 하나

최소한의 의존성만 유지하고 불필요한 의존성을 제거해서<br/>
객체 간 변경에 대한 영향이 최대한 크지 않게 설계해야 한다.

즉, 객체 사이의 **결합도**(**Coupling**)를 낮춰 <u>변경이 용이한 설계</u>를 만드는 것이 바람직하다. 

<br/>

### 자율성 높은 설계
객체 각각이 가진 본분에 벗어나는 기능에 대해서는<br/>
서로 겹치지 않고 **자율적인 존재**로 설계를 해주어야 한다.

이를 실현하기 위해선 우선적으로 행해져야 하는 작업이 바로 **캡슐화**(**Encapsulation**) 이다.<br/>
캡슐화는 <u>개념적이나 물리적으로 객체 **내부의 세부적인 사항을 감추는 것**</u>을 말하는데

이를 통해 유지보수 측면에서도 <br/>
변경 및 수정이 용이하고 분리하여 관리하고 이해하기 좋다.

더 나아가 서로에게 간섭하지 않도록 <br/>
내부 모든 코드에 직접적인 접근을 할 수 없게끔 만들 수 있다.

<br/>

### 결합도와 응집도

객체 내부의 상태를 캡슐화하게 되면<br/>
객체 간에 상호작용은 오직 **메시지**를 통해서만 가능하게 된다.

즉, 객체들은 <u>서로 내부에 대해서는 전혀 알지 못한 상태</u>에서 <br/>
상대 객체가 처리해야할 내용을 **메시지로 전송**해줄 뿐인 것이다.

이처럼 밀접하게 연관된 작업만을 수행하고 <br/>
<u>연관성 없는 작업은 다른 객체를 위임해서</u> 외부의 **간섭**을 **최대한 배제**한 **자율적**인 객체에 대해서<br/>
"**<u>응집도</u>가 높다**" 혹은 "**<u>결합도</u>가 낮다**" 라는 표현을 사용한다.

이런 자율적인 객체들을 활용해서 각자의 책임으로 개별 객체로 나눠 **자신들의 역할을 스스로 책임질 수 있도록** 구성해야 한다.<br/>
(_한곳에 몰려있던 책임을 개별 객체에 이동하는 것 : "책임의 이동"_ )
> ### 결합도
>
> 직접 접근하지 않고 특정 내용이 내부에 존재한다는 사실을 알지 못하도록 해서<br/>
> 단지 특정 연산 메서드의 응답을 통해서만<br/> 
> 내부 값을 활용할 수 있도록하는 것이 캡슐화의 목표 중 하나이다.
>
> 이런 모습은 **인터페이스**에 의존하는 모양이며<br/>
> 내부에 특정 클래스의 인스턴스를 포함하고 있다는 사실은 **구현(implementation)** 영역에 속한다.
>
> 이를 통해 객체를 “인터페이스”와 “구현”으로 나누고 **인터페이스만 공개하는 것**은<br/>
> 객체 사이의 **결합도를 낮추고** 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 **가장 기본적인 설계 원칙**이다.
>
> 위와 같이 설계할 경우,<br/>
> 특정 클래스 자체의 기능을 변경하고 코드를 수정하더라도<br/>
> 타 클래스의 코드까지 함께 변경할 필요가 없게 된다.
>
> ### 응집도
>
> 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다하는데<br/>
> **자신의 데이터를 스스로 처리**하는 **자율적인 객체**로 만들면 <br/>
> 결합도를 낮출 수 있을뿐더러 응집도 또한 높일 수 있다.
> 
> 여기서 연관된 작업만을 수행하게끔 작업을 위임하는 것을 “**책임의 이동**”이라고 하며
> 이와 같이 객체 자신과 연관된 작업을 “**책임**”이라고 할 수 있다.
> 
> 이를 위해서는 객체 스스로 자신의 데이터를 책임져야 하며
> 최대한 자신이 소유하지 않은 데이터를 이용해 작업을 처리하지 않도록 설계하는 것이 바람직하다.

“**외부의 간섭을 최대한 배제**하고 **메시지를 통해서만 협력**하는 자율적인 객체들의 집합체를 만드는 것”<br/>
즉, 결합도를 최대한 낮추고 응집도를 최대한 높이는 것이 <br/>
가장 훌륭한 객체지향 설계의 방향이라고 할 수 있다. 

하지만 설계를 하다보면 자율성을 높여서 결합도가 같이 높아지거나<br/>
너무 응집도를 높이다보니 자율성이 떨어지는 상황이 빈번하게 발생한다.

이처럼 모든 요소를 만족시킬 수는 없는 터라<br/>
상황에 따라 _결합도를 낮추는 것이 중요한지 혹은 자율성이 더 중요한지_<br/>
잘 판단하여 적절한 **트레이드 오프**를 실현해내야 한다.

### 의인화(Anthropomorphism)
객체지향 설계를 행할 때,
각자의 역할에 따라 현실에서 실제로 존재하는 존재처럼 생각하며 자율적인 존재로 설계를 진행할 수 있는데

물론 역할 자체가 현실 세계에서는 수동적인 업무일지는 몰라도<br/>
이와 같이 객체지향 설계 과정에서는 <u>모든 것을 능동적이고 자율적인 존재라는 전제</u> 하에<br/>
실제 존재하는 **능동적이고 자율적인 객체라고 생각하며** <br/>
소프트웨어 객체를 설계하는 원칙을 **의인화**(**Anthropomorphism**)라 한다.

> #### < 객체지향 설계를 할 때의 마음 가짐 >
> 마치 우리가 현실 세계에서 에이전트로 행동하는 것처럼<br/>
> 그들의 시스템 안에서 에이전트처럼 행동한다 생각함으로서<br/>
> 의인화(anthropomorphism)하여 설계한다.<br/>
> 
> *(실제로 객체 지향 소프트웨어에는 각 클레스의 인스턴스는 생명주기를 가지며  
각 객체마다 서로 가진 데이터와 메서드가 존재하는 것이 상당히 유사하다.)*

<br/>

---

### 설계의 필요성
> 설계는 코드를 **배치**하는 것이다.
> 
> -_[Metz12]_ -

“데이터와 프로세스를 나누어 별도의 클래스에 배치하는 방식” 과 <br/>
“**필요한 데이터를 보유한 클래스 내부에 사용하는 프로세스를 배치하는 방식**” 중 <br/>
한 가지 방법을 선택하여 설계된 프로그램이 있다면<br/> 
**후자**가 조금 더 객체 지향적이고 자율적인 객체로 설계할 수 있다.

좋은 설계는  “*오늘 완성해야 하는 기능을 구현하는 코드를 짜기*”라는 요구사항과
”*내일 쉽게 변경할 수 있는 코드를 짜기*”라는 요구사항을 동시에 충족시키는 설계이다.