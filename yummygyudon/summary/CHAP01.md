> 〈 **소프트웨어 모듈의 3가지 목적** 〉
>1. 실행 중에 **제대로 동작**하는 것
> 2. **변경을 위해 존재**하는 것
>   - 대부분의 모듈은 생명 주기동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 함
> 3. 코드를 **읽는 사람과 의사소통**하는 것

<br/>

## 예상 가능한 코드

<p>
모든 프로그램을 설계할 때,

그저 결과론적으로 작동이 된다는 것에 의의를 두면 아니되고

실제로 해당 코드대로 현실세계에서 작동한다는 가정하에

모든 프로세스가 실제 서비스와 같은 프로세스로 작동하는 것이 좋다.

또한 코드, 즉 변수 명이나 메서드 명 또한 살펴보았을 때,

어떤 행동/작업인지 바로 이해가 가능하며 납득이 가게끔 설계하는 것이 바람직하다.

<br/>

### 변경 가능한 코드

객체 사이의 의존성(Dependecy)와 관련된 문제로

객체 지향 설계는 “서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것”이기는 하나

최소한의 의존성만 유지하고 불필요한 의존성을 제거해서

객체 간 변경에 대한 영향이 최대한 크지 않게 설계해야 한다.

→ 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이 바람직하다. 

### 자율성 높은 설계

객체 각각이 가진 본분에 벗어나는 기능에 대해서는

서로 겹치지 않고 자율적인 존재로 설계를 해주어야 한다.

이를 통해 유지보수 측면에서도 변경 및 수정이 용이하고 분리하여 관리하고 이해하기 좋다.

더 나아가 서로에게 간접하지 않도록 내부로 모든 코드를 직접적으로 접근할 수 없게끔 만들 수 있다.

### 결합도와 응집도

1. **결합도**

직접 접근하지 않고 특정 내용이 내부에 존재한다는 사실을 알지 못하도록 해서

단지 특정 연산 메서드의 응답을 통해서만 내부 값을 활용할 수 있도록하는 것이 캡슐화의 목표 중 하나이다.

이런 모습은 **인터페이스**에 의존하는 모양이며

내부에 특정 클래스의 인스턴스를 포함하고 있다는 사실은 **구현(implementation)** 영역에 속한다.

이를 통해 객체를 “인터페이스”와 “구현”으로 나누고 **인터페이스만 공개하는 것**은 

객체 사이의 **결합도를 낮추고** 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 **가장 기본적인 설계 원칙**이다.

위와 같이 설계할 경우,

특정 클래스 자체의 기능을 변경하고 코드를 수정하더라도 

타 클래스의 코드까지 함께 변경할 필요가 없다는 것이다.

1. **응집도**

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(cohesion)가 높다하는데

**자신의 데이터를 스스로 처리**하는 **자율적인 객체**로 만들면 결합도를 낮출 수 있을뿐더러 응집도 또한 높일 수 있다.

여기서 연관된 작업만을 수행하게끔 작업을 위임하는 것을 “**책임의 이동**”이라고 하며
이와 같이 객체 자신과 연관된 작업을 “**책임**”이라고 할 수 있다.

이를 위해서는 객체 스스로 자신의 데이터를 책임져야 하며

최대한 자신이 소유하지 않은 데이터를 이용해 작업을 처리하지 않도록 설계하는 것이 바람직하다.

“**외부의 간섭을 최대한 배제**하고 **메시지를 통해서만 협력**하는 자율적인 객체들의 집합체를 만드는 것”

이것이 가장 훌륭한 객체지향 설계의 방향이라고 할 수 있다. 

그렇다고 지나칙 객체 지향적인 설계를 하기 위해서

의존성을 아예 배제시키는 것이 좋은 처사는 아니다.

**캡슐화**를 이용해 **의존성을 적절히 관리**함으로써 객체 사이의 **결합도를 낮추는 것**이 가장 핵심이다.

> **********************************************************************************************객체지향 설계를 할 때의 마음 가짐
:********************************************************************************************** 마치 우리가 현실 세계에서 에이전트로 행동하는 것처럼
그들의 시스템 안에서 에이전트처럼 행동한다 생각하며 ******************************의인화(anthropomorphism)******************************하여 설계한다.
*(실제로 객체 지향 소프트웨어에는 각 클레스의 인스턴스는 생명주기를 가지며  
각 객체마다 서로 가진 데이터와 메서드가 존재하는 것이 상당히 유사하다.)*
> 

> 설계는 **배치**하는 것이다.
> 

“데이터와 프로세스를 나누어 별도의 클래스에 배치하는 방식” 과 “필요한 데이터를 보유한 클래스 내부에 사용하는 프로세스를 배치하는 방식” 중 하나의 방식으로 설계된 프로그램이 있다면 후자가 조금 더 객체 지향적이고 자율적인 객체로 설계할 수 있다.

좋은 설계는  “*오늘 완성해야 하는 기능을 구현하는 코드를 짜기*”라는 요구사항과
”*내일 쉽게 변경할 수 있는 코드를 짜기*”라는 요구사항을 동시에 충족시키는 설계이다.