# Chapter 13. 서브 클래싱 & 서브 타이핑
> 올바른 목적 : " 코드 재사용이 아닌 타입 계층 구현하는 것 " 
> 
> → "**동일한 메시지**에 대해 **서로 다르게 행동**할 수 있는 <u>다형적인 객체</u>를 구현"하기 위해<br/>
> " **객체의 행동** "을 기반으로 타입 계층을 구성해야 한다.
#### ＜"상속"의 용도＞
1. " <u>타입 계층</u> 구현 "
   - **부모** 클래스 : <u>자식 클래스</u>의 **일반화**(**Generalization**)
     - 타입 계층 내에서 <u>일반적인 개념</u>을 구현
   - **자식** 클래스 : <u>부모 클래스</u>의 **특수화**(**Specialization**)
     - 타입 계층 내에서 <u>특수한 개념</u>을 구현

2. " 코드 <u>재사용</u> "
    - **점진적**으로 애플리케이션 **기능 확장**
    - 부모 자식 클래스간의 강한 결집 → <u>변경하기 어려운 코드</u>

>📍`객체 기반(Object-Based)` vs `객체 지향(Object-Oriented)`
> 
> 1. `상속` / `다형성` 지원 여부
>    - `객체 지향(Object-Oriented)` **⊂** `객체 기반(Object-Based)`
>    - `객체 기반(Object-Based)` : 지원 ❌
>      - _ex. Visual Basic, .._
>    - `객체 지향(Object-Oriented)` : 지원 ⭕️
>      - _ex. Java, C++, Ruby, C# .._<br/><br/>
> 2. `클래스` 사용 여부
>    - `객체 기반(Object-Based)` : 클래스가 존재 하지 않음 / Only 객체 사용
>      - "**프로토타입 기반 언어**(Prototype-Based Language)"
>    - `객체 지향(Object-Oriented)` : 클래스를 사용하는 방식

<br/>
<br/>


---

---
## 타입
### 개념 관점
> 우리가 인지하는 세상의 사물의 종류
> - 인간이 인지하는 객체들에 적용하는 개념/아이디어
> - 사물을 분류하기 위한 틀
>
> " _어떤 대상이 타입으로 분류_ " <br/>→ 해당 **대상** = 해당 타입의 "**인스턴스**"/"**객체**" 

- **심볼**(Symbol)
  - 타입에 **이름**을 붙인 것
- **내연**(Intension)
  - 타입의 **정의**
  - 타입에 속하는 객체들이 가지는 **공통적인 속성/행동**
- **외연**(Extension)
  - 타입에 속하는 객체들의 **집합**

<br/>

### 프로그래밍 언어 관점
> 연속적인 비트에 의미와 제약을 부여하기 위해 사용되는 도구
> - **데이터** → 0과 1로 구성된 **일련의 비트 조합**
>   - 일련의 비트 조합들 속에서 <u>의미를 부여하며 비트를 묶어내기 위한 **제약**과 **규칙**</u>


#### ＜"타입"의 목적＞
- 타입에 수행될 수 있는 "**유효한 오퍼레이션의 집합**"을 **정의**
  - ex. `+` 연산자
    - _Java : 원시형 숫자 타입 / 문자열 타입간 연산만 허용_
    - _C++/C# : **연산자 오버로딩** → 클래스 인스턴스간의 `+` 연산 가능_


- 타입에 <u>수행되는 오퍼레이션에 대해</u> "**미리 약속된 문맥**" 제공

<br/>

### 객체 지향 패러다임 관점
> - `개념` 관점 : "공통의 특징을 공유하는 대상들의 분류"
> - `프로그래밍 언어` 관점 : "동일 오퍼레이션을 적용할 수 있는 인스턴스들의 집합"
> 
> ⁜ "**타입**" == <u>호출 가능한 "**오퍼레이션**</u> 집합" == <u>수신 가능한 "**메시지**</u> 집합" == "**퍼블릭 인터페이스**"

- **퍼블릭 인터페이스** → **타입** 결정
  - 동일 퍼블릭 인터페이스 제공 객체들 == 동일한 타입 객체들
- ⭐️객체에게 중요한 것은 <u>속성이 아닌 "**행동**"</u> ⭐️
  - 항상 " <u>객체가 **외부**에 제공하는 **행동**</u> " 에 초점을 두고 바라봐야함.
    - 동일한 상태 & **서로 다른** **퍼블릭 인터페이스** == 서로 다른 타입 
    - 서로 다른 상태 & **동일**한 **퍼블릭 인터페이스** == **동일 타입**

<br/>
<br/>

---
## 타입 계층
> _"일반화"/"특수화"와 관련하여 참고 : [상속의 용도](#--상속--의-용도)_

⁜ 타입 내부 객체들에 대해 <u>보다 상세한 기준</u>으로 묶어 새로운 타입 정의 <br/>→ 새로운 타입 : "기존 타입의 **부분 집합**"

<br/>

#### ＜ "포함 관계" 개념 ＞
> [개념 관점의 타입](#개념-관점) 참고
- "포함**하는**" 타입
  - {`외연`} : 더 **큰** 규모
  - {`내연`} : 더 **일반적**인 정의
- "포함**되는**" 타입
  - {`외연`} : 더 **작은** 규모
  - {`내연`} : 더 **특수적**인 정의

<br/>

#### ＜ "타입 계층" ＞
- 더 **일반적**인 타입 = **슈퍼타입**(`Supertype`)
- 더 **특수**한 타입 = **서브타입**(`Subtype`)

<br/>
 
#### 〚 "내연 / 외연 관점" - 일반화 & 특수화 〛
1. 내연
   - **일반화** : 타입의 정의를 **좀 더 보편적 & 추상적**으로 만드는 것
   - **특수화** : 타입의 정의를 **좀 더 구체적 & 문맥 종속적**으로 만드는 것
   - _일반적인 타입 정의 구체화 → 특수한 타입의 정의_
2. 외연
   - **일반적 타입**의 인스턴스 **집합** :: `슈퍼셋(Super Set)` → "`슈퍼타입(Super Type)`"
     - <u>특수한 타입의 인스턴스 집합</u>"**을" 포함**
   - **특수한 타입**의 인스턴스 **집합** :: `서브셋(Sub Set)` → "`서브타입(Sub Type)`"
     - <u>일반적 타입의 인스턴스 집합</u>"**에" 포함**

<br/>

### 객체 지향 프로그래밍 - 타입 계층
<u>객체의 타입을 결정하는 것은 퍼블릭 인터페이스</u>이기 때문에<br/>
**일반적**인 타입 ☞ "비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스"보다 <u>**더 일반적인** 퍼블릭 인터페이스를 가지는 객체들의 타입</u><br/>
**특수**한 타입 ☞ "비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스"보다 <u>**더 특수한** 퍼블릭 인터페이스를 가지는 객체들의 타입</u>

- `슈퍼타입(Super Type)` : "<u>서브타입</u>이 정의한 **퍼블릭 인터페이스**"를 **일반화**시켜 <u>상대적으로 **범용적**이고 **넒은** 의미</u>로 정의
  - 집합이 다른 집합의 **모든 멤버 포함**
  - 정의가 다른 타입보다 좀 더 일반적


- `서브타입(Sub Type)` : "<u>슈퍼타입</u>이 정의한 **퍼블릭 인터페이스**"를 **특수화**시켜 <u>상대적으로 **구체적**이고 **좁은** 의미</u>로 정의
  - 집합의 인스턴스들이 **더 큰 집합에 포함됨**
  - 정의가 다른 타입보다 좀 더 구체적

⁜ 즉, **서브타입**의 인스턴스는 <u>**슈퍼타입**의 인스턴스로 간주</u>되는 포함관계를 가지고 있다.

<br/>
<br/>

---
## 서브 클래싱 & 서브 타이핑
> ⁜ [`객체 지향 프로그래밍`] 부모 클래스가 "**슈퍼 타입**", 자식 클래스가 "**서브 타입**"의 역할을 하도록 클래스 사이의 관계 정의<br/>
> (**클래스**와 클래스 간의 **상속**을 활용하여 타입 계층을 구현하는 일반적인 방법)

#### ＜ "상속"을 사용해야하는 상황 ＞
- 상속 관계가 `is-a` **관계 모델**
  - 앞서 설명된 포함관계에 따라 " _[자식 클래스]는 [부모 클래스]이다._ "의 문맥이 어색하지 않아야한다.


- "클라이언트" 입장에서 <u>부모 클래스의 타입</u>으로 **자식 클래스** 사용 가능 :: `행동 호환성`
  - 클라이언트 입장에서 <u>부모 클래스와 자식 클래스의 차이점을 모른채로 사용</u>이 가능해야한다.

<br/>

### `is-a` 관계 모델
> _때에 따라 모순적인 관계가 형성될 수 있기에 해당 조건보다는 [행동 호환성](#행동-호환성)의 관점에서 결정하는 것이 바람직하다._

⁜ <span style="color:grey">이해하기 쉽게 예시는 "**새**" & "**펭귄**"으로 생각하자
<br/> `is-a`모델 측면에서 "펭귄은 새다"라는 개념이 받아들여지는데
<br/> 만약 **" _새는 날 수 있다_ "라는 행동**에 대해서 "펭귄은 날 수 있다."는 불가능한 개념이기 때문에 <br/>모순적인 상황이 발생한다.
</span>

- 어휘적인 정의가 아닌 "**기대되는 행동**"에 따라 타입 계층을 구성해야 한다.
  - **타입 계층의 의미**는 <u>"**행동**"이라는 문맥에 의해</u> 달라질 수 있다.
    - _ex. 새의 **울음**(행동)에 초점 ☞ 펭귄(서브타입) & 새(슈퍼타입) 가능_
    - _ex. 새의 **비행**(행동)에 초점 ☞ 펭귄(서브타입) & 새(슈퍼타입) 불가능_

⁜ _`is-a` 모델 조건이 우선 충족되더라도 상속 사용 예비 후보 정도로 생각하고 평가하자._

<br/>

### 행동 호환성
> 타입의 이름 사이에 "개념적 연관성"이 있더라도 <u>"행동적 연관성"이 없다면</u> [`is-a` 관계](#is-a-관계-모델)를 사용해선 안된다.

- <u>두 타입 사이에 **행동이 호환**될 경우에만</u> 타입 계층으로 묶어야 한다.
  - 기준 : ⭐️"**클라이언트**의 기대 행동"⭐️

> #### ＜ 사용해선 안될 모순적인 상속 문제 해결방법 ＞
> 1. **Override** & 내부 **미구현**
>    - 클라이언트가 **기대하는 행동을 충족시키지 못함**
>
>
> 2. **Override** & **예외** 발생
>    - 기본 조건인 클라이언트가 **차이를 모르고 사용해야 한다**는 **조건 위반**
>    - 예외 발생에 대해 인지해야 사용 가능해지는 것
>
>
> 3. 메서드 수정(**타입 검**사) & **조건문**을 통한 선택적 요청 유도
>    - `instanceOf` / `try-catch`등과 같은 방법으로 특정 타입이 아닐 때만 메시지 보내도록
>    - 확장 & 유연성 ❌ (`개방-폐쇄 원칙` 위반)

<br/>

### 클라이언트 기대에 따른 계층 분리
위 문제를 해결할 수 있는 방법은 <u>"**클라이언트의 기대**에 맞게" 상속 계층을 **분리**</u>하는 것 뿐

1. 클라이언트 기대에 따라 "**상속 계층**을 분리"
    - ```java
      /**
      * 날 수 있는 새를 명확하게 구분할 수 있도록 상속 계층 분리
      */
      class Bird {
      }
      class FlyingBird extends Bird {
          void fly(){
          }
      }
      class Penguin extends Bird {
      }
      
      /**
      * 날지 못해도 상관없이 "새"와 협력하는 경우 : Bird 타입 파라미터 ( FlyingBird & Penguin 둘 다 가능 )
      * 날 수 있는 새와 협력해야 하는 경우 : FlyingBird 타입만 파라미터로 올 수 있도록 선언 ( FlyingBird만 가능 )
      */
      public void flyBird(FlyingBird bird) {
          bird.fly();
      }
      ```
    - 명시적으로 분리되어 있기 때문에 <br/>
      잘못된 객체와 협력해서 기대 행동이 수행 되지 않거나 예외가 던져지는 상황을 해결할 수 있다. 


2. 클라이언트에 따라 "**인터페이스** 분리" + <u>재사용 가능</u>한 **<u>슈퍼타입</u> 퍼블릭 인터페이스** + "<u>**합성**</u>"
   - **특정 행동을 원하는 클라이언트**에게 "<u>특정 행동에 대한 메시지만 보여지게끔</u>" 인터페이스 **분리**
   <br/><br/>
   - 클라이언트에 따라 인터페이스를 분리 → 클라이언트 요구 변경에 대한 **영향 조절 가능**
     - 특정 인터페이스 사용 클라이언트 요구에 변화 → <u>해당 인터페이스 **구현 클래스**까지만</u> 영향
     - " <u>**`인터페이스 분리 원칙`(`ISP` : Interface Segregation Principle)**</u> "<br/><br/>
   - 하나의 비대한 인터페이스 → "<u>여러 개의 클라이언트에 특화</u>된 인터페이스로 **분리**" : 클라이언트 **의존성 ⬇** & 클라이언트 **독립성 ⬆**

⭐️ _**중요한 것**_  ⭐️<Br/>
설계가 반영할 "**도메인의 요구사항**" & "**클라이언트 요구 행동**"<br/>
→ _현실을 묘사하는 것에 초점을 맞추는 것이 아닌_<br/>
"**요구사항**을 **실용적**으로 **수용**하는 것"에 초점을 맞춰야 한다.

<br/>

### 서브 클래싱 & 서브 타이핑
- `서브 클래싱(Subclassing)` : "**코드 재사용**"을 위해 상속을 사용하는 경우
  - 행동 호환 불가 
  - 부모 클래스 대체 불가
  - `구현 상속(Implementation inheritance)` | `클래스 상속(Class inheritance)`


- `서브 타이핑(Subtyping)` : "**타입 계층 구성**"을 위해 상속을 사용하는 경우
  - 행동 호환
  - 자식 클래스의 부모 클래스 **대체 가능**
    - **부모** 클래스 : **슈퍼타입**
    - **자식** 클래스 : **서브타입**
  - **코드**로는 "슈퍼타입"으로 **정의**하지만 <u>**런 타임**</u>에 "서브타입"으로 **대체 가능**
  - `인터페이스 상속(Interface inheritance)`

"서브 클래싱"과 "서브 타이핑" 사이에서 가장 중요한 것은<br/>
"**행동 호환성**(**Behavioral Substitution**)"이자 "**퍼블릭 인터페이스**" 간의 차이이다.

이 말은 즉슨<br/>
항상 "<u>서브 타입</u>의 **퍼블릭 인터페이스**"가<br/>
<u>슈퍼 타입</u>에서 정의한 퍼블릭 인터페이스와 **동일하거나 더 많은 오퍼레이션**을 포함해야 한다는 것이다.

- 서브 타입이 <u>슈퍼 타입의 모든 행동을 동일하게 수행할 수 있어</u> 행동 호환성을 만족시켜야 한다.
  - `부모-자식 클래스 사이의 "행동 호환성"` == `자식 클래스의 "대체 가능성"`