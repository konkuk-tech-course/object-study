# Chapter 13. 서브 클래싱 & 서브 타이핑
> 올바른 목적 : " 코드 재사용이 아닌 타입 계층 구현하는 것 " 
> 
> → "**동일한 메시지**에 대해 **서로 다르게 행동**할 수 있는 <u>다형적인 객체</u>를 구현"하기 위해<br/>
> " **객체의 행동** "을 기반으로 타입 계층을 구성해야 한다.
#### ＜"상속"의 용도＞
1. " <u>타입 계층</u> 구현 "
   - **부모** 클래스 : <u>자식 클래스</u>의 **일반화**(**Generalization**)
     - 타입 계층 내에서 <u>일반적인 개념</u>을 구현
   - **자식** 클래스 : <u>부모 클래스</u>의 **특수화**(**Specialization**)
     - 타입 계층 내에서 <u>특수한 개념</u>을 구현

2. " 코드 <u>재사용</u> "
    - **점진적**으로 애플리케이션 **기능 확장**
    - 부모 자식 클래스간의 강한 결집 → <u>변경하기 어려운 코드</u>

>📍`객체 기반(Object-Based)` vs `객체 지향(Object-Oriented)`
> 
> 1. `상속` / `다형성` 지원 여부
>    - `객체 지향(Object-Oriented)` **⊂** `객체 기반(Object-Based)`
>    - `객체 기반(Object-Based)` : 지원 ❌
>      - _ex. Visual Basic, .._
>    - `객체 지향(Object-Oriented)` : 지원 ⭕️
>      - _ex. Java, C++, Ruby, C# .._<br/><br/>
> 2. `클래스` 사용 여부
>    - `객체 기반(Object-Based)` : 클래스가 존재 하지 않음 / Only 객체 사용
>      - "**프로토타입 기반 언어**(Prototype-Based Language)"
>    - `객체 지향(Object-Oriented)` : 클래스를 사용하는 방식

<br/>
<br/>


---

---
## 타입
### 개념 관점
> 우리가 인지하는 세상의 사물의 종류
> - 인간이 인지하는 객체들에 적용하는 개념/아이디어
> - 사물을 분류하기 위한 틀
>
> " _어떤 대상이 타입으로 분류_ " <br/>→ 해당 **대상** = 해당 타입의 "**인스턴스**"/"**객체**" 

- **심볼**(Symbol)
  - 타입에 **이름**을 붙인 것
- **내연**(Intension)
  - 타입의 **정의**
  - 타입에 속하는 객체들이 가지는 **공통적인 속성/행동**
- **외연**(Extension)
  - 타입에 속하는 객체들의 **집합**

<br/>

### 프로그래밍 언어 관점
> 연속적인 비트에 의미와 제약을 부여하기 위해 사용되는 도구
> - **데이터** → 0과 1로 구성된 **일련의 비트 조합**
>   - 일련의 비트 조합들 속에서 <u>의미를 부여하며 비트를 묶어내기 위한 **제약**과 **규칙**</u>


#### ＜"타입"의 목적＞
- 타입에 수행될 수 있는 "**유효한 오퍼레이션의 집합**"을 **정의**
  - ex. `+` 연산자
    - _Java : 원시형 숫자 타입 / 문자열 타입간 연산만 허용_
    - _C++/C# : **연산자 오버로딩** → 클래스 인스턴스간의 `+` 연산 가능_


- 타입에 <u>수행되는 오퍼레이션에 대해</u> "**미리 약속된 문맥**" 제공

<br/>

### 객체 지향 패러다임 관점
> - `개념` 관점 : "공통의 특징을 공유하는 대상들의 분류"
> - `프로그래밍 언어` 관점 : "동일 오퍼레이션을 적용할 수 있는 인스턴스들의 집합"
> 
> ⁜ "**타입**" == <u>호출 가능한 "**오퍼레이션**</u> 집합" == <u>수신 가능한 "**메시지**</u> 집합" == "**퍼블릭 인터페이스**"

- **퍼블릭 인터페이스** → **타입** 결정
  - 동일 퍼블릭 인터페이스 제공 객체들 == 동일한 타입 객체들
- ⭐️객체에게 중요한 것은 <u>속성이 아닌 "**행동**"</u> ⭐️
  - 항상 " <u>객체가 **외부**에 제공하는 **행동**</u> " 에 초점을 두고 바라봐야함.
    - 동일한 상태 & **서로 다른** **퍼블릭 인터페이스** == 서로 다른 타입 
    - 서로 다른 상태 & **동일**한 **퍼블릭 인터페이스** == **동일 타입**

<br/>
<br/>

---
## 타입 계층
> _"일반화"/"특수화"와 관련하여 참고 : [상속의 용도](#--상속--의-용도)_

⁜ 타입 내부 객체들에 대해 <u>보다 상세한 기준</u>으로 묶어 새로운 타입 정의 <br/>→ 새로운 타입 : "기존 타입의 **부분 집합**"

<br/>

#### ＜ "포함 관계" 개념 ＞
> [개념 관점의 타입](#개념-관점) 참고
- "포함**하는**" 타입
  - {`외연`} : 더 **큰** 규모
  - {`내연`} : 더 **일반적**인 정의
- "포함**되는**" 타입
  - {`외연`} : 더 **작은** 규모
  - {`내연`} : 더 **특수적**인 정의

<br/>

#### ＜ "타입 계층" ＞
- 더 **일반적**인 타입 = **슈퍼타입**(`Supertype`)
- 더 **특수**한 타입 = **서브타입**(`Subtype`)

<br/>
 
#### 〚 "내연 / 외연 관점" - 일반화 & 특수화 〛
1. 내연
   - **일반화** : 타입의 정의를 **좀 더 보편적 & 추상적**으로 만드는 것
   - **특수화** : 타입의 정의를 **좀 더 구체적 & 문맥 종속적**으로 만드는 것
   - _일반적인 타입 정의 구체화 → 특수한 타입의 정의_
2. 외연
   - **일반적 타입**의 인스턴스 **집합** :: `슈퍼셋(Super Set)` → "`슈퍼타입(Super Type)`"
     - <u>특수한 타입의 인스턴스 집합</u>"**을" 포함**
   - **특수한 타입**의 인스턴스 **집합** :: `서브셋(Sub Set)` → "`서브타입(Sub Type)`"
     - <u>일반적 타입의 인스턴스 집합</u>"**에" 포함**

<br/>

### 객체 지향 프로그래밍 - 타입 계층
<u>객체의 타입을 결정하는 것은 퍼블릭 인터페이스</u>이기 때문에<br/>
**일반적**인 타입 ☞ "비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스"보다 <u>**더 일반적인** 퍼블릭 인터페이스를 가지는 객체들의 타입</u><br/>
**특수**한 타입 ☞ "비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스"보다 <u>**더 특수한** 퍼블릭 인터페이스를 가지는 객체들의 타입</u>

- `슈퍼타입(Super Type)` : "<u>서브타입</u>이 정의한 **퍼블릭 인터페이스**"를 **일반화**시켜 <u>상대적으로 **범용적**이고 **넒은** 의미</u>로 정의
  - 집합이 다른 집합의 **모든 멤버 포함**
  - 정의가 다른 타입보다 좀 더 일반적


- `서브타입(Sub Type)` : "<u>슈퍼타입</u>이 정의한 **퍼블릭 인터페이스**"를 **특수화**시켜 <u>상대적으로 **구체적**이고 **좁은** 의미</u>로 정의
  - 집합의 인스턴스들이 **더 큰 집합에 포함됨**
  - 정의가 다른 타입보다 좀 더 구체적

⁜ 즉, **서브타입**의 인스턴스는 <u>**슈퍼타입**의 인스턴스로 간주</u>되는 포함관계를 가지고 있다.

<br/>
<br/>

---
## 서브 클래싱 & 서브 타이핑
> ⁜ [`객체 지향 프로그래밍`] 부모 클래스가 "**슈퍼 타입**", 자식 클래스가 "**서브 타입**"의 역할을 하도록 클래스 사이의 관계 정의<br/>
> (**클래스**와 클래스 간의 **상속**을 활용하여 타입 계층을 구현하는 일반적인 방법)

#### ＜ "상속"을 사용해야하는 상황 ＞
- 상속 관계가 `is-a` **관계 모델**
  - 앞서 설명된 포함관계에 따라 " _[자식 클래스]는 [부모 클래스]이다._ "의 문맥이 어색하지 않아야한다.


- "클라이언트" 입장에서 <u>부모 클래스의 타입</u>으로 **자식 클래스** 사용 가능 :: `행동 호환성`
  - 클라이언트 입장에서 <u>부모 클래스와 자식 클래스의 차이점을 모른채로 사용</u>이 가능해야한다.

<br/>

### `is-a` 관계 모델
> _때에 따라 모순적인 관계가 형성될 수 있기에 해당 조건보다는 [행동 호환성](#행동-호환성)의 관점에서 결정하는 것이 바람직하다._

⁜ <span style="color:grey">이해하기 쉽게 예시는 "**새**" & "**펭귄**"으로 생각하자
<br/> `is-a`모델 측면에서 "펭귄은 새다"라는 개념이 받아들여지는데
<br/> 만약 **" _새는 날 수 있다_ "라는 행동**에 대해서 "펭귄은 날 수 있다."는 불가능한 개념이기 때문에 <br/>모순적인 상황이 발생한다.
</span>

- 어휘적인 정의가 아닌 "**기대되는 행동**"에 따라 타입 계층을 구성해야 한다.
  - **타입 계층의 의미**는 <u>"**행동**"이라는 문맥에 의해</u> 달라질 수 있다.
    - _ex. 새의 **울음**(행동)에 초점 ☞ 펭귄(서브타입) & 새(슈퍼타입) 가능_
    - _ex. 새의 **비행**(행동)에 초점 ☞ 펭귄(서브타입) & 새(슈퍼타입) 불가능_

⁜ _`is-a` 모델 조건이 우선 충족되더라도 상속 사용 예비 후보 정도로 생각하고 평가하자._

<br/>

### 행동 호환성
> 타입의 이름 사이에 "개념적 연관성"이 있더라도 <u>"행동적 연관성"이 없다면</u> [`is-a` 관계](#is-a-관계-모델)를 사용해선 안된다.

- <u>두 타입 사이에 **행동이 호환**될 경우에만</u> 타입 계층으로 묶어야 한다.
  - 기준 : ⭐️"**클라이언트**의 기대 행동"⭐️

> #### ＜ 사용해선 안될 모순적인 상속 문제 해결방법 ＞
> 1. **Override** & 내부 **미구현**
>    - 클라이언트가 **기대하는 행동을 충족시키지 못함**
>
>
> 2. **Override** & **예외** 발생
>    - 기본 조건인 클라이언트가 **차이를 모르고 사용해야 한다**는 **조건 위반**
>    - 예외 발생에 대해 인지해야 사용 가능해지는 것
>
>
> 3. 메서드 수정(**타입 검**사) & **조건문**을 통한 선택적 요청 유도
>    - `instanceOf` / `try-catch`등과 같은 방법으로 특정 타입이 아닐 때만 메시지 보내도록
>    - 확장 & 유연성 ❌ (`개방-폐쇄 원칙` 위반)

<br/>

### 클라이언트 기대에 따른 계층 분리
위 문제를 해결할 수 있는 방법은 <u>"**클라이언트의 기대**에 맞게" 상속 계층을 **분리**</u>하는 것 뿐

1. 클라이언트 기대에 따라 "**상속 계층**을 분리"
    - ```java
      /**
      * 날 수 있는 새를 명확하게 구분할 수 있도록 상속 계층 분리
      */
      class Bird {
      }
      class FlyingBird extends Bird {
          void fly(){
          }
      }
      class Penguin extends Bird {
      }
      
      /**
      * 날지 못해도 상관없이 "새"와 협력하는 경우 : Bird 타입 파라미터 ( FlyingBird & Penguin 둘 다 가능 )
      * 날 수 있는 새와 협력해야 하는 경우 : FlyingBird 타입만 파라미터로 올 수 있도록 선언 ( FlyingBird만 가능 )
      */
      public void flyBird(FlyingBird bird) {
          bird.fly();
      }
      ```
    - 명시적으로 분리되어 있기 때문에 <br/>
      잘못된 객체와 협력해서 기대 행동이 수행 되지 않거나 예외가 던져지는 상황을 해결할 수 있다. 


2. 클라이언트에 따라 "**인터페이스** 분리" + <u>재사용 가능</u>한 **<u>슈퍼타입</u> 퍼블릭 인터페이스** + "<u>**합성**</u>"
   - **특정 행동을 원하는 클라이언트**에게 "<u>특정 행동에 대한 메시지만 보여지게끔</u>" 인터페이스 **분리**
   <br/><br/>
   - 클라이언트에 따라 인터페이스를 분리 → 클라이언트 요구 변경에 대한 **영향 조절 가능**
     - 특정 인터페이스 사용 클라이언트 요구에 변화 → <u>해당 인터페이스 **구현 클래스**까지만</u> 영향
     - " <u>**`인터페이스 분리 원칙`(`ISP` : Interface Segregation Principle)**</u> "<br/><br/>
   - 하나의 비대한 인터페이스 → "<u>여러 개의 클라이언트에 특화</u>된 인터페이스로 **분리**" : 클라이언트 **의존성 ⬇** & 클라이언트 **독립성 ⬆**

⭐️ _**중요한 것**_  ⭐️<Br/>
설계가 반영할 "**도메인의 요구사항**" & "**클라이언트 요구 행동**"<br/>
→ _현실을 묘사하는 것에 초점을 맞추는 것이 아닌_<br/>
"**요구사항**을 **실용적**으로 **수용**하는 것"에 초점을 맞춰야 한다.

<br/>

### 서브 클래싱 & 서브 타이핑
- `서브 클래싱(Subclassing)` : "**코드 재사용**"을 위해 상속을 사용하는 경우
  - 행동 호환 불가 
  - 부모 클래스 대체 불가
  - `구현 상속(Implementation inheritance)` | `클래스 상속(Class inheritance)`


- `서브 타이핑(Subtyping)` : "**타입 계층 구성**"을 위해 상속을 사용하는 경우
  - 행동 호환
  - 자식 클래스의 부모 클래스 **대체 가능**
    - **부모** 클래스 : **슈퍼타입**
    - **자식** 클래스 : **서브타입**
  - **코드**로는 "슈퍼타입"으로 **정의**하지만 <u>**런 타임**</u>에 "서브타입"으로 **대체 가능**
  - `인터페이스 상속(Interface inheritance)`

"서브 클래싱"과 "서브 타이핑" 사이에서 가장 중요한 것은<br/>
"**행동 호환성**(**Behavioral Substitution**)"이자 "**퍼블릭 인터페이스**" 간의 차이이다.

이 말은 즉슨<br/>
항상 "<u>서브 타입</u>의 **퍼블릭 인터페이스**"가<br/>
<u>슈퍼 타입</u>에서 정의한 퍼블릭 인터페이스와 **동일하거나 더 많은 오퍼레이션**을 포함해야 한다는 것이다.

- 서브 타입이 <u>슈퍼 타입의 모든 행동을 동일하게 수행할 수 있어</u> 행동 호환성을 만족시켜야 한다.
  - `부모-자식 클래스 사이의 "행동 호환성"` == `자식 클래스의 "대체 가능성"`


<br/>
<br/>

---
## 리스코프 치환 원칙 (Liskov Substitution Priciple :: LSP)
> - `서브 타입`은 기반 타입에 대해 "**대체 가능**"해야 한다.
> - **클라이언트**가 "<u>차이점을 인식하지 못한 채</u>" **기반 클래스의 인터페이스**를 통해 <u>서브 클래스를 이용</u>할 수 있어야 한다.

⁜ `Vector` - `Stack` / `Square` - `Rectangle` 의 관계가 대표적으로 리스코프 치환 원칙을 위반하는 예이다.
- 그저 구현을 재사용하고 있을 뿐 (서브클래싱)
- 어휘적인 `is-a`는 성립하지만 <br/>
  **클라이언트 관점**에서는 기반 클래스를 대체할 수 없기에 `is-a`의 관계가 성립되지 않는다.

<br/>

### 클라이언트 & 대체 가능성
리스코프 치환 원칙에서 가장 근본적인 전제는<br/>
" 자식 클래스가 **부모 클래스를 대체**하기 위해 <u>부모 클래스에 대한 **클라이언트의 가정**을 준수</u>한다. "이다.

_ex. `Vector` : 임의의 위치에 요소 추가 및 추출 **가능** / `Stack` : 임의의 위치에서의 조회 및 추가 **금지**<br/>
→ 클라이언트가 각각에 대해 **전송할 수 있는** <u>**메시지와** 기대하는 **행동**이 서로 다름</u><br/>
→ **서로 다른 클라이언트와 협력**해야 한다는 것<br/>
→ 단지 코드를 재사용하는 "**서브클래싱**"_

즉, 리스코프 치환 원칙에서의 **상속 관계**는 <u>클라이언트 관점</u>에서 자식 클래스가 **부모 클래스를 대체할 수 있을 때만** 올바른 것

- `is-a` 관계의 핵심 = 객체의 `행동`
  - <u>**개념**과 **속성** 측면에서만 상속 관계</u>를 정의할 경우,<br/>
  리스코프 치환 원칙을 위반하는 "**서브클래싱**"에 이르게 될 확률 높음.

<br/>

### "유연한 설계"의 기반, `리스코프 치환 원칙` 

※ `리스코프 치환 원칙` = **클라이언트**가 "어떤 자식 클래스와도" <u>안정적으로 협력할 수 있는 상속 구조</u>를 구현할 수 있는 **가이드라인**

<br/>

#### ⭐️ 높은 확장성 ⭐️
> `개방-폐쇄 원칙` 지원
- <u>클라이언트 **수정 없이**</u> 상속 계층 **확장 가능**
  - 기능 확장을 위해 **자식 클래스 추가** 
  - 새로운 자식 클래스를 추가하더라도<br/>
  클라이언트 입장에서 <u>**퍼블릭 인터페이스**의 행동 방식이 달라지지 않기 때문에</u> 협력이 가능하다.<br/><br/>
  - _"리스코프 치환 원칙 위반" == "**잠재적**인 개방-폐쇄 원칙 위반"_


> 📍**서브 타이핑** 관계 구현 핵심
> 
> 구현 방법과 상관없이 "**클라이언트 관점**"에서 "**슈퍼타입**"에 대해 기대하는 모든 "**행동**"이 "**서브타입**"에게도 "**동일하게 적용**"된다는 조건 준수<br/>
> ( _`Class` 기반, `Prototype` 기반 모두 서브 파이핑 관계를 구축할 수 있음 :: **클래스**가 중요한 것이 아님._  )

<br/>
<br/>

---
## 계약에 의한 설계 & 서브타이핑

- `계약에 의한 설계(Design By Contract :: DBC)` <br/>
    =〚 **클라이언트 - 서버** 〛**협력 관계** → `"의무(Obligation)" & "이익(Benefit)"으로 구성된 계약`의 관점에서 표현<br/>
  (_⌜[APPENDIX_A. 계약에 의한 설계](../summary/APPENDIX_A.md)⌟ 참고_)
  - **사전 조건**(Precondition) : "**클라이언트**"가 <u>정상적인 메서드 실행</u>을 위해 **만족**시켜야 하는 요소
  - **사후 조건**(Postcondition) : "**서버**"가 <u>클라이언트에게 **보장**</u>해야 하는 요소
  - **클래스 불변식**(Class Invariant) : 메서드 <u>실행 전/후에 **인스턴스**가 **만족**</u>시켜야 하는 요소
 
<br/>

서브타이핑 제약이 존재하는 `리스코프 치환 원칙`은 `계약에 의한 설계` 의 개념을 통해 더 명확히 표현할 수 있다.
- `서브타입`은 리스코프 치환 원칙을 만족시키기 위해서는 "`클라이언트`와 `슈퍼타입` 간의 체결된 계약"을 준수해야 한다.

<br/>

> 📍**Java** - `Assertion` "**단정문**" :: `assert ... ;`
> - 코드가 실행될 때 **반드시** <u>어떤 값일지 확신하는 값, 범위 또는 확실한 클래스의 상태 등</u>을 체크하여 <br/>프로그램의 신뢰성을 높이기 위해서 사용
>   - 코드의 **실행 시점**에서 <u>**확신하는 값**을 체크</u>하는 용도
>   - ⭐️ "**입력값**"의 검증이나 "**업무 로직**"의 체크 : `예외처리`를 사용<br/><br/>
> 
> 
> - **사전 조건**(pre-conditions) : **메소드를 호출할때 지켜야 하는 요구사항**을 체크합니다.<br/>(`private` 메소드에만 사용합니다.)
>   - 단, **클라이언트**는 <u>사전조건을 만족시키는 데이터</u>를 전달해야하는 책임이 있다.
>   - _ex._
>     ```java
>     assert screening != null && screening.getStartTime().isAfter(LocalDateTime.now()) ;
>     ```
> - **사후 조건**(post-conditions) : 코드를 **수행할 결과 확신**하는 값을 체크합니다.
>   - _ex._
>     ```java
>     assert screening != null && amount.isGreaterThanOrEqual(Money.ZERO) ;
>     ```
> - **클래스 불변성**(class invariants) : 객체가 **반드시 특정 상태에 있다고 확신**하는 것을 검증<br/><br/>
> 
> 
> - "`public` 메소드의 인자"에 대해서는 <u>Assertion을 사용하지 않는다</u>.<br/>( _어떤 클라이언트가 어떤 값을 넣을지 확신 불가능_ )
 
<br/>

### 서브타입 - 계약
> ⭐️ **클라이언트**는 <u>**기반 클래스(부모 클래스)**에 대한 사전조건만</u> 알고 있다는 사실

- 〚**사전** 조건〛<br/>
  _클라이언트는 슈퍼 타입에 대한 사전조건까지만 충족하면 책임을 완수하는 것_
  - 서브타입에 "**더 강력한** 사전 조건" 정의 ❌
  - 서브타입에 "**같거나 <u>더 약한</u>** 사전 조건" 정의 ⭕️
- 〚**사후** 조건〛
  - 서브타입에 "**더 약한** 사후 조건" 정의 ❌
  - 서브타입에 "**같거나 <u>더 강한</u>** 사후 조건" 정의 ⭕️

<br/>

⁜ 이해하기 쉽게 **데이터가 들어올때와 나올때의 허용 범위**이라고 생각하면 된다.

_ex. 사람의 몸 : `입 ~ 항문 전체 경로`(**슈퍼타입**) - `위`(**서브타입**)_
- 일단 음식이면 들어올 수 있음 <br/>
→ 슈퍼타입 `입 ~ 항문 전체 경로`의 서브 타입 `위`에서 <br/>
소화능력이 떨어져 <u>죽만 허용하는(**더 강한**) **사전조건**</u>이 정의되어 있으면 **예외가 발생**
  - 사전 조건 : 최대한 용인할 수 있는 수신 데이터(메시지) 범위


- 슈퍼타입 `입 ~ 항문 전체 경로`에서는 어지저찌 위를 거쳐 다음 단계로 보내면 되지만 <br/>
서브 타입 `위`에서는 <u>충분히 음식물이 분해되었는지(더 강한) 더 검사하고 보내야</u> 한다.<br/>
 만약 슈퍼타입보다 약하게 검사해서<br/>
<u>음식이 아닌 플라스틱/철이 들어왔는데도(**더 약한 사후 조건**) 넘긴다면</u> **문제가 생길 수 밖에** 없을 것이다.
  - 사후 조건 : 최소 조건만 충족하면 더 강하게 규제해도 기존 규제는 항상 통과됨

<br/>
<br/>

---
- **더 상세**한 계약에 의한 설계 : ⌜[APPENDIX_A. 계약에 의한 설계](../summary/APPENDIX_A.md)⌟ 참고
- **상속이 아닌 방법**으로 타입 계층 구현 : ⌜[APPENDIX_B. 타입 계층의 구현](../summary/APPENDIX_B.md)⌟ 참고