# Chapter 13. 서브 클래싱 & 서브 타이핑
> 올바른 목적 : " 코드 재사용이 아닌 타입 계층 구현하는 것 " 
> 
> → "**동일한 메시지**에 대해 **서로 다르게 행동**할 수 있는 <u>다형적인 객체</u>를 구현"하기 위해<br/>
> " **객체의 행동** "을 기반으로 타입 계층을 구성해야 한다.
#### ＜"상속"의 용도＞
1. " <u>타입 계층</u> 구현 "
   - **부모** 클래스 : <u>자식 클래스</u>의 **일반화**(**Generalization**)
     - 타입 계층 내에서 <u>일반적인 개념</u>을 구현
   - **자식** 클래스 : <u>부모 클래스</u>의 **특수화**(**Specialization**)
     - 타입 계층 내에서 <u>특수한 개념</u>을 구현

2. " 코드 <u>재사용</u> "
    - **점진적**으로 애플리케이션 **기능 확장**
    - 부모 자식 클래스간의 강한 결집 → <u>변경하기 어려운 코드</u>

>📍`객체 기반(Object-Based)` vs `객체 지향(Object-Oriented)`
> 
> 1. `상속` / `다형성` 지원 여부
>    - `객체 지향(Object-Oriented)` **⊂** `객체 기반(Object-Based)`
>    - `객체 기반(Object-Based)` : 지원 ❌
>      - _ex. Visual Basic, .._
>    - `객체 지향(Object-Oriented)` : 지원 ⭕️
>      - _ex. Java, C++, Ruby, C# .._<br/><br/>
> 2. `클래스` 사용 여부
>    - `객체 기반(Object-Based)` : 클래스가 존재 하지 않음 / Only 객체 사용
>      - "**프로토타입 기반 언어**(Prototype-Based Language)"
>    - `객체 지향(Object-Oriented)` : 클래스를 사용하는 방식

<br/>
<br/>


---

---
## 타입
### 개념 관점
> 우리가 인지하는 세상의 사물의 종류
> - 인간이 인지하는 객체들에 적용하는 개념/아이디어
> - 사물을 분류하기 위한 틀
>
> " _어떤 대상이 타입으로 분류_ " <br/>→ 해당 **대상** = 해당 타입의 "**인스턴스**"/"**객체**" 

- **심볼**(Symbol)
  - 타입에 **이름**을 붙인 것
- **내연**(Intension)
  - 타입의 **정의**
  - 타입에 속하는 객체들이 가지는 **공통적인 속성/행동**
- **외연**(Extension)
  - 타입에 속하는 객체들의 **집합**

<br/>

### 프로그래밍 언어 관점
> 연속적인 비트에 의미와 제약을 부여하기 위해 사용되는 도구
> - **데이터** → 0과 1로 구성된 **일련의 비트 조합**
>   - 일련의 비트 조합들 속에서 <u>의미를 부여하며 비트를 묶어내기 위한 **제약**과 **규칙**</u>


#### ＜"타입"의 목적＞
- 타입에 수행될 수 있는 "**유효한 오퍼레이션의 집합**"을 **정의**
  - ex. `+` 연산자
    - _Java : 원시형 숫자 타입 / 문자열 타입간 연산만 허용_
    - _C++/C# : **연산자 오버로딩** → 클래스 인스턴스간의 `+` 연산 가능_


- 타입에 <u>수행되는 오퍼레이션에 대해</u> "**미리 약속된 문맥**" 제공

<br/>

### 객체 지향 패러다임 관점
> - `개념` 관점 : "공통의 특징을 공유하는 대상들의 분류"
> - `프로그래밍 언어` 관점 : "동일 오퍼레이션을 적용할 수 있는 인스턴스들의 집합"
> 
> ⁜ "**타입**" == <u>호출 가능한 "**오퍼레이션**</u> 집합" == <u>수신 가능한 "**메시지**</u> 집합" == "**퍼블릭 인터페이스**"

- **퍼블릭 인터페이스** → **타입** 결정
  - 동일 퍼블릭 인터페이스 제공 객체들 == 동일한 타입 객체들
- ⭐️객체에게 중요한 것은 <u>속성이 아닌 "**행동**"</u> ⭐️
  - 항상 " <u>객체가 **외부**에 제공하는 **행동**</u> " 에 초점을 두고 바라봐야함.
    - 동일한 상태 & **서로 다른** **퍼블릭 인터페이스** == 서로 다른 타입 
    - 서로 다른 상태 & **동일**한 **퍼블릭 인터페이스** == **동일 타입**

<br/>
<br/>

---
## 타입 계층
> _"일반화"/"특수화"와 관련하여 참고 : [상속의 용도](#--상속--의-용도)_

⁜ 타입 내부 객체들에 대해 <u>보다 상세한 기준</u>으로 묶어 새로운 타입 정의 <br/>→ 새로운 타입 : "기존 타입의 **부분 집합**"

<br/>

#### ＜ "포함 관계" 개념 ＞
> [개념 관점의 타입](#개념-관점) 참고
- "포함**하는**" 타입
  - {`외연`} : 더 **큰** 규모
  - {`내연`} : 더 **일반적**인 정의
- "포함**되는**" 타입
  - {`외연`} : 더 **작은** 규모
  - {`내연`} : 더 **특수적**인 정의

<br/>

#### ＜ "타입 계층" ＞
- 더 **일반적**인 타입 = **슈퍼타입**(`Supertype`)
- 더 **특수**한 타입 = **서브타입**(`Subtype`)

<br/>
 
#### 〚 "내연 / 외연 관점" - 일반화 & 특수화 〛
1. 내연
   - **일반화** : 타입의 정의를 **좀 더 보편적 & 추상적**으로 만드는 것
   - **특수화** : 타입의 정의를 **좀 더 구체적 & 문맥 종속적**으로 만드는 것
   - _일반적인 타입 정의 구체화 → 특수한 타입의 정의_
2. 외연
   - **일반적 타입**의 인스턴스 **집합** :: `슈퍼셋(Super Set)` → "`슈퍼타입(Super Type)`"
     - <u>특수한 타입의 인스턴스 집합</u>"**을" 포함**
   - **특수한 타입**의 인스턴스 **집합** :: `서브셋(Sub Set)` → "`서브타입(Sub Type)`"
     - <u>일반적 타입의 인스턴스 집합</u>"**에" 포함**

<br/>

### 객체 지향 프로그래밍 - 타입 계층
<u>객체의 타입을 결정하는 것은 퍼블릭 인터페이스</u>이기 때문에<br/>
**일반적**인 타입 ☞ "비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스"보다 <u>**더 일반적인** 퍼블릭 인터페이스를 가지는 객체들의 타입</u><br/>
**특수**한 타입 ☞ "비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스"보다 <u>**더 특수한** 퍼블릭 인터페이스를 가지는 객체들의 타입</u>

- `슈퍼타입(Super Type)` : "<u>서브타입</u>이 정의한 **퍼블릭 인터페이스**"를 **일반화**시켜 <u>상대적으로 **범용적**이고 **넒은** 의미</u>로 정의
  - 집합이 다른 집합의 **모든 멤버 포함**
  - 정의가 다른 타입보다 좀 더 일반적


- `서브타입(Sub Type)` : "<u>슈퍼타입</u>이 정의한 **퍼블릭 인터페이스**"를 **특수화**시켜 <u>상대적으로 **구체적**이고 **좁은** 의미</u>로 정의
  - 집합의 인스턴스들이 **더 큰 집합에 포함됨**
  - 정의가 다른 타입보다 좀 더 구체적

⁜ 즉, **서브타입**의 인스턴스는 <u>**슈퍼타입**의 인스턴스로 간주</u>되는 포함관계를 가지고 있다.

<br/>
<br/>

---
