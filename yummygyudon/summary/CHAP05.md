# 5. 책임 할당하기

앞서 데이터 중심의 접근법을 사용할 경우, 행동보다 데이터를 먼저 결정하고<br/>
협력이라는 문맥을 벗어나 고립된 객체의 상태에 초점이 맞춰쳐 <br/>
<u>캡슐화를 위반</u>하기 쉬울 뿐더러 <br/>요소들 사이의 <u>결합도까지 높아져 코드 변경이 용이하지 않다</u>는 것을 알 수 있었다.

위와 같은 문제점을 해결하기 위한 가장 기본적인 방법은<br/>
데이터가 아닌 책임에 초점을 맞춘 설계이다.


## 책임 주도 설계 원칙
데이터 중심 설계에서 책임 중심의 설계로 전환하기 위해서는 다음과 같은 원칙을 따라야 한다.

### 데이터보다 "행동"
객체에게 진정으로 중요한 것은 데이터가 아니라 "<u>외부에 제공하는 행동</u>".<br/>
즉, 적절히 분리된 퍼블릭 인터페이스를 통해 수행하는 **객체의 책임**이다.

따라서 **데이터**는 <u>객체가 책임을 수행하는 데 필요한 재료를 제공할 뿐</u>이기 떄문에<br/>
데이터에 초점을 맞추지 않고 **행동**으로 무게 중심을 옮겨<br/>
객체의 캡슐화가 약화되지 않고<br/>
높은 응집도와 낮은 결합도를 가질 수 있도록 해야한다.<br/>

기본적으로 객체를 설계하기 위한 질문의 순서를 바꿔<br/>
"_**<u>이 객체가 수행해야 하는 책임은 무엇인가</u>**_"를 <u>먼저 결정한 후</u>에<br/>
"_<u>이 책임을 수행하기 위해 필요한 데이터가 무엇인가</u>_"를 결정하는 것이 바람직하다.

즉, **책임을 먼저 결정한 후에 객체의 상태를 결정**하라는 것이다.

<br/>

### "협력"이라는 문맥안에서 결정
데이터보다 책임(행동)을 중점으로 설계하는 것이 중요하다고 했지만<br/>
사실 할당된 책임이 적절한지는 <u>**협력**에 **적합**한 정도로 결정</u>되는 부분이기 때문에<br/>
**협력에 적합하지 않다면** 아무리 책임을 중점적으로 설계하더라도 <u>그 책임은 잘못된 것</u>이 되는 것이다.

따라서 책임은 객체의 입장에서 생각하는 것이 아닌 <u>객체가 참여하는 **협력의 입장**</u>에서 생각을 해보아야 한다.<br/>
다시 말해 <u>협력을 시작하는 주체</u>는 **메시지 전송자**이기 때문에<br/>
적절한 책임이란 <u>**메시지 전송자**에게 적합한 책임</u>이라는 것이고<br/>
이 말은 곧, 그 <u>메시지를 전송하는 **클라이언트 의도**</u>에 적합한 책임을 할당해야 한다는 것과 같다.

이와 같이 적합한 책임을 설정하기 위해서는 객체가 결정한 후에 메시지를 선택하지 않고
<u>**메시지를 결정한 후**에 이 **메시지를 적절하게 처리해줄 객체**를 선택</u>해야 한다.

**메시지**가 <u>클라이언트의 의도</u>를 표현한 것이라는 것을 잊지 말고<br/>
객체를 결정하기 전에 <u>객체가 **수신할 메시지**를 먼저 결정</u>한다는 점을 주목해야 한다.

<u>상황별로 다양한 클라이언트의 메시지</u>에 대해 대응하고<br/>
책임을 할당 받을 객체를 **메시지 수신 클래스**로 결정하게 되는 것이다.

이렇게 된다면
메시지를 먼저 결정하기 때문에<br/>
<u>전송자 관점</u>에서는 **수신자가 깔끔하게 캡슐화**되는 것이다.

결론적으로 책임 중심의 설계에서의 <br/>
협력이라는 문맥 안에서 객체가 **수행할 책임에 초점**을 맞춰야 한다.

> #### ⟪ 설계 흐름 ⟫
> 1. 시스템이 사용자에게 제공해야 하는 기능인 **시스템 책임을 파악**한다.
> 2. 시스템 책임을 **더 작은 책임으로 분할**한다.
> 3. 분할된 책임을 수행할 수 있는 **적절한 객체 또는 역할을 찾아 책임을 할당**한다.
> 4. 객체가 책임을 <u>수행하는 도중 다른 객체의 도움이 필요한 경우</u>, 이를 **책임질 적절한 객체 또는 역할을 찾는다**.
> 5. 해당 객체 또는 역할에게 책임을 할당함으로써 **두 객체가 협력**하게 한다.

<br/>
<br/>

---
하지만 책임에 초점을 맞춘 설계는 <u>어떤 객체에게 어떤 책임을 할당할지</u> 결정하기 어려울 뿐더러<br/>
<u>트레이드 오프를 계산</u>하여 설계해야 하기 때문에 어려움이 있다.

이 책임 주도 설계의 어려움을 해결해줄 수 있는 기반 패턴이 바론 **GRASP** 패턴이다.

## GRASP 패턴
> [ _**G**eneral **R**esponsibility **A**ssignment **S**oftware **P**atterns_ ]<br/>
> 
> : Object-Oriented 디자인의 핵심은 <u>각 객체에 책임을 부여하는 것</u>.<br/> 
> " **책임을 부여하는 원칙들을 말하고 있는 패턴** " <br/>
> 
> _<span style="color:grey">구체적인 구조는 없지만, 철학을 배울 수 있다.</span>_
 
<br/>

### 도메인 개념
설계 시작 전에 도메인에 대한 **개략적인 모습**을 그려 보는 것이 유용한데

도메인 안에는 수 많은 개념들이 존재하고 이를 책임 할당의 대상으로 사용하게 되면<br/>
해당 내용들을 **코드로 변환**하기 수월할 뿐더러<br/>
어떤 책임을 할당해야 할 때 가장 고민해야할 **후보군을 선정하는 척도**로서 사용될 수도 있고<br/>
그리고 어떤 책임들이 **협력 관계를 맺어야 하는지 가시화** 할 수 있기 때문이다.

*그렇다고 본 단계에서 개념들의 의미와 관계가 정확하고 구체적일 필요는 없다.<br/>
**설계의 시작점**으로서 사용되기 때문에<br/>
<u>너무 많은 시간을 들이는 것은 오히려 손해</u>라 할 수 있으며<br/>
**책임을 할당 받을 큼직한 객체들의 종류와 관계에 대해 유용한 정보만 제공할 수 있다면 충분**하다.*

> #### ⟪ 도메인 모델의 정답 ⟫
> *도메인 모델의 구조가 코드의 구조에 영향을 끼치는 것은 사실이나<br/>
> 유연성이나 재사용성 등과 같이 **실제 코드로 구현하는 과정에서 역으로 도메인의 개념이 바뀌는 것** 또한 사실이다.*
> 
> *즉, 올바른 도메인 모델이란 것은 존재하지 않고<br/>
> <u>구현에 도움이 되는 모델로서 실용적이면서 유용</u>하다면 그것이 정답인 것이다.*

<br/>

### 정보 전문가에게 책임 할당
> ⌜ _**INFORMATION EXPERT** ( **정보 전문가** )_ ⌟ 패턴  <br/><br/>- _in GRASP_ -

애플리케이션에서의 "기능"을 "책임"이라 생각하며
이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작한다.

여기서 메시지에 대해선
수신할 객체가 아닌 전송할 객체의 의도를 반영해서 결정해야하는데
결정 단계에서 던져볼 질문은 다음과 같다.

1. 메시지를 전송할 객체는 **무엇을 원하는가**?
2. 메시지를 **수신할 적합한 객체**는 무엇인가?

단, 객체가 <u>상태와 행동을 통합하여 **캡슐화**</u>되어야 하며<br/>
<u>자신의 상태를 스스로 처리하는 **자율적인 존재**</u>여야 한다.

위와 같은 방식으로<br/>
"**책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것**".<br/>
이것이 `INFORMATION EXPERT`패턴이며 GRASP 에서의 <u>객체에게 책임을 할당하는 **첫 번째 원칙**</u>이다.

- _정보와 행동을 최대한 가까운 곳에 위치_ → **캡슐화 유지**
- _필요한 정보를 가진 객체들로 책임 분산_ → **응집력 및 가독성 향상**
- _결합도 감소_ → **간결 & 유지보수 용이**

<br/>

단, `INFORMATION EXPERT`패턴은 객체가 자신이 소유하고 있는 정보와 관련된 작업을 수행한다고 표현하지만<br/>
정보와 데이터는 엄연히 다르다는 것을 주의해야 한다.

즉, 책임을 수행하는 객체가 <u>정보를 "알고"있다 해서 그 정보를 **"저장"하고 있을 필요는 없다**</u>는 것이고

바꿔 말해, 저장하지 않더라도 <u>해당 정보를 **제공할 수 있는 다른 객체**를 알고 있어 활용하거나 <br/>**필요한 정보를 계산**해서 제공할 수도 있다는 것</u>을 인지해야 한다.

<br/>

어쩌면 한 가지 업무에 대해서 세세하게 책임을 구분하여 파고 들어가다보면 그에 따라 **필요한 전문가가 많아**지면서<br/>
프로세스의 depth가 깊어질 순 있지만<br/>
다양한 상황에 대한 **유연한 대처**도 가능해지고 **높은 응집력**과 **낮은 결합도**를 실현할 수 있다.

<br/>

### 높은 응집도 & 낮은 결합도
> ⌜ _**LOW COUPLING** ( **낮은 결합도** )_ ⌟ 패턴 &<br/> 
> ⌜ _**HIGH COHESION** ( **높은 응집도** )_ ⌟ 패턴 <br/><br/>- _in GRASP_ -

Low Coupling.<br/>
즉, <u>**전체적인 결합도를 낮게 유지되도록 책임을 할당**</u>하라는 원리로서<br/>
**낮은 결합도**는 모든 설계 결정에서 염두에 둬야하는 원리이기에<br/>
"현재 애플리케이션의 책임 할당을 검토하거나 여러 대안이 있을 때"에<br/>
항상 이를 기억하며 낮은 결합도를 유지할 수 있는 설계를 선택해야 한다.

고로 결합도는<br/>
" _<u>**어떤 전문가 클래스들에 책임을 할당하여 서로 협력 관계를 맺는 것이 효율적인가를 고민할 때**</u>_ "의 해답이 된다.

예를 들자면 도메인 상에서 특정 객체가 **한 객체의 속성으로서 포함**되고 있을 때,<br/>
이 두 객체가 협력하게 하면<br/>
<u>다른 전문가 객체와의 결합도가 추가되지 않고도</u> **협력을 완성**시킬 수 있다.

<br/>

이를 High Cohesion 의 관점으로도 평가해 볼 수 있다.

High Cohesion.<br/>
즉, <u>**높은 응집도를 유지할 수 있도록 책임을 할당**</u>하라는 원리로서<br/>
**낮은 결합도**와 더불어 모든 설계 결정에서 염두에 둬야하는 원리이기에<br/>
"현재 애플리케이션의 책임 할당을 검토하거나 여러 대안이 있을 때"에<br/>
항상 이를 기억하며 높은 응집도를 유지할 수 있는 설계를 선택해야 한다.
<br/>

### 창조자에게 객체 생성 책임 할당
> ⌜ _**CREATOR** ( **창조자** )_ ⌟ 패턴  <br/><br/>- _in GRASP_ -
 
특정 객체를 생성해야 할 때,<br/>
어떤 객체에게 해당 객체 생성에 대한 책임을 할당해야할지 확인할 조건들은 아래와 같고<br/>
아래 조건을 최대한 많이 만족하는 후보 객체에게 "객체 생성 책임"을 할당 한다.
- (후보 객체가) 특정 객체를 **포함**하거나 **참조**한다.
- (후보 객체가) 특정 객체를 **기록**한다.
- (후보 객체가) 특정 객체를 **긴밀하게 사용**한다.
- (후보 객체가) 특정 객체를 **초기화하는 데 필요한 데이터를 가지고 있다**.( _<u>특정 객체에 대해 **정보 전문가**</u> 입장_ )

어떤 방식으로든 <u>생성되는 객체와 연결되거나 관련될 필요가 있는 객체</u>에 **해당 객체를 생성할 책임을 맡기는 것**으로<br/>
어차피 결합될 두 객체의 관계에서 사용하는 입장의 객체에게 책임을 할당하는 것이다.

<u>이미 결합되어 있는 객체들</u>이고 <u>이미 맺어져있는 관계</u>에서 생성 책임을 할당하는 것이기 때문에<br/>
**낮은 결합도**를 **유지**할 수 있다.


<br/>
<br/>

---

만약 변경에 취약한 클래스를 포함하고 있다면 개선할 필요가 있는데
여기서의 "변경에 취약한 클래스"란
코드를 수정해야 하는 이유가 하나 이상인 변동성이 큰 클래스이다.

변경이 취약하다면
서로 연관성이 없는 기능이나 데이터들이더라도 변동되는 상황에 대처하기 위해
하나의 클래스 안에 뭉쳐질 수 밖에 없어 응집도가 낮아진다.

이럴 경우, 변경의 이유에 따라 클래스를 분리하는 작업이 필수적인데
우선 클래스 내에서 변경 상황이 발생하는 패턴을 파악하는 것이 좋다.

<br/>

코드를 통해서 변경의 원인과 패턴을 파악하는 방법 중 하나는 <br/>
<u>**인스턴스 변수가 초기화되는 시점**</u>을 살펴보는 것이다.

응집도가 높다면 인스턴스 생성할 때, 모든 속성을 초기화하지만<br/>
응집도가 낮은 경우라면 얘기가 다르다.<br/>
응집도가 낮다면 <u>객체의 속성들이 서로 연관이 없을 확률이 높기 때문에</u> 속성들 중 **일부만 초기화**되는 상황이 발생한다.<br/>

초기화 시점을 살펴본 후,<br/>
이에 따라 <u>**함께 초기화되는 속성**을 기준</u>으로 **코드를 분리**하는 작업이 필요하다.

<br/>

또 하나의 방법은<br/>
<u>**메서드들이 인스턴스 변수를 사용하는 방식**</u>을 살펴보는 것이다.

<br/>

앞선 방법과 비슷한 맥락으로<br/>
응집도가 높다면 모든 메서드가 객체의 모든 속성을 사용할테지만<br/>
옹집도가 낮은 경우, 속성에 따라 사용되는 메서드 그룹이 나뉠 것이다.

메서드의 속성 사용 방식을 살펴본 후,<br/>
<u>나눠진 **속성 그룹**과 해당 그룹에 접근하는 **메서드 그룹**을 기준</u>으로 **코드를 분리**하는 작업이 필요하다.

### 타입 분리
한 클래스에 다양한 타입에 대한 객체들을 다루게 되면<br/>
자연스럽게 응집도가 낮아지게 되며 변경에 매우 취약한 클래스가 되어버린다.

그에 따라 변동성이 높은 속성에 대해 각각 분리된 타입으로 나누게되면<br/>
해당 타입들을 사용하는 클래스에서는 그룹별로 **명시** 할 수 있게된다.

하지만 이는 속성에 대해서만 분리한 것이고 결국 <u>이 분리된 다양한 타입들을 각각에 사용되는 메서드가 필요</u>하기 때문에
개선된 것은 크게 없다.

이에 따라 아래 이어질 내용이지만<br/>
이전 단원에서도 짚었던 것처럼 **다형성**을 활용하여 개선할 수 있다.

<br/>

### 다형성 분리 & 변경 보호
객체의 <u>**암시적인 타입**에 따라</u> **행동을 분기**해야 한다면<br/>
암시적인 타입을 <u>**명시적**인 클래스로 **정의**</u>하고 <u>행동을 나눔</u>으로써 응집도 문제를 해결할 수 있다.
( _명시적 클래스 :: 인터페이스로도 활용 가능_ )

즉, 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고<br/> 
**변화하는 행동**을 <u>**각 타입의 책임**으로 할당</u>하라는 것이다.

이를 바로 "디형성 패턴"이라 칭한다.
> ⌜ _**POLYMORPHISM** ( **다형성** )_ ⌟ 패턴  <br/><br/>- _in GRASP_ -

다형성을 기반으로 암시적인 타입을 명시 및 정의하여 유연성을 높였다면<br/>
그 타입에 소속된 세부 타입들에 대한 존재는 감춰져야 한다.

즉, 캡슐화가 되어야하며 해당 타입들이 사용되는 협력관계의 객체로부터의 변경을 방지해야 한다.

이처럼 변경을 캡슐화하도록 책임을 할당하는 것을<br/>
"변경 보호 패턴"이라 칭한다.
> ⌜ _**PROTECTED VARIATIONS** ( **변경 보호** )_ ⌟ 패턴  <br/><br/>- _in GRASP_ -


<br/>
<br/>

---

## 책임 주도 설계(R.D.D) 대안

책임 주도 설계는 익숙해지기 전까지 많은 시간과 노력이 필요하다.<br/>
가장 좋은 방법은 최대한 빠르게 목적한 기능을 수행하는 코드를 먼저 작성하고 시작하는 것이<br/>
아무 것도 없는 상태에서 책임과 협력에 관해 고민하는 것보다 <br/>
명확하게 책임들이 들어나기 때문에 훨씬 수월할 것이다.

이처럼 최대한 빨리 기능을 먼저 구현한 후에 개선하는 것을 **리팩토링**(**Refactoring**)이라 부른다.

주의할 점은 코드를 수정한 후에 <u>겉으로 드러나는 동작이 바뀌어서는 안된다</u>는 것이다.
캡슐화를 시키고, 응집도를 높이고 결합도를 낮추더라도 동작은 그대로 유지해야하는 것이 원칙이다.

### 메서드 응집도

- <u>**응집도**가 낮고 **이해**하기 어려우며 **재사용 및 변경**이 어려운 **긴** 코드</u> : "**몬스터 메서드**(**Monster Method**)" [ _마이클 페더스_ ]
