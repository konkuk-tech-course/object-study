# Appendix C. 동적인 협력, 정적인 코드

"**협력**"은 "**살아 움직이는 객체**"가 필요하고<br/>
모든 객체는 "**생애주기(Life Cycle)**"라는 것이 존재하여<br/>
살아있는 동안 <u>지속적으로 상태는 변화</u>하고<br/>
<u>외부의 자극</u>에 따라 <u>다양한 방식으로 행동</u>한다.

이러한 <u>변화와 움직임을 표현</u>하기 위해<br/>
" _객체지향 프로그래밍 언어_ "를 통한 <u>코드를 작성</u>하는 것이다.

아이러니 한 것은<br/>
작성한 코드이기에 정적이지만 객체는 **그 정적인 코드에 의해 동적으로 살아 움직인다**는 것이다. 

<br/>

즉, 프로그램은 "**고정**된 정적 코드 형식 안"에서 객체의 "모든 **변화 가능성**을 담아내야 하는 것"이다.

- `동적 모델 (Dynamic Model)` : 프로그램 "**실행 구조**"를 표현하는 모델
  - "`객체`" & "`협력`"


- `정적 모델 (Static Model)` : "**코드 구조**"를 담는 모델
  - "`타입`" & "`관계`"
    - **타입** : 객체를 분류하기 위한 틀
      - 동일한 타입에 속하는 객체들이 수행할 수 있는 **모든 행동들의 압축 표현**
      - "클래스 기반 객체지향 언어" (_ex. Java_) : 타입 표현 → "클래스"<br/>
      _일반적으로 '정적모델' → '클래스로 구성된 모델'_


"정적 모델(**타입&관계** :: 코드)"은 "동적 모델(**객체&협력**)"에 의해 주도돼야 하고<br/>
동적 모델이라는 토대 위에 세워져야 한다.

<br/>

그 중 고려해야 하는 가장 중요한 요소가 " <u>**변경**</u> "이다.

"**설계**가 필요한 이유"는 **변경을 수용할 수 있는 코드**를 만들기 위해서이고<br/>
"**변경을 수용할 수 있는 코드**"는 <u>단순 & 낮은 결합도 & 높은 응집도 & 중복없는 코드</u> 이다.

- <u>수정이 용이한</u> 코드
  - 높은 응집도
  - 낮은 결합도
  - 단순
- <u>유연한</u> 코드
  - 동일 코드 → 다양한 컨텍스트에서 동작 가능한 코드
  - 협력을 만드는 코드
  - 객체 사이의 다양한 조합 지원

" _수정과 확장에 용이하면서 유연한 코드_ "를 작성하기 위해서는<br/> 
단순 코드가 아닌 "**협력**"에 초점을 맞춰야 한다.

<br/>

> ⭐️ 좋은 설계는 객체 사이의 <u>**협력**과 **행동**을 표현하는 동적 모델</u>을 **기반**으로 해야한다. ⭐️<br/>
> ⭐️ 정적 모델은 **동적 모델**이 그려놓은 윤곽을 따라야 한다. (**동적 모델 ＞ 정적 모델**) ⭐️

<br/>
<br/>

---
## 동적 모델 & 정적 모델
### "헹동" → "코드"
객체의 **정적 모델**을 결정하는 것은 "<u>**협력**에 참여하는 객체의 **행동**</u>"<br/>
( _ex. `상속 계층` 구성 방식_ )

_"객체의 행동을 고려하지 않은 경우", `개방-폐쇄 원칙`을 위반하는 코드 양산_<br/>
→ `리스코프 치환 원칙`에 따라 "**클라이언트**"의 관점에서 "<u>**대체 가능성**</u>"을 제공하는 구조를 설계해야 한다.

<br/>

- ⭐️ 가장 중요한 요소 : 객체가 "외부에 제공하는 <u>**행동**</u>"
  - _**정적 모델**을 설계하는 이유 : 단지 <u>"**행동**"과 "**변경**"을 적절하게 수용할 수 있는 코드 구조 찾는 것</u>_


<br/>

### "변경" 고려
아무리 _"행동"의 측면에서 적절하게 정적 모델을 고려하더라도_<br/>
"<u>변경을 고려하지 않는다면</u>" **유지보수하기 어려운 코드**로 전락할 위험이 있다.

따라서 <br/>
동일한 행동을 제공하는 정적 모델이 있다면<br/>
항상 현재의 설계에서 <u>요구되는 변경을 자연스레 수용할 수 있는 설계</u>를 선택하는 것이 중요하다.<br/>
:: " **외부**에 **동일한 행동**을 제공 " & " 코드 **변경**에 대해 **유연한 대응** 가능 "한 설계 

<br/>
<br/>

---
## 도메인 모델 & 구현

- `도메인(Domain)` :  사용자가 프로그램을 사용하는 대상 영역
- `모델(Model)` : 지식을 선택적으로 단순화 하고 의식적으로 구조화한 형태

→ `도메인 모델(Domain Model)` : 사용자가 <u>프로그램을 **사용하는 대상 영역**에 대한 **지식**</u>을 **선택적**으로 "**단순화**"하고 의식적으로 "**구조화**"한 형태<br/>
(`개념`-`소프트웨어` 사이의 "**표현적 차이**"를 줄여 <u>이해하고 수정하기 쉬운 소프트웨어를 만들 수 있게끔</u> 해주는 장점이 있다.)

단, 중요한 점은 도메인 모델을 작성하는 것은 <br/>
프로그램 개발에 있어 <u>목표가 아닌 그저 **출발점**</u>이라고 생각해야 한다.<br/>
( _도메인 모델 : 단지 필요 개념의 이름, 의미, 관계에 대한 힌트 역할_ )

<br/>

⭐️ 소프트웨어 `기능` & 객체의 `책임` <br/>
→ 객체들의 협력으로 코드의 구조를 이끄는 것 == **<u>협력</u>을 <u>지원</u>하는 코드 구조**를 만드는 것<br/>
→ 구조를 주도하는 것은 "**행동**"이다.<br/>
→ 객체들의 **협력**이 **도메인 모델에 맞지 않다면** <u>필요한 몇 가지 개념만 남기고 도메인 모델을 과감히 수정할 줄 알아야 한다</u>.<br/>
( _프로그래밍 언어를 사용하여 도메인 모델을 통해 **개념간의 의사소통을 명확히 표현하기 어렵다**는 한계 - <u>**정적**인 분류 & **동적**인 의사소통 간의 불일치</u> 발생_  )

<br/>

### <u>타입 표현 전용</u> 클래스, `TYPE OBJECT` 패턴

큰 카테고리는 동일하지만 부분적으로 다른 부분이 존재하여<br/>
각 차이에 대한 변경에 대응해야 할 때,<br/>
모든 변경에 대해서 매번 새로운 클래스를 만들고 수정하는 일이 발생할 수 밖에 없다.

물론 다양한 방법으로 개선할 수 있지만<br/>
그 중에서 <u>"인터페이스/클래스"로 구현되지 않는</u> 경우,<br/>
"**타입을 표현**하는 클래스의 인스턴스로 구현"하여 차이점을 분류하는 방법이<br/>
"`TYPE OBJECT` 패턴"이다.

즉, 어떤 객체의 **타입을 표현하는 별도의 객체**를 이용해 타입을 구현해서<br/>
<u>어떤 인스턴스가 **다른 인스턴스의 타입을 표현**</u>하는 방법이 `TYPE OBJECT` 패턴인 것이다.

<br/>
<br/>

---
- 코드 ⇤ 도메인의 개념적 분류가 아닌 **"객체의 행동과 변경"**
- 전체 개발 주기 동안 동일 한 모양의 모델을 가지며 모두 행동과 변경이라는 요소에 영향을 받음
  - _**객체지향 패터다임** 장점 : **전체 주기** 동안 <u>동일한 설계 기법 & 모델링 방법</u> 사용_
    - `도메인`을 표현하는 방법 & `프로그램 코드`를 표현하는 방법 **동일**

즉, 객체지향 패러다임이 강력한 이유인 <br/>" _전체 개발 주기 동안 **동일한 <u>기법</u> 및 <u>표현력</u> 유지** 가능_ "에 따라

`분석-설계-구현` 단계 동안에 세부적인 내용에는 차이가 있을 지라도<br/>
**"설계"의 초점은 동일**하기 때문에
#### ⭐️ 우리는 소프트웨어를 설계할 때, " <u>모든 단계</u>에 걸쳐 "행동"과 "변경"에 초점을 맞추는 것 "에 신경쓰면 된다. ⭐️