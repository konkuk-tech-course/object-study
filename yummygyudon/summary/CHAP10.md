# Chapter 10. 상속과 코드 재사용

객체 지향에서 클래스를 재사용하는 방법으로는 두 가지가 있다.
- "**상속**" : **클래스 안에 정의된 인스턴스 변수와 메서드**를 <u>자동으로 새로운 클래스에 **추가**</u>하는 구현 방법
- "**합성**" : 새로운 클래스 **인스턴스 안**에 <u>**기존 클래스**의 인스턴스를 **포함**</u>시키는 방법

이렇게 코드를 재사용하려는 목표은 결국 중복된 코드를 제거하려는 것이 목적이다.

## 상속과 중복 코드

### `DRY` 원칙
> "**D**on't **R**epeat **Y**ourself" ( 반복하지 말아라 )<br/>
>  : 동일한 것. 즉, 동일한 지식을 중복하지 말아라. 
> 
> 모든 지식은 시스템 내에서 단일하고, 애매하지 않으며 확고히 믿을만한 표현 양식을 가져야 한다.
> 
> _* " **한 번, 단 한번**( **Once and Only Once** ) 원칙 "" / " **단일 지점 제어**( **Single-Point Control** ) 원칙 "이라고도 불린다._

**중복 코드**가 <u>변경</u>에 **방해 요소**가 되는 것이 <br/>
중복 코드 제거에 있어 가장 큰 이유이다.

비즈니스와 관련된 지식을 코드로 변환하게 되는데<br/>
지식은 항상 바뀌기에 그에 따라 코드도 변할 수 밖에 없다.<br/>
따라서 <u>새로운 코드를 추가하고 나면 언젠가는 변경될 것이라고 생각</u>하는 것이 바람직하다.

어떤 코드가 중복인지 찾는 것부터 시작해<br/>
찾더라도 모든 코드를 일관되게 수정해야 한다.<br/>
심지어 개별적으로 테스트했을 때도 동일한 결과가 나와야 한다.

이처럼 중복 코드로 인해 **수정과 테스트에 드는 비용**이 증가되고<br/>
시스템과 개발자 모두 **곤경에 처하는 상황**을 피할 수 없다.

여하튼 <u>중복 여부를 판단하는 기준</u>은 "**변경**"이다.<br/>
예를 들어,<br/>
**요구사항이 변경됨**에 따라 <u>두 코드를 함께 수정해야 한다면</u> **중복**이다.<br/>
당연히 함께 수정할 필요가 없으면 중복이 아니다.<br/>
단순히 코드의 모양은 가능성이기 때문에 모양만으로 판단해선 안된다.

즉, 중복 여부를 결정하는 기준은 "<u>**코드가 변경에 반응하는 방식**</u>"이다.

### 변경
중복 코드는 <u>**새로운 중복 코드**를 야기할 가능성</u>이 높다.<br/>
중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은<br/>
새로운 중복 코드를 추가하는 것뿐이기 때문이다.

이에 따라 새로운 중복 코드를 추가하는 과정에서<br/>
예상치 못하게 <u>**코드의 일관성**이 무너질 위험</u>이 도사리고 있으며<br/>
더 큰 문제는<br/>
중복 코드가 늘어날수록 <u>애플리케이션은 **변경**에 **취약**</u>해지고 <u>**버그 발생 가능성**</u>이 높아진다.<br/>
( _**코드의 양**과 **버그 발생 가능성**은 <u>비례</u>한다._ )

즉, 민첩한 변경을 위해서는 중복 코드 추가가 아닌 **제거가 필요**하다.<br/>
( _항상 코드를 DRY하게 만들기 위해 노력해야 한다._ )

<br/>

두 클래스 사이의 중복 코드를 제거하는 방법 중 하나는<br/>
" <u>클래스를 하나로 합치는 것</u> "이다.

즉, 코드가 중복되게끔 만든 분리의 기준 값을 찾아 하나의 타입으로 만드는 것이다.<br/>
하지만 타입으로 사용되는 클래스는 **낮은 응집도와 높은 결합도**라는 문제가 생기기 마련이다.

이 때, 사용되는 것이 바로 " <u>**상속**</u> "이다.

<br/>

### 상속 활용

상속의 기본 효용은<br/>
" <u>이미 존재하는 클래스와 유사한 클래스가 필요하다면 **코드를 복사하지 말고 상속을 활용**해 코드를 재사용하라는 것이다.</u> "

<br/>

단, 클래스의 상속 계층이 매우 깊어지게 된다면<br/>
<u>이해하기 어려운</u> **재사용을 위한 가정**들이 생겨난다.

**결합도**가 하나의 모듈이 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도인데<br/>
상속을 이용해 코드를 재사용할 경우,<br/>
부모 클래스를 만들 때 사용했던 많은 가정이나 추론 과정을<br/>
자식 클래스에서 **부모 클래스를 상속받아 만들 때도** 그 <u>모든 정보를 완벽히 이해</u>하고 있어야 한다.

즉, <u>알아야 하는 지식이 많을수록 결합도가 높아짐</u>에 따라<br/>
상속은 <u>부모 클래스와 자식 클래스 사이</u>의 **강한 결합도**가 형성되고 그만큼 **코드를 수정하기 어려워진다**.

어쩌면 당연하다.<br/>
Override 하는 방식은 부모 클래스의 것을 그대로 받아와서 사용하는 `super`를 사용하는 방식이다.

그렇기 때문에 Override를 하고자 할 때,<br/>
부모 클래스에서 사용하는 로직이 조금이라도 <u>자식 클래스에서 원하는 처리와 다를 경우</u><br/>
**새로운 중복코드가 생길 가능성**이 생긴다.

또한 만약 부모 클래스에서 **로직이 조금이라도 바뀐다면**<br/>
자식 클래스에서 기존의 부모 로직과 <u>강한 결합도를 가진 코드들</u>에 **문제가 생길 가능성**이 높다.

이와 같이<br/>
" _<u>**상속 관계로 연결된 자식 클래스**가 <u>부모 클래스의 변경에 취약</u>해지는 현상</u>_ "을<br/>
`취약한 기반 클래스 문제`라고 부른다.