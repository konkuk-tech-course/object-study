# Chapter 10. 상속과 코드 재사용

객체 지향에서 클래스를 재사용하는 방법으로는 두 가지가 있다.
- "**상속**" : **클래스 안에 정의된 인스턴스 변수와 메서드**를 <u>자동으로 새로운 클래스에 **추가**</u>하는 구현 방법
- "**합성**" : 새로운 클래스 **인스턴스 안**에 <u>**기존 클래스**의 인스턴스를 **포함**</u>시키는 방법

이렇게 코드를 재사용하려는 목표은 결국 중복된 코드를 제거하려는 것이 목적이다.

## 상속과 중복 코드

### `DRY` 원칙
> "**D**on't **R**epeat **Y**ourself" ( 반복하지 말아라 )<br/>
>  : 동일한 것. 즉, 동일한 지식을 중복하지 말아라. 
> 
> 모든 지식은 시스템 내에서 단일하고, 애매하지 않으며 확고히 믿을만한 표현 양식을 가져야 한다.
> 
> _* " **한 번, 단 한번**( **Once and Only Once** ) 원칙 "" / " **단일 지점 제어**( **Single-Point Control** ) 원칙 "이라고도 불린다._

**중복 코드**가 <u>변경</u>에 **방해 요소**가 되는 것이 <br/>
중복 코드 제거에 있어 가장 큰 이유이다.

비즈니스와 관련된 지식을 코드로 변환하게 되는데<br/>
지식은 항상 바뀌기에 그에 따라 코드도 변할 수 밖에 없다.<br/>
따라서 <u>새로운 코드를 추가하고 나면 언젠가는 변경될 것이라고 생각</u>하는 것이 바람직하다.

어떤 코드가 중복인지 찾는 것부터 시작해<br/>
찾더라도 모든 코드를 일관되게 수정해야 한다.<br/>
심지어 개별적으로 테스트했을 때도 동일한 결과가 나와야 한다.

이처럼 중복 코드로 인해 **수정과 테스트에 드는 비용**이 증가되고<br/>
시스템과 개발자 모두 **곤경에 처하는 상황**을 피할 수 없다.

여하튼 <u>중복 여부를 판단하는 기준</u>은 "**변경**"이다.<br/>
예를 들어,<br/>
**요구사항이 변경됨**에 따라 <u>두 코드를 함께 수정해야 한다면</u> **중복**이다.<br/>
당연히 함께 수정할 필요가 없으면 중복이 아니다.<br/>
단순히 코드의 모양은 가능성이기 때문에 모양만으로 판단해선 안된다.

즉, 중복 여부를 결정하는 기준은 "<u>**코드가 변경에 반응하는 방식**</u>"이다.

### 변경
중복 코드는 <u>**새로운 중복 코드**를 야기할 가능성</u>이 높다.<br/>
중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은<br/>
새로운 중복 코드를 추가하는 것뿐이기 때문이다.

이에 따라 새로운 중복 코드를 추가하는 과정에서<br/>
예상치 못하게 <u>**코드의 일관성**이 무너질 위험</u>이 도사리고 있으며<br/>
더 큰 문제는<br/>
중복 코드가 늘어날수록 <u>애플리케이션은 **변경**에 **취약**</u>해지고 <u>**버그 발생 가능성**</u>이 높아진다.<br/>
( _**코드의 양**과 **버그 발생 가능성**은 <u>비례</u>한다._ )

즉, 민첩한 변경을 위해서는 중복 코드 추가가 아닌 **제거가 필요**하다.<br/>
( _항상 코드를 DRY하게 만들기 위해 노력해야 한다._ )

<br/>

두 클래스 사이의 중복 코드를 제거하는 방법 중 하나는<br/>
" <u>클래스를 하나로 합치는 것</u> "이다.

즉, 코드가 중복되게끔 만든 분리의 기준 값을 찾아 하나의 타입으로 만드는 것이다.<br/>
하지만 타입으로 사용되는 클래스는 **낮은 응집도와 높은 결합도**라는 문제가 생기기 마련이다.

이 때, 사용되는 것이 바로 " <u>**상속**</u> "이다.

<br/>

### 상속 활용

상속의 기본 효용은<br/>
" <u>이미 존재하는 클래스와 유사한 클래스가 필요하다면 **코드를 복사하지 말고 상속을 활용**해 코드를 재사용하라는 것이다.</u> "

<br/>

단, 클래스의 상속 계층이 매우 깊어지게 된다면<br/>
<u>이해하기 어려운</u> **재사용을 위한 가정**들이 생겨난다.

**결합도**가 하나의 모듈이 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도인데<br/>
상속을 이용해 코드를 재사용할 경우,<br/>
부모 클래스를 만들 때 사용했던 많은 가정이나 추론 과정을<br/>
자식 클래스에서 **부모 클래스를 상속받아 만들 때도** 그 <u>모든 정보를 완벽히 이해</u>하고 있어야 한다.

즉, <u>알아야 하는 지식이 많을수록 결합도가 높아짐</u>에 따라<br/>
상속은 <u>부모 클래스와 자식 클래스 사이</u>의 **강한 결합도**가 형성되고 그만큼 **코드를 수정하기 어려워진다**.

어쩌면 당연하다.<br/>
Override 하는 방식은 부모 클래스의 것을 그대로 받아와서 사용하는 `super`를 사용하는 방식이다.

그렇기 때문에 Override를 하고자 할 때,<br/>
부모 클래스에서 사용하는 로직이 조금이라도 <u>자식 클래스에서 원하는 처리와 다를 경우</u><br/>
**새로운 중복코드가 생길 가능성**이 생긴다.

또한 만약 부모 클래스에서 **로직이 조금이라도 바뀐다면**<br/>
자식 클래스에서 기존의 부모 로직과 <u>강한 결합도를 가진 코드들</u>에 **문제가 생길 가능성**이 높다.

이와 같이<br/>
" _<u>**상속 관계로 연결된 자식 클래스**가 <u>부모 클래스의 변경에 취약</u>해지는 현상</u>_ "을<br/>
`취약한 기반 클래스 문제`라고 부른다.

<br/>

---
## 취약한 기반 클래스 문제
상속은 자식 클래스와 부모 클래스의 결합도를 높이고<br/>
그에 따라 강한 결합도로 인해 자식클래스는 <u>부모 클래스의 불필요한 세부사항</u>에 **종속**된다.

부모 클래스의 작은 변경에도 자식 클래스는 오류와 에러에 시달릴 수 밖에 없는데<br/>
이와 같이 " <u>상속이라는 문맥 안에서 결합도를 초래하는 문제점</u> "을 <br/>
" <u>**취약한 기반 클래스 문제**</u>(**Fragile Base Class Problem, Brittle Base Class Problem**) "이라고 한다.

물론 <u>자식 클래스를 점진적으로 추가해서 **기능을 확장**하는 데</u>는 용이하지만<br/>
높은 결합도로 인해 **부모 클래스를 점진적으로 개선하는 것이 어렵다**.

본래 객체를 사용하는 이유가<br/>
" _<u>구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화를 할 수 있다는 특징</u>_ "을 가지고<br/>
이에 따라 **변경에 의한 파급 효과를 제어**할 수 있기 때문이다.

하지만 상속을 사용하게 되면<br/>
부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 **자식 클래스는 변경에 의한 파급 효과가 발생하기 쉬워진다**.<br/>
즉,상속은 코드의 재사용을 위해 <u>**캡슐화의 장점**을 약화</u>시키고 <u>**구현에 대한 결합도**를 높임</u>으로써<br/>
객체지향의 강점을 반감시키는 것이다.

다양한 문제들 중 하나를 꼽아보자면<br/>
Override 시, `super`를 통해 부모 메서드의 내용을 상속받아 사용하게 되는데<br/>
부모 메서드의 구현을 직접적으로 보지 못하고 결국 퍼블릭 인터페이스를 사용하게 됨으로써<br/>
자칫 로직을 잘못짜면 <u>**중복 연산</u>이 발생**할 수 있는 위험성이 있다.

그렇다고 부모 클래스에서 해당 메서드를 삭제할 수도 없는 노릇이다.<br/>
이에 따라 발생할 수 있는 예외에 대해서 자식 메서드의 로직을 더 세세하게 짜는 방법도 있지만<br/>
이 또한 결국 중복 코드일 가능성도 높기 때문에<br/>
아이러니 하게도 **중복 코드를 줄이기 위해 중복 코드를 작성하는 모순**이 생길 수 있는 것이다.

> #### ⁜ 상속을 위한 경고
> 1. 자식 클래스의 메서드 안에서 `super` 참조를 이용해 **부모 클래스의 메서드를 직접 호출**할 경우,<br/> 
>   두 클래스는 **강하게 결합**된다.<br/>
>   <u>`super` 호출을 제거할 수 있는 방법</u>을 찾아 **결합도를 제거**하라.<br/></br>
> 2. 상속받은 <u>부모 클래스의 메서드</u>가 **자식 클래스**의 <u>내부 구조에 대한 규칙을 깨트릴 수 있다</u>.<br/></br>
> 3. 자식 클래스가 부모 클래스의 **메서드를 오버라이딩**할 경우 ,<br/>
>   부모 클래스가 **자신의 메서드를 사용하는 방법**에 <u>자식 클래스가 결합될 수 있다</u>.<br/></br>
> 4. 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 <u>구현을 영원히 변경하지 않거나</u>,<br/>
>   자식 클래스와 부모 클래스를 <u>동시에 변경</u>하거나 <br/>
>   둘 중 하나를 선택할 수 밖에 없다.
 
<br/>

