# Chapter 6. 메시지와 인터페이스

훌륭한 객체 지향 코드를 얻기 위해서는<br/>
클래스가 아닌 객체를 지향해야한다.

다시 말해 <u>협력 안에서 객체가 수행하는 **책임**에 초점</u>을 맞춰야 한다는 것이고<br/>
여기서 중요한 것은 책임은 <u>객체가 수신할 수 있는 **메시지의 기반**</u>이 된다는 점이다.

물론 클래스 자체도 애플리케이션을 구성하는 요소이기에 중요하지만<br/>
다소 정적인 클래스만 사용하기 보단<br/>
**메시지**를 통한 동적인 흐름으로 변환되는 것이 객체 지향 애플리케이션의 가장 중요한 요소라고 볼 수 있다.

> 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하라. - _Metz12_ -

자연스레 객체들이 수신하는 메시지들이 해당 객체의 퍼블릭 인터페이스(Public Interface)를 구성하게 되고<br/>
좋은 퍼블릭 인터페이스를 구성하기 위해선 <br/>책임 주도 설계와 더불어 유연하고 재사용 가능한 설계 원칙과 기법을 적용해야 한다.

<br/>

---
## 협력 & 메시지
### 클라이언트 - 서버 `Client - Server` 모델
앞선 단원들에서 메시지는 객체 사이의 렵력을 가능하게 하는 유일한 매개체로서 사용된다는 것을 알 수 있었다.<br/>
그에 따라 당연히 다른 객체에게 접근할 수 있는 유일한 방법 또한 메시지 전송뿐이라는 것이고<br/>
이와 같이 메시지를 매개로 하는 요청과 응답의 관계를 토대로 두 객체의 협력을 구성한다.

메시지 **전송**(**요청**) & 메시지 **수신 및 처리/반환**(**응답**)로 이루어진 관계를 "<u>**클라이언트-서버**</u>" 모델이라 칭하며<br/>
<u>요청하는 측</u>을 "**클라이언트**", <u>수신하는 측</u>을 "**서버**"라고 부른다.

협력의 경우, 서로 유기적으로 연결되어 있는 관계인만큼<br/>
어떠한 협력에서는 클라이언트의 역할을 맡지만 또 다른 협력에서는 서버의 역할을 맡으며<br/>
**두 가지의 역할을 동시에 수행**하는 경우가 일반적이다.

그렇기 때문에 수신하는 메시지 집합에 대해서만 초점을 맞출 것이 아니라 <br/>
본 클래스가 <u>외부에 전송하는 메시지 집합</u>에 대해서도 함께 고려해야 한다.

> #### ⁜ 메시지 
> : 메세지(message)는 객체들이 **협력하기 위해** 사용할 수 있는 <u>유일한 의사소통 수단</u>
> 
> - "**오퍼레이션 명**(operation name)"과 "**인자**(argument)"로 구성
> 
> ---
> #### ⁜ 메시지 전송 
> : 한 객체가 <u>다른 객체에게 도움을 요청하는 것</u><br/><br/>
> _* **메시지 패싱**(message **passing**) 이라고도 불림_<br/>
> _* `수신자` + `오퍼레이션 명` + `인자` | ex. `condition.isSatisfiedBy(screening)`_
> - 메시지를 **전송**하는 객체 : **메시지 전송자**(message **sender**)
> - 메시지를 **수신**하는 객체 : **메시지 수신자**(message **receiver**)
>
> ---
> #### ⁜ 메서드
>  : 메시지를 수신했을 때, 실제로 실행되는 함수 또는 프로시저<br/><br/>
> _* 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 로직이 달라질 수 있다.<br/>
> 예를 들어 `DiscountPolicy`인터페이스가 수신자이더라도 <br/>
> lazy binding된 실체화 객체가 무엇인지에 따라 이름이 같은 오퍼레이션 명이지만<br/> 
> 실행되는 내부 구현 로직은 상이하다._<br/><br/>

<br/>

메시지 전송자는 <u>수신자가 어떤 실체화 클래스의 인스턴스</u>인지, <u>어떤 방식으로 요청을 처리</u>하는지 모르더라도<br/>
<u>**어떤 메시지를 전송해야 하는지**만</u> 알면 되기 때문에<br/>
메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 **느슨하게 결합**될 수 있도록 한다.<br/>
( _이처럼 실행 시점에 lazy binding하는 방식으로 결합도를 낮추며 유연성과 확장성을 높인 코드가 탄생한다._ )

<br/>

### Public Interface 와 Operation의 관계
객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스(Public Interface)라 하는 것을 앞서 배웠다.

그리고 **오퍼레이션**(**Operation**)은 그 <u>퍼블릭 인터페이스에 포함된 메시지</u>라고 볼 수 있는데<br/>
다시 말해 <u>수행 가능한 어떤 행동에 대한 **추상화**</u>인 것이다.

이 또한 실체화될 경우 내부 로직은 서로 상이할 수 있으나 <br/>
추상화 타입으로 사용되는 인터페이스에 정의되어 있는 메서드가 오퍼레이션에 해당하는 것이다.

> #### ⁜ UML(Unified Modeling Language)에서의 오퍼레이션(Operation)
> 
> - Operation 이란 <u>실행하기 위해 객체가 호출될 수 있는 변환이난 정의에 관한 명세</u>이다.
> - **인터페이스의 각 요소**를 오퍼레이션이라 할 수 있다.
> - 오퍼레이션은 구현이 아닌 **추상화**이며 <u>메서드</u>는 **오퍼레이션을 구현**한 것이다.
>   - 메서드는 오퍼레이션에 대한 구현이며 **오퍼레이션과 연관된 알고리즘 또는 절차**를 명시한다.
> 
>_* 퍼블릭 인터페이스와 메시지의 관점에서는 "메서드 호출"보다는 "**오퍼레이션 호출**"이라는 말이 더 적절하다._
> 
> _-Larman04-_

<br/>

### 시그니처(Signature)

- <u>**오퍼레이션(메서드)의 이름**</u>과 <u>**파라미터 목록**</u>을 합쳐 "시그니처(signature)"라 부른다.
  - _실행 코드 없이 시그니처 정의_ = 오퍼레이션
  - _시그니처 구현_ = 메서드

하나의 오퍼레이션에 대해 <u>오직 1대1로 하나의 메서드만 존재한다면</u> **추상화의 필요성도 사라지기 때문에**<br/>
사실 오퍼레이션과 메서드를 구분할 필요가 없어진다.

하지만 다형성을 활용하기 위해서는 <br/>
하나의 오퍼레이션에 대해 다양한 메서드를 구현해야하만 하고
이에 따라 "오퍼레이션의 관점에서의 **다형성**"은 
<u>동일한 오퍼레이션 호출에 대해 **서로 다른 메서드들이 실행되는 것**</u>이라고 할 수 있다.

중요한 것은 객체가 수신할 수 있는 메시지가<br/>
퍼블릭 인터페이스를 비롯하여 포함된 오퍼레이션을 결정하게 된다는 점이고

자연스레 **퍼블릭 인터페이스**가 <u>그 객체의 품질을 결정</u>하게 되기 때문에<br/>
결국 **메시지**가 <u>객체의 품질을 결정</u>한다고 볼 수 있다.

<br/>
<br/>

---
## 인터페이스와 설계 품질
좋은 인터페이스는 **최소한**의 인터페이스와 **추상적**인 인터페이스라는 조건을 만족해야 한다.
- 최소한의 인터페이스 : 꼭 필요한 오퍼레이션만 포함
- 추상적인 인터페이스 : 어떻게 수행하는지가 아닌 무엇을 하는지를 표현

책임 주도 설계 방법은 메시지를 먼저 선택하여 협력과는 무관한 오퍼레이션이 스며드는 것을 방지하기 때문에
최소한의 오퍼레이션만 포함할 수 있게 된다.

또한, 객체가 메시지가 아닌 객체를 선택하게 함으로써
클라이언트의 의도를 메시지에 직관적으로 표현할 수 있게 되므로 추상적인 오퍼레이션을 사용할 수 있다.

더 나아가 퍼블릭 인터페이스의 품질을 더 향상 시킬 수 있는 원칙과 기법이 존재하는데
이는 아래와 같다.
- `디미터` 법칙
- 질문이 아닌 명령
- 의도가 보이는 인터페이스
- [`명령-쿼리` 분리](#명령-쿼리-분리)

### 디미터 법칙 (Law of Demeter)
협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙으로<br/>
객체의 <u>내부 구조에 강하게 결합되지 않도록</u> **협력 경로**를 **제한**하라는 내용이다.

> _낯선 자에게 말하지 말라. 오직 인접한 이웃하고만 말하라._ <br/>_-Larman04 & Metz12-_

본 법칙을 따르기 위해서는
클래스가 특정 조건을 만족하는 대상에게만 메시지를 전송하도록 설계 및 프로그래밍 해야한다.

> M이 <u>**메시지를 전송할 수 있는** 모든 객체</u>는 **아래 설명된 클래스의 인스턴스**여야 한다.<br/>
> - M의 **인자로 전달된** 클래스 ( == C 자체 )
> - **C**의 **인스턴스 변수**의 클래스
> > - `this`**객체**
> > - 메서드의 **매개변수**
> > - `this`의 **속성**
> > - `this`의 속성인 **컬렉션의 요소**
> > - <u>메서드 내</u>에서 생성된 **로컬 객체**
> 
> 단, `M에 의해 생성된 객체` | `M이 호출하는 메서드에 의해 생성된 객체` | `전역 변수로 선언된 객체` 모두 M의 인자로 간주한다.<br/><br/>
>_( 모든 클래스 : C , C에 구현된 모든 메서드 : M )_

<br/>

디미터 법칙을 따르게 된다면 메시지 수신자의 **내부 구조가 전송자에게 노출되지 않으며**,<br/>
메시지 전송자는 **수신자의 내부 구현에 결합되지 않기** 때문에<br/>
클라이언트와 서버 사이에 **낮은 결합도**를 유지할 수 있다.

하지만 우후죽순으로 해당 법칙을 수용하게 되면<br/> 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다는 점을 명심해야 한다.

<br/>

사실 캡슐화를 다른 관점에서 표현한 것이 디미터 법칙이라 볼 수 있는데<br/>
"캡슐화 원칙"은 클래스 **내부 구현을 감추는 것에 중점**을 둔다면<br/>
"디미터 법칙"은 협력하는 클래스의 **캡슐화를 지키기 위해** <u>접근해야 하는 요소를 제한</u>하는 것에 중점을 둔다.

(_ex. `screening.getMovie().getDiscountConditions()` 와 같이 <br/>
외부에서 전송자가 수신자의 내부 구조에 대해 연속적으로 물어보며 메시지의 이동 방향이 모두 보여지는 **기차 충돌(train wreek)** 코드는 <br/>
디미터 법칙을 어긴 코드이다._)

<br/>

### 명령 지향 ( Tell, Don't Ask )
사실 이 또한 디미터 법칙에서 강조하는 내용으로
훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.

메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후에도 메시지 수신자의 상태를 바꿔서는 안된다.

> 절차 지향 코드는 <u>순차적으로</u> 정보를 **얻은 후에 결정**하고<br/>
> 객체 지향 코드는 <u>객체에게 그것을 하도록</u> **시킨다**. <br/>_- Sharp00 -_

객체 지향의 기본은 **함께 변동성이 높은 정보와 행동**을 하나의 단위. 즉, <u>객체로 통합하는 것</u>인데<br/>
본 원칙을 따르게되면<br/>
**객체의 정보를 이용하는 행동**을 <u>객체 외부가 아닌 **내부**에 위치</u>시키기 때문에<br/>
**밀접하게 연관된 정보와 행동을 함께 가지는 객체**를 만들 수 있다.

그에 따라 메시지를 결정하다보면 자연스레 <u>정보 전문가에게 책임을 할당</u>하게 되고<br/>
<u>높은 응집도</u>를 가진 클래스를 완성시킬 가능성이 높다.

<br/>

객체가 수신할 메시지를 결정하는 과정에서 이러한 명령 원칙과 디미터 법칙을 고려하여<br/>
" _내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하진 않는지_ ", <br/>" _그에 따라 해당 객체가 책임져야 하는 특정 행동이 외부로 노출된 것은 아닌지_ " 를 따져본다면<br/>
퍼블릭 인터페이스의 품질을 향상시킬 수 있다.

하지만 단순히 객체에게 묻지 않고 명령만 한다고 해서 모든 문제가 해결되지 않는다.

훌륭한 인터페이스가 되기 위해선 명령 지향을 넘어 
객체가 _<u>어떻게 작업을 수행하는지를 보여주는 것이 아니라</u>_<br/>
객체가 <u>**무엇**을 하는지</u>를 객체의 <u>**의도가 보이도록** 하는 것</u>도 중요하다.

<br/>

### 의도가 보이는 인터페이스

만약 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓게 되면
발생하는 문제가 2가지 있다.

1. 메서드에 대해 제대로 **커뮤니케이션하지 못한다.**
   - 예를 들어 할인 조건을 파단하는 작업에 대해 `isSatisfiedByPeriod()`와 `isSatisfiedBySequence()` 같이 각 조건 클래스마다 다른 이름의 메서드를 가진다면<br/>동일 작업임에도 불구하고 메서드의 이름이 다르기 때문에 <br/>두 메서드의 내부 구현을 정확히 이해하지 못한다면 동일한 작업을 수행한다는 사실을 파악하기 힘들다.
2. 메서드 수준에서 **캡슐화를 위반**한다.
   - 위 예시를 다시 사용하자면 만약 할인 조건이 바뀌게 될 경우, <br/>
   객체를 변경하는 것 뿐만 아니라 호출하는 메서드까지 모두 수정해야하고<br/>
   더 나아가 협력하는 객체의 종류를 자세하게 알도록 강요하게 된다.

따라서 메서드의 이름을 짓기 위해서는 "어떻게"가 아닌 "**무엇을**" 하는지 드러내야 한다.<br/>

<br/>

> **무엇을 하느냐에 따라** 메서드 이름을 짓는 패턴 = "<u>**의도를 드러내는 선택자(Intention Revealing Selector)**</u>"

무엇을 하는지 나타내기 위해선 <br/>
해당 객체가 **협력 안에서 수행해야 하는 책임**에 관해 고민해야히고 **클라이언트의 의도에 부합하도록** 이름을 지어야 한다.

만약 동일한 메시지에 대해 다양한 처리 방법이 필요하다면 <br/>
애플리케이션 내에서 해당 요소에 대한 **추상화**가 필수적일텐데 <br/>
무엇을 하느냐에 초점을 맞춰 설계하게 되면 오히려 <u>하나의 타입으로 추상화하여 묶기가 더 용이</u>해지고<br/>
그에 따라 **유연한 협력**까지 얻을 수 있게 된다.

<br/>

위 개념을 확장하여 인터페이스 레벨까지 확장한 것이 "<u>**의도를 드러내는 인터페이스(Intention Revealing Interface)**</u>"이다.<br/>
이는 <u>구현과 관련된 모든 정보</u>를 **캡슐화**하고 객체의 **퍼블릭 인터페이스**에는 **<u>협력과 관련된 의도</u>만을 표현**해야 한다는 개념이다.

---
## 원칙의 함점
설계는 트레이트 오프의 산물이다.
혹 원칙들이 서로 충돌하는 경우에 원칙에 정당성을 부여하고 억지로 끼워 맞춘다면<br/>
설계는 일관성을 잃고 코드는 질서가 사라질 것이다.

따라서 상황에 부적합하다고 판단된다면 과감히 원칙을 무시하는 능력이 필요하다.

> #### ⁜ 디미터 법칙은 "하나의 도트(.)"를 강조하지 않는다.
> 앞서 살펴봤던 내용이지만<br/>
> 디미터 법칙은 기차 충돌 코드를 지양하는 법칙이다.
> 
> 하지만 Stream 혹은 IntStream 등을 사용하는 경우라면<br/>
> 중간 연산을 위해 도트를 2개 이상 쓰는 상황이 필수불가결해진다.
> 
> 즉, 디미터 법칙의 가장 중요한 기준은 **정보의 노출 수준**이다.<br/>
> 기차 충돌처럼 보이는 코드라도 <u>객체 내부 구현의 어떠한 정보도 외부로 노출하지 않는다면</u> 그것은 디미터 법칙을 **위반한 것이 아니다**.
> 
> 따라서 디미터 법칙을 사용할 땐,<br/> 
> 도트의 갯수를 기준으로 잡기 보단 **내부 구현 정보 노출 여부**를 확인하는 것이 올바르다.
> 
> ---
> #### ⁜ 결합도와 응집도의 충돌
> 아마 가장 많이 발생하는 트레이드 오프가 아닌가 싶다.
> 
> 일반적으로 어떤 객체의 상태를 물어본 후 **반환된 상태를 기반**으로 **결정**을 내리고<br/>
> 그 결정에 따라 객체의 <u>상태를 변경하는 코드</u>는 **명령 지향 스타일**로 변경해야 한다.
> 
> 그에 따라 <u>정보에 대한 책임을 전문가에게 위임</u>시키는 작업이 잦게 발생한다.<br/>
> 하지만 **모든 상황에서 맹목적으로 위임**하여 위임 메서드를 우후죽순 추가하게 되면<br/>
> <u>같은 퍼블릭 인터페이스 안에 **어울리지 않는 오퍼레이션들이 공존**하게 된다</u>.
> 
> 결과적으로 객체는 <u>상관없는 책임들을 한꺼번에 떠안게</u> 되기 때문에<br/>
> 오히려 **응집도가 낮아지게 된다**.
> 
> 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮고 변경에 취약해진다.<br/>
> 따라서 클래스는 <u>**하나의 변경 원인만**을 가지게 하는 것</u>이 바람직핟다.
> 
> 혹여 경우에 따라 특정 객체의 <u>캡슐화를 느슨하게 만들지라도</u> <br/>
> **협력에서의 결합도를 낮추는 것**이 전체적인 관점에서 더 좋은 결과를 낳을 수 있다는 것이다.

이 외에도 명령 지향으로 설계를 하더라도<br/>
가끔씩은 <u>묻는 것 외에는 다른 방법이 존재하지 않는 경우</u>도 발생한다.

객체에게 시키는 것이 항상 가능한 것이 아니기 때문에 아무리 명령을 지향한다더라도
**가끔씩은 물어보기도 해야한다**.

다시 말해, 설계는 트레이드 오프의 산물이며
<u>경우에 따라 원칙을 깨버릴 수 있는 역량</u> 또한 중요하다는 것이다.

<br/>

---
## 명령-쿼리 분리
바로 직전에 언급했듯이<br/>
가끔씩은 필요에 따라 물어야 한다는 사실에 기반하여<br/>
`명령-쿼리 분리`(Command-Query Separation) 원칙을 활용하게 된다면 도움이 된다.

- **루틴**(**Routine**) : 어떤 절차를 **묶어 호출** 가능하도록 <u>이름을 부여한 **기능 모듈**</u>
  - **프로시저**(Procedure)
    - 부수효과를 발생시킬 수 **있다**.
    - 값을 반환할 수 **없다**.
  - **함수**(Function)
    - 부수효과를 발생시킬 수 **없다**.
    - 값을 반환할 수 **있다**.

명령(Command)와 쿼리(Query)는 객체의 **인터페이스 측면**에서<br/>
프로시저와 함수를 부르는 또 다른 이름이다.

객체의 <u>상태를 **수정**하는 오퍼레이션</u>을 "**명령**"이라 하고,<br/>
객체와 <u>관련된 **정보를 반환**하는 오퍼레이션</u>을 "**쿼리**"라고 한다.

이에 따라 명령-쿼리 분리 원칙이라 함은<br/>
오퍼레이션은 "부수효과를 발생시키는 명령"과 "부수효과를 발생시키지 않는 쿼리"<br/>
둘 중 하나여야 한다는 원칙이다.

즉, 어떤 오퍼레이션도 <u>**명령임과 동시에 쿼리여선 안된다.**</u><br/>
( _"질문이 답변을 수정해서는 안된다."_ )

>- 객체의 <u>상태를 변경</u>하는 **명령** = **반환값 없어야 함**.(`void`)
>- 객체의 <u>정보를 반환</u>하는 **쿼리** = **상태를 변경하지 않아야 함**.
>
> _* 명령-쿼리 분리 원칙에 따라 작성된 객체의 인터페이스 : **명령-쿼리 인터페이스(Command-Query Interface)**_
 
명령-쿼리 인터페이스를 사용함으로써 객체의 **캡슐화**와 다양한 문맥에서의 **재사용을 보장**할 수 있다는 이점이 있다.


### 참조 투명성
명령과 쿼리를 엄격하게 분류하면 객체의 부수효과를 제어하기가 수월해진다.

쿼리는 객체의 <u>상태를 변경하지 않기</u> 때문에 <br/>
몇 번이고 **반복적으로 호출**하더라도 상관이 없고 **순서를 자유롭게 변경**할 수 있으며<br/>
명령이 개입하지 않는 한 쿼리의 값은 변경되지 않기 때문에 쿼리 결과를 **예측하기 수월**해진다.

명령과 쿼리를 분리함에 따라 <br/>
명령형 언어 안에서 **참조 투명성**(**Referential Transparency**)의 장점을 제한적으로나마 누릴 수 있게 된다.

> #### ⁜ 참조 투명성(Referential Transparency)
> 우선 컴퓨터와 수학에서의 가장 큰 차이점은 "**부수효과(side effect) 존재 유무**"이다.
> 
> 컴퓨터 프로그램에서 부수효과를 발생시키는 대표적인 문법은 바로 "대입문"과 "함수"이다.
> `x = x+1`의 식만 보더라도 
> 수학에서는 `x`의 값을 초기화한 후에는 값을 변경하는 것이 불가능하지만
> 프로그램에서는 대입문으로서 작용하기 때문에 다른 값으로 변경하는 것이 가능해진다.
> 
> 이러한 변동성과 그에 따른 부수효과에 의해 결과값이 매번 달라질 수 있다는 특징이 있다.
> 부수효과를 논할 때 빠지지 않는 개념이 바로 참조 투명성이다.
> > : " <u>어떤 표현식 e가 있을 때, 모든 e를 **e의 값으로 바꾸더라도 결과가 달라지지 않는** 특성</u> "
> > ```
> > f(1) + f(1) = 6
> > f(1) * 2 = 6
> > f(1) - 1 = 2 
> > ```
> > 다음과 같은 식이 있을 때, 모든 `f(1)`을 값인 `3`으로 바꾸더라도 수식의 결과가 달라지지 않는다.<br/>
> > 이를 바로 "참조 투명성을 만족한다."고 표현할 수 있다.
> >  ```
> > 3 + 3 = 6
> > 3 * 2 = 6
> > 3 - 1 = 2
> > ```
> > 어떤 값이 변하지 않는 성질을 **불변성**(**Immutability**)이라 한다.<br/>
> > 바꿔말하자면 <u>부수효과가 발생하지 않는</u> 특성인 것이다.
> > 
> > ✓ **불변성** → **부수효과 방지** → **참조 투명성 만족**
> 
> 이러한 참조 투명성을 만족하는 식은 2가지 장점을 제공한다.
> - 모든 함수를 알고 있는 <u>하나의 결과값으로 대체</u>할 수 있기 때문에 **식을 계산하기 쉽다**.
> - 모든 곳에서 함수의 결과값이 동일하기 때문에 식의 <u>순서를 변경하더라도</u> **각 식의 결과는 달라지지 않는다**.

<br/>

객체지향 패러다임은 객체의 **상태 변경**이라는 <u>부수효과를 기반</u>으로 하기 때문에<br/>
참조 투명성은 예외에 가까울 정도로 만족시키기 어려운 구조이다.

허지만 명령-쿼리 분리 원칙을 사용함으로써<br/>
부수효과를 가지는 명령과 가지지 않는 쿼리를 명백하게 분리하기 때문에<br/>
조금이나마 참조 투명성의 장점을 누릴 수 있게 되는 것이다.

<br/>

> #### ⁜ 함수형 프로그래밍
> 부수효과를 기반으로 하는 프로그래밍 방식을 **명령형 프로그래밍( Imperative Programming )** 이라 칭하고<br/>
> 상태를 변경시키는 연산들을 적절한 순서대로 나열함으로써 프로그램을 작성하는 프로그래밍 방식이다.
> 
> 대부분의 객체 지향 언어들 또한 메시지에 의한 객체 상태 변경에 초점을 두기에 명령형 프로그래밍 언어라 볼 수 있다.
> 
> 그에 반해<br/>
> 최근 주목받는 **함수형 프로그래밍( Functional Programming )** 은<br/>
> <u>부수효과가 존재하지 않는</u> 수학적인 함수에 기반한다.
> 
> 부수효과가 존재하지 않기 때문에 **참조 투명성의 장점**을 **극대화**할 수 있으며<br/>
> 명령형 프로그래밍과 다르게 프로그램의 **실행 결과를 이해하고 예측하기가 훨씬 수월**하다.
> 
> 나아가 **병렬 처리**에 있어 유리하다는 장점이 있어<br/>
> 최근 다양한 객체 지향 언어들이 함수형 프로그래밍 패러다임을 접목시키고 있는 추세이다.

<br/>