# Chapter 6. 메시지와 인터페이스

훌륭한 객체 지향 코드를 얻기 위해서는<br/>
클래스가 아닌 객체를 지향해야한다.

다시 말해 <u>협력 안에서 객체가 수행하는 **책임**에 초점</u>을 맞춰야 한다는 것이고<br/>
여기서 중요한 것은 책임은 <u>객체가 수신할 수 있는 **메시지의 기반**</u>이 된다는 점이다.

물론 클래스 자체도 애플리케이션을 구성하는 요소이기에 중요하지만<br/>
다소 정적인 클래스만 사용하기 보단<br/>
**메시지**를 통한 동적인 흐름으로 변환되는 것이 객체 지향 애플리케이션의 가장 중요한 요소라고 볼 수 있다.

> 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하라. - _Metz12_ -

자연스레 객체들이 수신하는 메시지들이 해당 객체의 퍼블릭 인터페이스(Public Interface)를 구성하게 되고<br/>
좋은 퍼블릭 인터페이스를 구성하기 위해선 <br/>책임 주도 설계와 더불어 유연하고 재사용 가능한 설계 원칙과 기법을 적용해야 한다.

<br/>

## 협력 & 메시지
### 클라이언트 - 서버 `Client - Server` 모델
앞선 단원들에서 메시지는 객체 사이의 렵력을 가능하게 하는 유일한 매개체로서 사용된다는 것을 알 수 있었다.<br/>
그에 따라 당연히 다른 객체에게 접근할 수 있는 유일한 방법 또한 메시지 전송뿐이라는 것이고<br/>
이와 같이 메시지를 매개로 하는 요청과 응답의 관계를 토대로 두 객체의 협력을 구성한다.

메시지 **전송**(**요청**) & 메시지 **수신 및 처리/반환**(**응답**)로 이루어진 관계를 "<u>**클라이언트-서버**</u>" 모델이라 칭하며<br/>
<u>요청하는 측</u>을 "**클라이언트**", <u>수신하는 측</u>을 "**서버**"라고 부른다.

협력의 경우, 서로 유기적으로 연결되어 있는 관계인만큼<br/>
어떠한 협력에서는 클라이언트의 역할을 맡지만 또 다른 협력에서는 서버의 역할을 맡으며<br/>
**두 가지의 역할을 동시에 수행**하는 경우가 일반적이다.

그렇기 때문에 수신하는 메시지 집합에 대해서만 초점을 맞출 것이 아니라 <br/>
본 클래스가 <u>외부에 전송하는 메시지 집합</u>에 대해서도 함께 고려해야 한다.

> #### ⁜ 메시지 
> : 메세지(message)는 객체들이 **협력하기 위해** 사용할 수 있는 <u>유일한 의사소통 수단</u>
> 
> - "**오퍼레이션 명**(operation name)"과 "**인자**(argument)"로 구성
> 
> ---
> #### ⁜ 메시지 전송 
> : 한 객체가 <u>다른 객체에게 도움을 요청하는 것</u><br/><br/>
> _* **메시지 패싱**(message **passing**) 이라고도 불림_<br/>
> _* `수신자` + `오퍼레이션 명` + `인자` | ex. `condition.isSatisfiedBy(screening)`_
> - 메시지를 **전송**하는 객체 : **메시지 전송자**(message **sender**)
> - 메시지를 **수신**하는 객체 : **메시지 수신자**(message **receiver**)
>
> ---
> #### ⁜ 메서드
>  : 메시지를 수신했을 때, 실제로 실행되는 함수 또는 프로시저<br/><br/>
> _* 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 로직이 달라질 수 있다.<br/>
> 예를 들어 `DiscountPolicy`인터페이스가 수신자이더라도 <br/>
> lazy binding된 실체화 객체가 무엇인지에 따라 이름이 같은 오퍼레이션 명이지만<br/> 
> 실행되는 내부 구현 로직은 상이하다._<br/><br/>

<br/>

메시지 전송자는 <u>수신자가 어떤 실체화 클래스의 인스턴스</u>인지, <u>어떤 방식으로 요청을 처리</u>하는지 모르더라도<br/>
<u>**어떤 메시지를 전송해야 하는지**만</u> 알면 되기 때문에<br/>
메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 **느슨하게 결합**될 수 있도록 한다.<br/>
( _이처럼 실행 시점에 lazy binding하는 방식으로 결합도를 낮추며 유연성과 확장성을 높인 코드가 탄생한다._ )

<br/>

### Public Interface 와 Operation의 관계
객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스(Public Interface)라 하는 것을 앞서 배웠다.

그리고 **오퍼레이션**(**Operation**)은 그 <u>퍼블릭 인터페이스에 포함된 메시지</u>라고 볼 수 있는데<br/>
다시 말해 <u>수행 가능한 어떤 행동에 대한 **추상화**</u>인 것이다.

이 또한 실체화될 경우 내부 로직은 서로 상이할 수 있으나 <br/>
추상화 타입으로 사용되는 인터페이스에 정의되어 있는 메서드가 오퍼레이션에 해당하는 것이다.

> #### ⁜ UML(Unified Modeling Language)에서의 오퍼레이션(Operation)
> 
> - Operation 이란 <u>실행하기 위해 객체가 호출될 수 있는 변환이난 정의에 관한 명세</u>이다.
> - **인터페이스의 각 요소**를 오퍼레이션이라 할 수 있다.
> - 오퍼레이션은 구현이 아닌 **추상화**이며 <u>메서드</u>는 **오퍼레이션을 구현**한 것이다.
>   - 메서드는 오퍼레이션에 대한 구현이며 **오퍼레이션과 연관된 알고리즘 또는 절차**를 명시한다.
> 
>_* 퍼블릭 인터페이스와 메시지의 관점에서는 "메서드 호출"보다는 "**오퍼레이션 호출**"이라는 말이 더 적절하다._
> 
> _-Larman04-_

<br/>

### 시그니처(Signature)

- <u>**오퍼레이션(메서드)의 이름**</u>과 <u>**파라미터 목록**</u>을 합쳐 "시그니처(signature)"라 부른다.
  - _실행 코드 없이 시그니처 정의_ = 오퍼레이션
  - _시그니처 구현_ = 메서드

하나의 오퍼레이션에 대해 <u>오직 1대1로 하나의 메서드만 존재한다면</u> **추상화의 필요성도 사라지기 때문에**<br/>
사실 오퍼레이션과 메서드를 구분할 필요가 없어진다.

하지만 다형성을 활용하기 위해서는 <br/>
하나의 오퍼레이션에 대해 다양한 메서드를 구현해야하만 하고
이에 따라 "오퍼레이션의 관점에서의 **다형성**"은 
<u>동일한 오퍼레이션 호출에 대해 **서로 다른 메서드들이 실행되는 것**</u>이라고 할 수 있다.

중요한 것은 객체가 수신할 수 있는 메시지가<br/>
퍼블릭 인터페이스를 비롯하여 포함된 오퍼레이션을 결정하게 된다는 점이고

자연스레 **퍼블릭 인터페이스**가 <u>그 객체의 품질을 결정</u>하게 되기 때문에<br/>
결국 **메시지**가 <u>객체의 품질을 결정</u>한다고 볼 수 있다.