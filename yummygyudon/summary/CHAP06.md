# Chapter 6. 메시지와 인터페이스

훌륭한 객체 지향 코드를 얻기 위해서는<br/>
클래스가 아닌 객체를 지향해야한다.

다시 말해 <u>협력 안에서 객체가 수행하는 **책임**에 초점</u>을 맞춰야 한다는 것이고<br/>
여기서 중요한 것은 책임은 <u>객체가 수신할 수 있는 **메시지의 기반**</u>이 된다는 점이다.

물론 클래스 자체도 애플리케이션을 구성하는 요소이기에 중요하지만<br/>
다소 정적인 클래스만 사용하기 보단<br/>
**메시지**를 통한 동적인 흐름으로 변환되는 것이 객체 지향 애플리케이션의 가장 중요한 요소라고 볼 수 있다.

> 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하라. - _Metz12_ -

자연스레 객체들이 수신하는 메시지들이 해당 객체의 퍼블릭 인터페이스(Public Interface)를 구성하게 되고<br/>
좋은 퍼블릭 인터페이스를 구성하기 위해선 <br/>책임 주도 설계와 더불어 유연하고 재사용 가능한 설계 원칙과 기법을 적용해야 한다.

<br/>

---
## 협력 & 메시지
### 클라이언트 - 서버 `Client - Server` 모델
앞선 단원들에서 메시지는 객체 사이의 렵력을 가능하게 하는 유일한 매개체로서 사용된다는 것을 알 수 있었다.<br/>
그에 따라 당연히 다른 객체에게 접근할 수 있는 유일한 방법 또한 메시지 전송뿐이라는 것이고<br/>
이와 같이 메시지를 매개로 하는 요청과 응답의 관계를 토대로 두 객체의 협력을 구성한다.

메시지 **전송**(**요청**) & 메시지 **수신 및 처리/반환**(**응답**)로 이루어진 관계를 "<u>**클라이언트-서버**</u>" 모델이라 칭하며<br/>
<u>요청하는 측</u>을 "**클라이언트**", <u>수신하는 측</u>을 "**서버**"라고 부른다.

협력의 경우, 서로 유기적으로 연결되어 있는 관계인만큼<br/>
어떠한 협력에서는 클라이언트의 역할을 맡지만 또 다른 협력에서는 서버의 역할을 맡으며<br/>
**두 가지의 역할을 동시에 수행**하는 경우가 일반적이다.

그렇기 때문에 수신하는 메시지 집합에 대해서만 초점을 맞출 것이 아니라 <br/>
본 클래스가 <u>외부에 전송하는 메시지 집합</u>에 대해서도 함께 고려해야 한다.

> #### ⁜ 메시지 
> : 메세지(message)는 객체들이 **협력하기 위해** 사용할 수 있는 <u>유일한 의사소통 수단</u>
> 
> - "**오퍼레이션 명**(operation name)"과 "**인자**(argument)"로 구성
> 
> ---
> #### ⁜ 메시지 전송 
> : 한 객체가 <u>다른 객체에게 도움을 요청하는 것</u><br/><br/>
> _* **메시지 패싱**(message **passing**) 이라고도 불림_<br/>
> _* `수신자` + `오퍼레이션 명` + `인자` | ex. `condition.isSatisfiedBy(screening)`_
> - 메시지를 **전송**하는 객체 : **메시지 전송자**(message **sender**)
> - 메시지를 **수신**하는 객체 : **메시지 수신자**(message **receiver**)
>
> ---
> #### ⁜ 메서드
>  : 메시지를 수신했을 때, 실제로 실행되는 함수 또는 프로시저<br/><br/>
> _* 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 로직이 달라질 수 있다.<br/>
> 예를 들어 `DiscountPolicy`인터페이스가 수신자이더라도 <br/>
> lazy binding된 실체화 객체가 무엇인지에 따라 이름이 같은 오퍼레이션 명이지만<br/> 
> 실행되는 내부 구현 로직은 상이하다._<br/><br/>

<br/>

메시지 전송자는 <u>수신자가 어떤 실체화 클래스의 인스턴스</u>인지, <u>어떤 방식으로 요청을 처리</u>하는지 모르더라도<br/>
<u>**어떤 메시지를 전송해야 하는지**만</u> 알면 되기 때문에<br/>
메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 **느슨하게 결합**될 수 있도록 한다.<br/>
( _이처럼 실행 시점에 lazy binding하는 방식으로 결합도를 낮추며 유연성과 확장성을 높인 코드가 탄생한다._ )

<br/>

### Public Interface 와 Operation의 관계
객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스(Public Interface)라 하는 것을 앞서 배웠다.

그리고 **오퍼레이션**(**Operation**)은 그 <u>퍼블릭 인터페이스에 포함된 메시지</u>라고 볼 수 있는데<br/>
다시 말해 <u>수행 가능한 어떤 행동에 대한 **추상화**</u>인 것이다.

이 또한 실체화될 경우 내부 로직은 서로 상이할 수 있으나 <br/>
추상화 타입으로 사용되는 인터페이스에 정의되어 있는 메서드가 오퍼레이션에 해당하는 것이다.

> #### ⁜ UML(Unified Modeling Language)에서의 오퍼레이션(Operation)
> 
> - Operation 이란 <u>실행하기 위해 객체가 호출될 수 있는 변환이난 정의에 관한 명세</u>이다.
> - **인터페이스의 각 요소**를 오퍼레이션이라 할 수 있다.
> - 오퍼레이션은 구현이 아닌 **추상화**이며 <u>메서드</u>는 **오퍼레이션을 구현**한 것이다.
>   - 메서드는 오퍼레이션에 대한 구현이며 **오퍼레이션과 연관된 알고리즘 또는 절차**를 명시한다.
> 
>_* 퍼블릭 인터페이스와 메시지의 관점에서는 "메서드 호출"보다는 "**오퍼레이션 호출**"이라는 말이 더 적절하다._
> 
> _-Larman04-_

<br/>

### 시그니처(Signature)

- <u>**오퍼레이션(메서드)의 이름**</u>과 <u>**파라미터 목록**</u>을 합쳐 "시그니처(signature)"라 부른다.
  - _실행 코드 없이 시그니처 정의_ = 오퍼레이션
  - _시그니처 구현_ = 메서드

하나의 오퍼레이션에 대해 <u>오직 1대1로 하나의 메서드만 존재한다면</u> **추상화의 필요성도 사라지기 때문에**<br/>
사실 오퍼레이션과 메서드를 구분할 필요가 없어진다.

하지만 다형성을 활용하기 위해서는 <br/>
하나의 오퍼레이션에 대해 다양한 메서드를 구현해야하만 하고
이에 따라 "오퍼레이션의 관점에서의 **다형성**"은 
<u>동일한 오퍼레이션 호출에 대해 **서로 다른 메서드들이 실행되는 것**</u>이라고 할 수 있다.

중요한 것은 객체가 수신할 수 있는 메시지가<br/>
퍼블릭 인터페이스를 비롯하여 포함된 오퍼레이션을 결정하게 된다는 점이고

자연스레 **퍼블릭 인터페이스**가 <u>그 객체의 품질을 결정</u>하게 되기 때문에<br/>
결국 **메시지**가 <u>객체의 품질을 결정</u>한다고 볼 수 있다.

<br/>
<br/>

---
## 인터페이스와 설계 품질
좋은 인터페이스는 **최소한**의 인터페이스와 **추상적**인 인터페이스라는 조건을 만족해야 한다.
- 최소한의 인터페이스 : 꼭 필요한 오퍼레이션만 포함
- 추상적인 인터페이스 : 어떻게 수행하는지가 아닌 무엇을 하는지를 표현

책임 주도 설계 방법은 메시지를 먼저 선택하여 협력과는 무관한 오퍼레이션이 스며드는 것을 방지하기 때문에
최소한의 오퍼레이션만 포함할 수 있게 된다.

또한, 객체가 메시지가 아닌 객체를 선택하게 함으로써
클라이언트의 의도를 메시지에 직관적으로 표현할 수 있게 되므로 추상적인 오퍼레이션을 사용할 수 있다.

더 나아가 퍼블릭 인터페이스의 품질을 더 향상 시킬 수 있는 원칙과 기법이 존재하는데
이는 아래와 같다.
- `디미터` 법칙
- 질문이 아닌 명령
- 의도가 보이는 인터페이스
- [`명령-쿼리` 분리](#명령-쿼리-분리)

### 디미터 법칙 (Law of Demeter)
협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙으로<br/>
객체의 <u>내부 구조에 강하게 결합되지 않도록</u> **협력 경로**를 **제한**하라는 내용이다.

> _낯선 자에게 말하지 말라. 오직 인접한 이웃하고만 말하라._ <br/>_-Larman04 & Metz12-_

본 법칙을 따르기 위해서는
클래스가 특정 조건을 만족하는 대상에게만 메시지를 전송하도록 설계 및 프로그래밍 해야한다.

> M이 <u>**메시지를 전송할 수 있는** 모든 객체</u>는 **아래 설명된 클래스의 인스턴스**여야 한다.<br/>
> - M의 **인자로 전달된** 클래스 ( == C 자체 )
> - **C**의 **인스턴스 변수**의 클래스
> > - `this`**객체**
> > - 메서드의 **매개변수**
> > - `this`의 **속성**
> > - `this`의 속성인 **컬렉션의 요소**
> > - <u>메서드 내</u>에서 생성된 **로컬 객체**
> 
> 단, `M에 의해 생성된 객체` | `M이 호출하는 메서드에 의해 생성된 객체` | `전역 변수로 선언된 객체` 모두 M의 인자로 간주한다.<br/><br/>
>_( 모든 클래스 : C , C에 구현된 모든 메서드 : M )_

<br/>

디미터 법칙을 따르게 된다면 메시지 수신자의 **내부 구조가 전송자에게 노출되지 않으며**,<br/>
메시지 전송자는 **수신자의 내부 구현에 결합되지 않기** 때문에<br/>
클라이언트와 서버 사이에 **낮은 결합도**를 유지할 수 있다.

하지만 우후죽순으로 해당 법칙을 수용하게 되면<br/> 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다는 점을 명심해야 한다.

<br/>

사실 캡슐화를 다른 관점에서 표현한 것이 디미터 법칙이라 볼 수 있는데<br/>
"캡슐화 원칙"은 클래스 **내부 구현을 감추는 것에 중점**을 둔다면<br/>
"디미터 법칙"은 협력하는 클래스의 **캡슐화를 지키기 위해** <u>접근해야 하는 요소를 제한</u>하는 것에 중점을 둔다.

(_ex. `screening.getMovie().getDiscountConditions()` 와 같이 <br/>
외부에서 전송자가 수신자의 내부 구조에 대해 연속적으로 물어보며 메시지의 이동 방향이 모두 보여지는 **기차 충돌(train wreek)** 코드는 <br/>
디미터 법칙을 어긴 코드이다._)

<br/>

### 명령 지향 ( Tell, Don't Ask )
사실 이 또한 디미터 법칙에서 강조하는 내용으로
훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.

메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후에도 메시지 수신자의 상태를 바꿔서는 안된다.

> 절차 지향 코드는 <u>순차적으로</u> 정보를 **얻은 후에 결정**하고<br/>
> 객체 지향 코드는 <u>객체에게 그것을 하도록</u> **시킨다**. <br/>_- Sharp00 -_

객체 지향의 기본은 **함께 변동성이 높은 정보와 행동**을 하나의 단위. 즉, <u>객체로 통합하는 것</u>인데<br/>
본 원칙을 따르게되면<br/>
**객체의 정보를 이용하는 행동**을 <u>객체 외부가 아닌 **내부**에 위치</u>시키기 때문에<br/>
**밀접하게 연관된 정보와 행동을 함께 가지는 객체**를 만들 수 있다.

그에 따라 메시지를 결정하다보면 자연스레 <u>정보 전문가에게 책임을 할당</u>하게 되고<br/>
<u>높은 응집도</u>를 가진 클래스를 완성시킬 가능성이 높다.

<br/>

객체가 수신할 메시지를 결정하는 과정에서 이러한 명령 원칙과 디미터 법칙을 고려하여<br/>
" _내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하진 않는지_ ", <br/>" _그에 따라 해당 객체가 책임져야 하는 특정 행동이 외부로 노출된 것은 아닌지_ " 를 따져본다면<br/>
퍼블릭 인터페이스의 품질을 향상시킬 수 있다.

하지만 단순히 객체에게 묻지 않고 명령만 한다고 해서 모든 문제가 해결되지 않는다.

훌륭한 인터페이스가 되기 위해선 명령 지향을 넘어 
객체가 _<u>어떻게 작업을 수행하는지를 보여주는 것이 아니라</u>_<br/>
객체가 <u>**무엇**을 하는지</u>를 객체의 <u>**의도가 보이도록** 하는 것</u>도 중요하다.

<br/>

### 의도가 보이는 인터페이스

만약 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓게 되면
발생하는 문제가 2가지 있다.

1. 메서드에 대해 제대로 **커뮤니케이션하지 못한다.**
   - 예를 들어 할인 조건을 파단하는 작업에 대해 `isSatisfiedByPeriod()`와 `isSatisfiedBySequence()` 같이 각 조건 클래스마다 다른 이름의 메서드를 가진다면<br/>동일 작업임에도 불구하고 메서드의 이름이 다르기 때문에 <br/>두 메서드의 내부 구현을 정확히 이해하지 못한다면 동일한 작업을 수행한다는 사실을 파악하기 힘들다.
2. 메서드 수준에서 **캡슐화를 위반**한다.
   - 위 예시를 다시 사용하자면 만약 할인 조건이 바뀌게 될 경우, <br/>
   객체를 변경하는 것 뿐만 아니라 호출하는 메서드까지 모두 수정해야하고<br/>
   더 나아가 협력하는 객체의 종류를 자세하게 알도록 강요하게 된다.

따라서 메서드의 이름을 짓기 위해서는 "어떻게"가 아닌 "**무엇을**" 하는지 드러내야 한다.<br/>

<br/>

> **무엇을 하느냐에 따라** 메서드 이름을 짓는 패턴 = "<u>**의도를 드러내는 선택자(Intention Revealing Selector)**</u>"

무엇을 하는지 나타내기 위해선 <br/>
해당 객체가 **협력 안에서 수행해야 하는 책임**에 관해 고민해야히고 **클라이언트의 의도에 부합하도록** 이름을 지어야 한다.

만약 동일한 메시지에 대해 다양한 처리 방법이 필요하다면 <br/>
애플리케이션 내에서 해당 요소에 대한 **추상화**가 필수적일텐데 <br/>
무엇을 하느냐에 초점을 맞춰 설계하게 되면 오히려 <u>하나의 타입으로 추상화하여 묶기가 더 용이</u>해지고<br/>
그에 따라 **유연한 협력**까지 얻을 수 있게 된다.

<br/>

위 개념을 확장하여 인터페이스 레벨까지 확장한 것이 "<u>**의도를 드러내는 인터페이스(Intention Revealing Interface)**</u>"이다.<br/>
이는 <u>구현과 관련된 모든 정보</u>를 **캡슐화**하고 객체의 **퍼블릭 인터페이스**에는 **<u>협력과 관련된 의도</u>만을 표현**해야 한다는 개념이다.

---
## 원칙의 함점

---
## 명령-쿼리 분리

